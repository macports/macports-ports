--- include/oneapi/tbb/detail/_config.h.orig	2021-12-17 21:40:54.000000000 +0800
+++ include/oneapi/tbb/detail/_config.h	2022-05-04 15:06:56.000000000 +0800
@@ -165,6 +165,10 @@
         #define __TBB_ipf 1
     #elif __i386__||__i386  // __i386 is for Sun OS
         #define __TBB_x86_32 1
+    #elif __powerpc64__ || __ppc64__
+        #define __TBB_PPC64 1
+    #elif __powerpc__ || __ppc__
+        #define __TBB_PPC32 1
     #else
         #define __TBB_generic_arch 1
     #endif


--- include/oneapi/tbb/detail/_machine.h.orig	2021-12-17 21:40:54.000000000 +0800
+++ include/oneapi/tbb/detail/_machine.h	2022-05-04 21:59:14.000000000 +0800
@@ -45,6 +45,30 @@
 #include <float.h> // _control87
 #endif
 
+// Darwin PPC:
+#include <stdint.h>
+#include <unistd.h>
+
+#if __powerpc64__ || __ppc64__
+    #define __TBB_WORDSIZE 8
+#else
+    #define __TBB_WORDSIZE 4
+#endif
+
+// Traditionally Power Architecture is big-endian.
+// Little-endian could be just an address manipulation (compatibility with TBB not verified),
+// or normal little-endian (on more recent systems). Embedded PowerPC systems may support
+// page-specific endianness, but then one endianness must be hidden from TBB so that it still sees only one.
+#if __BIG_ENDIAN__ || (defined(__BYTE_ORDER__) && __BYTE_ORDER__==__ORDER_BIG_ENDIAN__)
+    #define __TBB_ENDIANNESS __TBB_ENDIAN_BIG
+#elif __LITTLE_ENDIAN__ || (defined(__BYTE_ORDER__) && __BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__)
+    #define __TBB_ENDIANNESS __TBB_ENDIAN_LITTLE
+#elif defined(__BYTE_ORDER__)
+    #define __TBB_ENDIANNESS __TBB_ENDIAN_UNSUPPORTED
+#else
+    #define __TBB_ENDIANNESS __TBB_ENDIAN_DETECT
+#endif
+
 #if __TBB_GLIBCXX_THIS_THREAD_YIELD_BROKEN
 #include <sched.h> // sched_yield
 #else
@@ -148,7 +172,7 @@
     uintptr_t j, i = x;
     __asm__("bsr %1,%0" : "=r"(j) : "r"(i));
     return j;
-#elif __powerpc__ || __POWERPC__
+#elif __powerpc__ || __ppc__ || __powerpc64__ || __ppc64__
     #if __TBB_WORDSIZE==8
     __asm__ __volatile__ ("cntlzd %0,%0" : "+r"(x));
     return 63 - static_cast<intptr_t>(x);


--- include/oneapi/tbb/task_group.h.orig	2021-12-17 21:40:54.000000000 +0800
+++ include/oneapi/tbb/task_group.h	2022-05-04 15:25:15.000000000 +0800
@@ -202,9 +202,9 @@
         bool reserved3          : 1;
         bool reserved4          : 1;
     } my_traits;
-
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
     static_assert(sizeof(context_traits) == 1, "Traits shall fit into one byte.");
-
+#endif
     static constexpr std::uint8_t may_have_children = 1;
     //! The context internal state (currently only may_have_children).
     std::atomic<std::uint8_t> my_state;
@@ -430,9 +430,9 @@
     friend struct r1::task_group_context_impl;
     friend class task_group_base;
 }; // class task_group_context
-
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
 static_assert(sizeof(task_group_context) == 128, "Wrong size of task_group_context");
-
+#endif
 enum task_group_status {
     not_complete,
     complete,

