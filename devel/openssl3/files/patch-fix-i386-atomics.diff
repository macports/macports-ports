From b6c37e369f66a39eebd9e948f0a08e023bd7d304 Mon Sep 17 00:00:00 2001
From: "Kirill A. Korinsky" <kirill@korins.ky>
Date: Sun, 10 Apr 2022 02:14:24 +0200
Subject: [PATCH] Prevent clang from emitting atomic libcalls

This commit is rebasing of https://github.com/openssl/openssl/pull/16584
to the last master branch.

This PR was used for MacPorts for near of 5 months, since
https://github.com/macports/macports-ports/pull/12848

Fixes: https://github.com/openssl/openssl/issues/16551

Co-authored-by: Tee KOBAYASHI <xtkoba@gmail.com>
Signed-off-by: Kirill A. Korinsky <kirill@korins.ky>
---
 crypto/init.c               |  4 ++--
 crypto/threads_pthread.c    | 17 +++++++++++------
 include/openssl/crypto.h.in |  8 ++++++++
 3 files changed, 21 insertions(+), 8 deletions(-)

diff --git crypto/init.c crypto/init.c
index b7d7ad0ea3..e8fc9e6d60 100644
--- crypto/init.c
+++ crypto/init.c
@@ -34,7 +34,7 @@
 #include <openssl/trace.h>
 
 static int stopped = 0;
-static uint64_t optsdone = 0;
+static CRYPTO_ATOMIC_U64 optsdone = 0;
 
 typedef struct ossl_init_stop_st OPENSSL_INIT_STOP;
 struct ossl_init_stop_st {
@@ -457,7 +457,7 @@ void OPENSSL_cleanup(void)
  */
 int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings)
 {
-    uint64_t tmp;
+    CRYPTO_ATOMIC_U64 tmp;
     int aloaddone = 0;
 
    /* Applications depend on 0 being returned when cleanup was already done */
diff --git crypto/threads_pthread.c crypto/threads_pthread.c
index 46b8459b5e..0071f6cbcf 100644
--- crypto/threads_pthread.c
+++ crypto/threads_pthread.c
@@ -228,9 +228,11 @@ int CRYPTO_atomic_or(uint64_t *val, uint64_t op, uint64_t *ret,
                      CRYPTO_RWLOCK *lock)
 {
 # if defined(__GNUC__) && defined(__ATOMIC_ACQ_REL) && !defined(BROKEN_CLANG_ATOMICS)
-    if (__atomic_is_lock_free(sizeof(*val), val)) {
-        *ret = __atomic_or_fetch(val, op, __ATOMIC_ACQ_REL);
-        return 1;
+    if (CRYPTO_ATOMIC_IS_ALIGNED_U64(val) &&
+        __atomic_is_lock_free(sizeof(*val), (CRYPTO_ATOMIC_U64 *)val)) {
+            *ret = __atomic_or_fetch((CRYPTO_ATOMIC_U64 *)val, op,
+                                     __ATOMIC_ACQ_REL);
+            return 1;
     }
 # elif defined(__sun) && (defined(__SunOS_5_10) || defined(__SunOS_5_11))
     /* This will work for all future Solaris versions. */
@@ -253,9 +255,12 @@ int CRYPTO_atomic_or(uint64_t *val, uint64_t op, uint64_t *ret,
 int CRYPTO_atomic_load(uint64_t *val, uint64_t *ret, CRYPTO_RWLOCK *lock)
 {
 # if defined(__GNUC__) && defined(__ATOMIC_ACQUIRE) && !defined(BROKEN_CLANG_ATOMICS)
-    if (__atomic_is_lock_free(sizeof(*val), val)) {
-        __atomic_load(val, ret, __ATOMIC_ACQUIRE);
-        return 1;
+    if (CRYPTO_ATOMIC_IS_ALIGNED_U64(val) &&
+        CRYPTO_ATOMIC_IS_ALIGNED_U64(ret) &&
+        __atomic_is_lock_free(sizeof(*val), (CRYPTO_ATOMIC_U64 *)val)) {
+            __atomic_load((CRYPTO_ATOMIC_U64 *)val, (CRYPTO_ATOMIC_U64 *)ret,
+                          __ATOMIC_ACQUIRE);
+            return 1;
     }
 # elif defined(__sun) && (defined(__SunOS_5_10) || defined(__SunOS_5_11))
     /* This will work for all future Solaris versions. */
diff --git include/openssl/crypto.h.in include/openssl/crypto.h.in
index df7abb2a29..81b1d48c52 100644
--- include/openssl/crypto.h.in
+++ include/openssl/crypto.h.in
@@ -85,6 +85,14 @@ __owur int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock);
 int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock);
 void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock);
 
+# if defined(__GNUC__) && !defined(OPENSSL_NO_STDINT_H)
+typedef __attribute__((__aligned__(8))) uint64_t CRYPTO_ATOMIC_U64;
+#  define CRYPTO_ATOMIC_IS_ALIGNED_U64(val) (((uintptr_t)(val) & (8 - 1)) == 0)
+# else
+typedef uint64_t CRYPTO_ATOMIC_U64;
+#  define CRYPTO_ATOMIC_IS_ALIGNED_U64(val) (1)
+# endif
+
 int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock);
 int CRYPTO_atomic_or(uint64_t *val, uint64_t op, uint64_t *ret,
                      CRYPTO_RWLOCK *lock);
-- 
2.35.1

