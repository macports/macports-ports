From ecf08bc56151923b1539b508f4984baf19db8b4e Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <vital.had@gmail.com>
Date: Tue, 3 Jan 2023 04:07:54 +0700
Subject: [PATCH 2/3] Fixes for older macOS

---
 folly/File.cpp                       |  4 +++-
 folly/SocketAddress.cpp              |  4 ++++
 folly/io/async/AsyncServerSocket.cpp | 12 ++++++++++++
 folly/io/async/AsyncUDPSocket.cpp    | 10 ++++++++++
 folly/net/TcpInfoTypes.h             |  2 +-
 folly/portability/Time.cpp           | 24 +++++++++++++++++++++---
 folly/system/ThreadId.cpp            | 14 +++++++++++---
 7 files changed, 62 insertions(+), 8 deletions(-)

diff --git a/folly/File.cpp b/folly/File.cpp
index 401eb7a01..d34a67f30 100644
--- a/folly/File.cpp
+++ b/folly/File.cpp
@@ -120,8 +120,10 @@ File File::dupCloseOnExec() const {
     int fd;
 #ifdef _WIN32
     fd = ::dup(fd_);
-#else
+#elseif defined(F_DUPFD_CLOEXEC)
     fd = ::fcntl(fd_, F_DUPFD_CLOEXEC, 0);
+#else
+    fd = ::dup(fd_);
 #endif
     checkUnixError(fd, "dup() failed");
 
diff --git a/folly/SocketAddress.cpp b/folly/SocketAddress.cpp
index 2fb1fac9e..fe6231183 100644
--- a/folly/SocketAddress.cpp
+++ b/folly/SocketAddress.cpp
@@ -125,6 +125,10 @@ struct GetAddrInfoError {
 
 namespace folly {
 
+#ifndef AI_NUMERICSERV		
+#define AI_NUMERICSERV 0		
+#endif
+
 bool SocketAddress::isPrivateAddress() const {
   auto family = getFamily();
   if (family == AF_INET || family == AF_INET6) {
diff --git a/folly/io/async/AsyncServerSocket.cpp b/folly/io/async/AsyncServerSocket.cpp
index 127c88e75..796d77380 100644
--- a/folly/io/async/AsyncServerSocket.cpp
+++ b/folly/io/async/AsyncServerSocket.cpp
@@ -47,6 +47,18 @@ namespace folly {
 #define TCP_SAVED_SYN 28
 #endif
 
+#ifndef AI_NUMERICSERV		
+#define AI_NUMERICSERV 0		
+#endif
+
+#ifndef IPV6_TCLASS
+#if defined(__GNU__)
+#define IPV6_TCLASS 61
+#elif defined(__APPLE__)
+#define IPV6_TCLASS 36
+#endif
+#endif
+
 static constexpr bool msgErrQueueSupported =
 #ifdef FOLLY_HAVE_MSG_ERRQUEUE
     true;
diff --git a/folly/io/async/AsyncUDPSocket.cpp b/folly/io/async/AsyncUDPSocket.cpp
index 24477baad..7ed5d9d08 100644
--- a/folly/io/async/AsyncUDPSocket.cpp
+++ b/folly/io/async/AsyncUDPSocket.cpp
@@ -36,6 +36,14 @@
 #define SO_REUSEPORT 15
 #endif
 
+#ifndef IPV6_TCLASS
+#if defined(__GNU__)
+#define IPV6_TCLASS 61
+#elif defined(__APPLE__)
+#define IPV6_TCLASS 36
+#endif
+#endif
+
 #if FOLLY_HAVE_VLA
 #define FOLLY_HAVE_VLA_01 1
 #else
@@ -257,6 +265,7 @@ void AsyncUDPSocket::init(sa_family_t family, BindOptions bindOptions) {
             "failed to set IPV6_RECVTCLASS on the socket",
             errno);
       }
+  #ifdef IP_RECVTOS
     } else if (family == AF_INET) {
       if (netops::setsockopt(
               socket, IPPROTO_IP, IP_RECVTOS, &flag, sizeof(flag)) != 0) {
@@ -265,6 +274,7 @@ void AsyncUDPSocket::init(sa_family_t family, BindOptions bindOptions) {
             "failed to set IP_RECVTOS on the socket",
             errno);
       }
+  #endif
     }
   }
 
diff --git a/folly/net/TcpInfoTypes.h b/folly/net/TcpInfoTypes.h
index 09a8a9907..d3a6caac4 100644
--- a/folly/net/TcpInfoTypes.h
+++ b/folly/net/TcpInfoTypes.h
@@ -179,7 +179,7 @@ struct tcp_info_legacy {
   __u32 tcpi_total_retrans;
 };
 
-#elif defined(__APPLE__)
+#elif defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED > 101003
 #define FOLLY_HAVE_TCP_INFO 1
 using tcp_info = ::tcp_connection_info;
 const int tcp_info_sock_opt = TCP_CONNECTION_INFO;
diff --git a/folly/portability/Time.cpp b/folly/portability/Time.cpp
index 88f00150f..3f882b473 100644
--- a/folly/portability/Time.cpp
+++ b/folly/portability/Time.cpp
@@ -37,11 +37,13 @@ static void duration_to_ts(
 #if !FOLLY_HAVE_CLOCK_GETTIME || FOLLY_FORCE_CLOCK_GETTIME_DEFINITION
 #if __MACH__
 #include <errno.h>
+#include <sys/types.h>
 #include <mach/mach_init.h> // @manual
 #include <mach/mach_port.h> // @manual
 #include <mach/mach_time.h> // @manual
 #include <mach/mach_types.h> // @manual
 #include <mach/task.h> // @manual
+#include <mach/task_info.h> // for MacOS <= Lion
 #include <mach/thread_act.h> // @manual
 #include <mach/vm_map.h> // @manual
 
@@ -64,6 +66,7 @@ static int clock_process_cputime(struct timespec* ts) {
   }
 
   // Get CPU usage for terminated threads.
+#ifdef MACH_TASK_BASIC_INFO
   mach_task_basic_info task_basic_info;
   mach_msg_type_number_t task_basic_info_count = MACH_TASK_BASIC_INFO_COUNT;
   kern_result = task_info(
@@ -74,6 +77,18 @@ static int clock_process_cputime(struct timespec* ts) {
   if (UNLIKELY(kern_result != KERN_SUCCESS)) {
     return -1;
   }
+#else
+  task_basic_info task_basic_info;
+  mach_msg_type_number_t task_basic_info_count = TASK_BASIC_INFO_COUNT;
+  kern_result = task_info(
+      mach_task_self(),
+      TASK_BASIC_INFO,
+      (thread_info_t)&task_basic_info,
+      &task_basic_info_count);
+  if (UNLIKELY(kern_result != KERN_SUCCESS)) {
+    return -1;
+  }
+#endif
 
   auto cputime = time_value_to_ns(thread_times_info.user_time) +
       time_value_to_ns(thread_times_info.system_time) +
@@ -99,6 +114,7 @@ static int clock_thread_cputime(struct timespec* ts) {
   return 0;
 }
 
+#if defined(__APPLE__) && __MAC_OS_X_VERSION_MIN_REQUIRED > 101100
 FOLLY_ATTR_WEAK int clock_gettime(clockid_t clk_id, struct timespec* ts) {
   switch (folly::to_underlying(clk_id)) {
     case CLOCK_REALTIME: {
@@ -120,6 +136,7 @@ FOLLY_ATTR_WEAK int clock_gettime(clockid_t clk_id, struct timespec* ts) {
       return -1;
   }
 }
+#endif
 
 int clock_getres(clockid_t clk_id, struct timespec* ts) {
   if (clk_id != CLOCK_MONOTONIC) {
@@ -190,6 +207,7 @@ extern "C" int clock_getres(clockid_t clock_id, struct timespec* res) {
       res->tv_nsec = time_t(perSec * kNsPerSec);
       return 0;
     }
+#if defined(__APPLE__) && __MAC_OS_X_VERSION_MIN_REQUIRED > 101100
     case CLOCK_PROCESS_CPUTIME_ID:
     case CLOCK_THREAD_CPUTIME_ID: {
       DWORD adj, timeIncrement;
@@ -198,12 +216,11 @@ extern "C" int clock_getres(clockid_t clock_id, struct timespec* res) {
         errno = EINVAL;
         return -1;
       }
-
       res->tv_sec = 0;
       res->tv_nsec = long(timeIncrement * 100);
       return 0;
     }
-
+#endif
     default:
       errno = EINVAL;
       return -1;
@@ -236,6 +253,7 @@ extern "C" int clock_gettime(clockid_t clock_id, struct timespec* tp) {
       duration_to_ts(now, tp);
       return 0;
     }
+#if defined(__APPLE__) && __MAC_OS_X_VERSION_MIN_REQUIRED > 101100
     case CLOCK_PROCESS_CPUTIME_ID: {
       if (!GetProcessTimes(
               GetCurrentProcess(),
@@ -268,7 +286,7 @@ extern "C" int clock_gettime(clockid_t clock_id, struct timespec* tp) {
           filetimeToUnsignedNanos(kernalTime) +
               filetimeToUnsignedNanos(userTime));
     }
-
+#endif
     default:
       errno = EINVAL;
       return -1;
diff --git a/folly/system/ThreadId.cpp b/folly/system/ThreadId.cpp
index e426b39e1..b297d671f 100644
--- a/folly/system/ThreadId.cpp
+++ b/folly/system/ThreadId.cpp
@@ -40,9 +40,17 @@ namespace detail {
 
 uint64_t getOSThreadIDSlow() {
 #if __APPLE__
-  uint64_t tid;
-  pthread_threadid_np(nullptr, &tid);
-  return tid;
+  #if MAC_OS_X_VERSION_MAX_ALLOWED < 1070
+    uint64_t tid;
+    tid = pthread_mach_thread_np(pthread_self());
+  #elif MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    uint64_t tid;
+    tid = pthread_mach_thread_np(pthread_self());
+  #else
+    uint64_t tid;
+    pthread_threadid_np(nullptr, &tid);
+    return tid;
+  #endif
 #elif defined(_WIN32)
   return uint64_t(GetCurrentThreadId());
 #elif defined(__FreeBSD__)
-- 
2.39.0

