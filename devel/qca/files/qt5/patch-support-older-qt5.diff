diff --git a/CMakeLists.txt b/CMakeLists.txt
index 6e290245cb9d4c7b6a208dbe245aab3105f4fd0a..ffaeaf43d6d8da08084dabe9a649827427946537 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -50,7 +50,8 @@ if(QT6)
 else()
   message(STATUS "Building Qt 5 version")
   set(Qt5_NO_LINK_QTMAIN ON)
-  find_package(Qt5 5.14 REQUIRED Core)
+  # Support down to Qt 5.6 (aka OS X 10.7)
+  find_package(Qt5 5.6 REQUIRED Core)
 endif()
 
 set(CMAKE_AUTOMOC ON)
diff --git a/plugins/qca-gnupg/gpgaction.cpp b/plugins/qca-gnupg/gpgaction.cpp
index c739dd1a7f63c18fe68f256ac91622299460215e..22efab0d2a0171da55173269d4a785d36cc2d501 100644
--- a/plugins/qca-gnupg/gpgaction.cpp
+++ b/plugins/qca-gnupg/gpgaction.cpp
@@ -586,6 +586,12 @@ void GpgAction::processStatusLine(const QString &line)
     QString s, rest;
     s = nextArg(line, &rest);
 
+#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
+    const auto splitPars = Qt::SkipEmptyParts;
+#else
+    const auto splitPars = QString::SkipEmptyParts;
+#endif
+
     if (s == QLatin1String("NODATA")) {
         // only set this if it'll make it better
         if (curError == GpgOp::ErrorUnknown)
@@ -665,12 +671,12 @@ void GpgAction::processStatusLine(const QString &line)
         output.verifyResult = GpgOp::VerifyBad;
     } else if (s == QLatin1String("ERRSIG")) {
         output.wasSigned       = true;
-        const QStringList list = rest.split(QLatin1Char(' '), Qt::SkipEmptyParts);
+        const QStringList list = rest.split(QLatin1Char(' '), splitPars);
         output.signerId        = list[0];
         output.timestamp       = getTimestamp(list[4]);
         output.verifyResult    = GpgOp::VerifyNoKey;
     } else if (s == QLatin1String("VALIDSIG")) {
-        const QStringList list = rest.split(QLatin1Char(' '), Qt::SkipEmptyParts);
+        const QStringList list = rest.split(QLatin1Char(' '), splitPars);
         output.timestamp       = getTimestamp(list[2]);
     }
 }
diff --git a/plugins/qca-gnupg/utils.cpp b/plugins/qca-gnupg/utils.cpp
index f4ecffa013e51d505938b9393a8196edff252583..8ee4fc3fb987b3dea78f910ef995c16487b65158 100644
--- a/plugins/qca-gnupg/utils.cpp
+++ b/plugins/qca-gnupg/utils.cpp
@@ -130,7 +130,12 @@ QString find_bin()
     const QString pathSep = QStringLiteral(":");
 #endif
 
-    QStringList paths = QString::fromLocal8Bit(qgetenv("PATH")).split(pathSep, Qt::SkipEmptyParts);
+#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
+    const auto splitPars = Qt::SkipEmptyParts;
+#else
+    const auto splitPars = QString::SkipEmptyParts;
+#endif
+    QStringList paths = QString::fromLocal8Bit(qgetenv("PATH")).split(pathSep, splitPars);
 
 #ifdef Q_OS_MAC
     // On Mac OS bundled always uses system default PATH
diff --git a/plugins/qca-logger/qca-logger.cpp b/plugins/qca-logger/qca-logger.cpp
index a80cc365e268f5d88a8eed988ee8cfc61008a6b6..e77afdf9a4fd3c5160224e8facb422815c872fdd 100644
--- a/plugins/qca-logger/qca-logger.cpp
+++ b/plugins/qca-logger/qca-logger.cpp
@@ -25,6 +25,12 @@
 
 #include <cstdlib>
 
+#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
+#   define ENDL Qt::endl
+#else
+#   define ENDL endl
+#endif
+
 using namespace QCA;
 
 namespace loggerQCAPlugin {
@@ -47,14 +53,14 @@ public:
 
     void logTextMessage(const QString &message, enum QCA::Logger::Severity severity) override
     {
-        _stream << now() << " " << severityName(severity) << " " << message << Qt::endl;
+        _stream << now() << " " << severityName(severity) << " " << message << ENDL;
     }
 
     void logBinaryMessage(const QByteArray &blob, enum QCA::Logger::Severity severity) override
     {
         Q_UNUSED(blob);
         _stream << now() << " " << severityName(severity) << " "
-                << "Binary blob not implemented yet" << Qt::endl;
+                << "Binary blob not implemented yet" << ENDL;
     }
 
 private:
diff --git a/src/qca_cert.cpp b/src/qca_cert.cpp
index 610cd1f1a66c9b793274678786b64f480b48516a..12b4663c1a113865923001d5bc851471c826405c 100644
--- a/src/qca_cert.cpp
+++ b/src/qca_cert.cpp
@@ -32,6 +32,12 @@
 
 #include <cstdlib>
 
+#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
+#   define SPLITPARS Qt::KeepEmptyParts
+#else
+#   define SPLITPARS QString::KeepEmptyParts
+#endif
+
 namespace QCA {
 
 Provider::Context *getContext(const QString &type, const QString &provider);
@@ -1250,7 +1256,7 @@ static QByteArray ipaddr_str2bin(const QString &str)
 {
     // ipv6
     if (str.contains(QLatin1Char(':'))) {
-        const QStringList parts = str.split(QLatin1Char(':'), Qt::KeepEmptyParts);
+        const QStringList parts = str.split(QLatin1Char(':'), SPLITPARS);
         if (parts.count() < 3 || parts.count() > 8)
             return QByteArray();
 
@@ -1307,7 +1313,7 @@ static QByteArray ipaddr_str2bin(const QString &str)
 
         return ipv6;
     } else if (str.contains(QLatin1Char('.'))) {
-        const QStringList parts = str.split(QLatin1Char('.'), Qt::KeepEmptyParts);
+        const QStringList parts = str.split(QLatin1Char('.'), SPLITPARS);
         if (parts.count() != 4)
             return QByteArray();
 
@@ -1349,7 +1355,7 @@ static bool cert_match_domain(const QString &certname, const QString &acedomain)
         return false;
 
     // hack into parts, and require at least 1 part
-    const QStringList parts_name = name.split(QLatin1Char('.'), Qt::KeepEmptyParts);
+    const QStringList parts_name = name.split(QLatin1Char('.'), SPLITPARS);
     if (parts_name.isEmpty())
         return false;
 
@@ -1361,7 +1367,7 @@ static bool cert_match_domain(const QString &certname, const QString &acedomain)
     if (parts_name.count() >= 2 && parts_name[parts_name.count() - 2].contains(QLatin1Char('*')))
         return false;
 
-    const QStringList parts_compare = acedomain.split(QLatin1Char('.'), Qt::KeepEmptyParts);
+    const QStringList parts_compare = acedomain.split(QLatin1Char('.'), SPLITPARS);
     if (parts_compare.isEmpty())
         return false;
 
diff --git a/src/qca_core.cpp b/src/qca_core.cpp
index 19cbff9afcd89b6e99a60f17786a3f9102c63a42..1be2cb895ef6d844b4130a36342743335ec9654c 100644
--- a/src/qca_core.cpp
+++ b/src/qca_core.cpp
@@ -353,7 +353,12 @@ bool isSupported(const QStringList &features, const QString &provider)
 
 bool isSupported(const char *features, const QString &provider)
 {
-    return isSupported(QString::fromLatin1(features).split(QLatin1Char(','), Qt::SkipEmptyParts), provider);
+#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
+    const auto splitPars = Qt::SkipEmptyParts;
+#else
+    const auto splitPars = QString::SkipEmptyParts;
+#endif
+    return isSupported(QString::fromLatin1(features).split(QLatin1Char(','), splitPars), provider);
 }
 
 QStringList supportedFeatures()
diff --git a/tools/qcatool/main.cpp b/tools/qcatool/main.cpp
index b9ad99742df241d95745d362898b52675a22e3d6..ba009b9832ecf8e862bf89263ffcec5362f59b06 100644
--- a/tools/qcatool/main.cpp
+++ b/tools/qcatool/main.cpp
@@ -31,6 +31,14 @@
 #include "import_plugins.h"
 #endif
 
+#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
+#   define ENDL Qt::endl
+#   define SPLITPARS Qt::KeepEmptyParts
+#else
+#   define ENDL endl
+#   define SPLITPARS QString::KeepEmptyParts
+#endif
+
 const char *const APPNAME = "qcatool";
 const char *const EXENAME = "qcatool";
 const char *const VERSION = QCA_VERSION_STR;
@@ -85,14 +93,14 @@ public:
 
     void logTextMessage(const QString &message, enum QCA::Logger::Severity severity) override
     {
-        _stream << now() << " " << severityName(severity) << " " << message << Qt::endl;
+        _stream << now() << " " << severityName(severity) << " " << message << endl;
     }
 
     void logBinaryMessage(const QByteArray &blob, enum QCA::Logger::Severity severity) override
     {
         Q_UNUSED(blob);
         _stream << now() << " " << severityName(severity) << " "
-                << "Binary blob not implemented yet" << Qt::endl;
+                << "Binary blob not implemented yet" << endl;
     }
 
 private:
@@ -124,7 +132,7 @@ static void output_plugin_diagnostic_text()
     QCA::clearPluginDiagnosticText();
     if (str[str.length() - 1] == QLatin1Char('\n'))
         str.truncate(str.length() - 1);
-    const QStringList lines = str.split(QLatin1Char('\n'), Qt::KeepEmptyParts);
+    const QStringList lines = str.split(QLatin1Char('\n'), SPLITPARS);
     for (int n = 0; n < lines.count(); ++n)
         fprintf(stderr, "plugin: %s\n", qPrintable(lines[n]));
 }
@@ -135,7 +143,7 @@ static void output_keystore_diagnostic_text()
     QCA::KeyStoreManager::clearDiagnosticText();
     if (str[str.length() - 1] == QLatin1Char('\n'))
         str.truncate(str.length() - 1);
-    const QStringList lines = str.split(QLatin1Char('\n'), Qt::KeepEmptyParts);
+    const QStringList lines = str.split(QLatin1Char('\n'), SPLITPARS);
     for (int n = 0; n < lines.count(); ++n)
         fprintf(stderr, "keystore: %s\n", qPrintable(lines[n]));
 }
@@ -145,7 +153,7 @@ static void output_message_diagnostic_text(QCA::SecureMessage *msg)
     QString str = msg->diagnosticText();
     if (str[str.length() - 1] == QLatin1Char('\n'))
         str.truncate(str.length() - 1);
-    const QStringList lines = str.split(QLatin1Char('\n'), Qt::KeepEmptyParts);
+    const QStringList lines = str.split(QLatin1Char('\n'), SPLITPARS);
     for (int n = 0; n < lines.count(); ++n)
         fprintf(stderr, "message: %s\n", qPrintable(lines[n]));
 }
diff --git a/unittest/bigintunittest/bigintunittest.cpp b/unittest/bigintunittest/bigintunittest.cpp
index a94d15cc4db598d42b6d6d884be9a6186d27e76c..c4b6812034f50e6206d83e3d292df60cf315b5b6 100644
--- a/unittest/bigintunittest/bigintunittest.cpp
+++ b/unittest/bigintunittest/bigintunittest.cpp
@@ -30,6 +30,12 @@
 #include "import_plugins.h"
 #endif
 
+#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
+#   define ENDL Qt::endl
+#else
+#   define ENDL endl
+#endif
+
 class BigIntUnitTest : public QObject
 {
     Q_OBJECT
@@ -87,7 +93,7 @@ void BigIntUnitTest::allTests()
     // Check if the stream operator is any good
     QString     testString;
     QTextStream ts(&testString, QIODevice::WriteOnly);
-    ts << a << b << c << Qt::endl;
+    ts << a << b << c << ENDL;
     QCOMPARE(testString, QStringLiteral("4000000000000-40000000000002000000000000\n"));
 
     // Botan's addition tests
