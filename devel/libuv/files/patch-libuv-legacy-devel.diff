--- ./src/unix/darwin.c	2025-04-25 03:50:27.000000000 -0600
+++ ./src/unix/darwin.c	2025-07-07 22:31:49.000000000 -0600
@@ -25,6 +25,7 @@
 #include <stdint.h>
 #include <errno.h>
 
+#include <dlfcn.h>
 #include <mach/mach.h>
 #include <mach/mach_time.h>
 #include <mach-o/dyld.h> /* _NSGetExecutablePath */
@@ -33,9 +34,9 @@
 #include <unistd.h>  /* sysconf */
 
 static uv_once_t once = UV_ONCE_INIT;
+static uint64_t (*time_func)(void);
 static mach_timebase_info_data_t timebase;
 
-
 int uv__platform_loop_init(uv_loop_t* loop) {
   loop->cf_state = NULL;
 
@@ -54,12 +55,16 @@
 static void uv__hrtime_init_once(void) {
   if (KERN_SUCCESS != mach_timebase_info(&timebase))
     abort();
+
+  time_func = (uint64_t (*)(void)) dlsym(RTLD_DEFAULT, "mach_continuous_time");
+  if (time_func == NULL)
+    time_func = mach_absolute_time;
 }
 
 
 uint64_t uv__hrtime(uv_clocktype_t type) {
   uv_once(&once, uv__hrtime_init_once);
-  return mach_continuous_time() * timebase.numer / timebase.denom;
+  return time_func() * timebase.numer / timebase.denom;
 }
 
 
--- ./src/unix/fs.c	2025-04-25 03:50:27.000000000 -0600
+++ ./src/unix/fs.c	2025-07-07 22:28:08.000000000 -0600
@@ -1073,7 +1073,8 @@
     return -1;
   }
 /* sendfile() on iOS(arm64) will throw SIGSYS signal cause crash. */
-#elif (defined(__APPLE__) && !TARGET_OS_IPHONE)                               \
+#elif ((defined(__APPLE__) && (MAC_OS_X_VERSION_MAX_ALLOWED >= 1050))         \
+        && !TARGET_OS_IPHONE                  )                               \
     || defined(__DragonFly__)                                                 \
     || defined(__FreeBSD__)
   {
@@ -1442,7 +1443,7 @@
   dst->st_blksize = src->st_blksize;
   dst->st_blocks = src->st_blocks;
 
-#if defined(__APPLE__)
+#if defined(__APPLE__) && (MAC_OS_X_VERSION_MAX_ALLOWED >= 1050)
   dst->st_atim.tv_sec = src->st_atimespec.tv_sec;
   dst->st_atim.tv_nsec = src->st_atimespec.tv_nsec;
   dst->st_mtim.tv_sec = src->st_mtimespec.tv_sec;
--- ./src/unix/process.c	2025-04-25 03:50:27.000000000 -0600
+++ ./src/unix/process.c	2025-07-07 22:28:08.000000000 -0600
@@ -36,7 +36,9 @@
 #include <poll.h>
 
 #if defined(__APPLE__)
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1050
 # include <spawn.h>
+#endif
 # include <paths.h>
 # include <sys/kauth.h>
 # include <sys/types.h>
@@ -70,6 +72,41 @@
 #define UV_USE_SIGCHLD
 #endif
 
+//on 10.7 and lower we adopt an approach from chrome
+//(admittedly not thread-safe, but it worked fine for some time)
+//that closes all fds on execution, since spawning with
+//FD_CLOEXEC will panic on 10.7 (not sure about 10.6)
+
+#if defined(__APPLE__) && (MAC_OS_X_VERSION_MIN_REQUIRED >= 1070)
+// Sets all file descriptors to close on exec except for stdin, stdout
+// and stderr.
+// TODO(agl): Remove this function. It's fundamentally broken for multithreaded
+// apps.
+void SetAllFDsToCloseOnExec() {
+  const char fd_dir[] = "/dev/fd";
+  opendir(fd_dir);
+  DIR *dir = opendir(fd_dir);
+  closedir(dir); 
+  if (NULL == dir) {
+    fprintf(stderr, "Unable to open %s\n", fd_dir);
+    return;
+  }
+  struct dirent *ent;
+  while ((ent = readdir(dir))) {
+    // Skip . and .. entries.
+    if (ent->d_name[0] == '.')
+      continue;
+    int i = atoi(ent->d_name);
+    // We don't close stdin, stdout or stderr.
+    if (i <= STDERR_FILENO)
+      continue;
+    int flags = fcntl(i, F_GETFD);
+    if ((flags == -1) || (fcntl(i, F_SETFD, flags | FD_CLOEXEC) == -1)) {
+      fprintf(stderr, "fcntl failure.\n");
+    }
+  }
+}
+#endif
 
 #ifdef UV_USE_SIGCHLD
 static void uv__chld(uv_signal_t* handle, int signum) {
@@ -417,7 +454,7 @@
 }
 
 
-#if defined(__APPLE__)
+#if defined(__APPLE__) && (MAC_OS_X_VERSION_MIN_REQUIRED >= 1050)
 typedef struct uv__posix_spawn_fncs_tag {
   struct {
     int (*addchdir_np)(const posix_spawn_file_actions_t *, const char *);
@@ -500,7 +537,13 @@
    *    spawn-sigmask in attributes
    * 4) POSIX_SPAWN_SETSID: Make the process a new session leader if a detached
    *    session was requested. */
-  flags = POSIX_SPAWN_CLOEXEC_DEFAULT |
+  flags = 
+#if (defined(__APPLE__) && (MAC_OS_X_VERSION_MIN_REQUIRED >= 1080)) || \
+     !defined(__APPLE) 
+          //CLOEXEC works properly on 10.8 and higher (maybe 10.6),
+          //but panics on 10.7. it's fine for non-macs
+          POSIX_SPAWN_CLOEXEC_DEFAULT |
+#endif
           POSIX_SPAWN_SETSIGDEF |
           POSIX_SPAWN_SETSIGMASK;
   if (options->flags & UV_PROCESS_DETACHED) {
@@ -518,6 +561,12 @@
   if (err != 0)
     goto error;
 
+#if defined(__APPLE__) && (MAC_OS_X_VERSION_MIN_REQUIRED >= 1070)
+  //set all FDS to close on exec for 10.7 and lower
+  //manually, as the flag causes a panic on 10.7 (maybe not 10.6)
+  if(!(flags & POSIX_SPAWN_CLOEXEC_DEFAULT))
+      SetAllFDsToCloseOnExec();
+#endif
   /* Reset all signal the child to their default behavior */
   sigfillset(&signal_set);
   err = posix_spawnattr_setsigdefault(attrs, &signal_set);
@@ -618,9 +667,11 @@
       }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     if (fd == use_fd)
         err = posix_spawn_file_actions_addinherit_np(actions, fd);
     else
+#endif
         err = posix_spawn_file_actions_adddup2(actions, use_fd, fd);
     assert(err != ENOSYS);
     if (err != 0)
@@ -869,7 +920,7 @@
   int exec_errorno;
   ssize_t r;
 
-#if defined(__APPLE__)
+#if defined(__APPLE__) && (MAC_OS_X_VERSION_MIN_REQUIRED >= 1050)
   uv_once(&posix_spawn_init_once, uv__spawn_init_posix_spawn);
 
   /* Special child process spawn case for macOS Big Sur (11.0) onwards

--- ./src/unix/tty.c	2025-04-25 03:50:27.000000000 -0600
+++ ./src/unix/tty.c	2025-07-07 22:28:08.000000000 -0600
@@ -85,7 +85,7 @@
   int dummy;
 
   result = ioctl(fd, TIOCGPTN, &dummy) != 0;
-#elif defined(__APPLE__)
+#elif defined(__APPLE__) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1050
   char dummy[256];
 
   result = ioctl(fd, TIOCPTYGNAME, &dummy) != 0;
--- ./src/unix/udp.c	2025-04-25 03:50:27.000000000 -0600
+++ ./src/unix/udp.c	2025-07-07 22:28:08.000000000 -0600
@@ -152,7 +152,9 @@
 }
 
 static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
+#if defined(__linux__) || defined(__FreeBSD__) || \
+    (defined(__APPLE__) && (defined(MAC_OS_VERSION_10_15) || \
+        MAC_OS_X_VERSION_MIN_ALLOWED > MAC_OS_VERSION_10_15))
   struct sockaddr_in6 peers[20];
   struct iovec iov[ARRAY_SIZE(peers)];
   struct mmsghdr msgs[ARRAY_SIZE(peers)];
@@ -180,7 +182,8 @@
     msgs[k].msg_len = 0;
   }
 
-#if defined(__APPLE__)
+#if (defined(__APPLE__) && (defined(MAC_OS_VERSION_10_15) || \
+            MAC_OS_X_VERSION_MIN_ALLOWED > MAC_OS_VERSION_10_15) )
   do
     nread = recvmsg_x(handle->io_watcher.fd, msgs, chunks, MSG_DONTWAIT);
   while (nread == -1 && errno == EINTR);
@@ -767,6 +770,7 @@
     !defined(__ANDROID__) &&                                        \
     !defined(__DragonFly__) &&                                      \
     !defined(__QNX__) &&                                            \
+    (!defined(__APPLE__) || (MAC_OS_X_VERSION_MAX_ALLOWED >= 1070)) && \
     !defined(__GNU__)
 static int uv__udp_set_source_membership4(uv_udp_t* handle,
                                           const struct sockaddr_in* multicast_addr,
@@ -890,7 +894,9 @@
 
 
 int uv_udp_using_recvmmsg(const uv_udp_t* handle) {
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
+#if defined(__linux__) || defined(__FreeBSD__) || \
+    (defined(__APPLE__) && (defined(MAC_OS_VERSION_10_15) \
+     || MAC_OS_X_VERSION_MIN_ALLOWED > MAC_OS_VERSION_10_15))
   if (handle->flags & UV_HANDLE_UDP_RECVMMSG)
     return 1;
 #endif
@@ -958,6 +964,7 @@
     !defined(__ANDROID__) &&                                        \
     !defined(__DragonFly__) &&                                      \
     !defined(__QNX__) &&                                            \
+    (!defined(__APPLE__) || (MAC_OS_X_VERSION_MAX_ALLOWED >= 1070)) && \
     !defined(__GNU__)
   int err;
   union uv__sockaddr mcast_addr;
@@ -1311,7 +1318,9 @@
   r = 0;
   nsent = 0;
 
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) || \
+#if defined(__linux__) || defined(__FreeBSD__) || \
+  (defined(__APPLE__) && (defined(MAC_OS_VERSION_10_15) || \
+    MAC_OS_X_VERSION_MIN_ALLOWED > MAC_OS_VERSION_10_15)) || \
   (defined(__sun__) && defined(MSG_WAITFORONE))
   if (count > 1) {
     for (i = 0; i < count; /*empty*/) {
