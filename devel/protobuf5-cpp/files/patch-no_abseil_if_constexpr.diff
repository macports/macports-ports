Backports the following protobuf patches from main to v5.29.5:

0ea5ccd61c69 Use `if constexpr` instead of
             `absl::utility_internal::IfConstexprElseIfConstexprElse`
d801cbd86818 Remove `absl::if_constexpr` from list of used Abseil targets

This is necessary for compatibility with abseil-cpp beyond:

14cfd97abe88 Delete absl/utility/internal/if_constexpr.h

This revision is present in abseil-cpp 20250512.rc1 and later.

From 4fb25aec644c9fb6f933e272127e4ad8de27b260 Mon Sep 17 00:00:00 2001
From: Derek Mauro <dmauro@google.com>
Date: Wed, 19 Feb 2025 11:03:21 -0800
Subject: [PATCH 1/2] Use `if constexpr` instead of
 `absl::utility_internal::IfConstexprElseIfConstexprElse`

PiperOrigin-RevId: 728737911
---
 src/google/protobuf/arena.h | 61 +++++++++++++++----------------------
 1 file changed, 25 insertions(+), 36 deletions(-)

diff --git src/google/protobuf/arena.h src/google/protobuf/arena.h
index 545fd5126a47..cfdb3e79a12a 100644
--- src/google/protobuf/arena.h
+++ src/google/protobuf/arena.h
@@ -32,7 +32,6 @@ using type_info = ::type_info;
 #include "absl/base/optimization.h"
 #include "absl/base/prefetch.h"
 #include "absl/log/absl_check.h"
-#include "absl/utility/internal/if_constexpr.h"
 #include "google/protobuf/arena_align.h"
 #include "google/protobuf/arena_allocation_policy.h"
 #include "google/protobuf/port.h"
@@ -214,41 +213,31 @@ class PROTOBUF_EXPORT PROTOBUF_ALIGNAS(8) Arena final {
   // otherwise, returns a heap-allocated object.
   template <typename T, typename... Args>
   PROTOBUF_NDEBUG_INLINE static T* Create(Arena* arena, Args&&... args) {
-    return absl::utility_internal::IfConstexprElse<
-        is_arena_constructable<T>::value>(
-        // Arena-constructable
-        [arena](auto&&... args) {
-          using Type = std::remove_const_t<T>;
-#ifdef __cpp_if_constexpr
-          // DefaultConstruct/CopyConstruct are optimized for messages, which
-          // are both arena constructible and destructor skippable and they
-          // assume much. Don't use these functions unless the invariants
-          // hold.
-          if constexpr (is_destructor_skippable<T>::value) {
-            constexpr auto construct_type = GetConstructType<T, Args&&...>();
-            // We delegate to DefaultConstruct/CopyConstruct where appropriate
-            // because protobuf generated classes have external templates for
-            // these functions for code size reasons. When `if constexpr` is not
-            // available always use the fallback.
-            if constexpr (construct_type == ConstructType::kDefault) {
-              return static_cast<Type*>(DefaultConstruct<Type>(arena));
-            } else if constexpr (construct_type == ConstructType::kCopy) {
-              return static_cast<Type*>(CopyConstruct<Type>(arena, &args...));
-            }
-          }
-#endif
-          return CreateArenaCompatible<Type>(arena,
-                                             std::forward<Args>(args)...);
-        },
-        // Non arena-constructable
-        [arena](auto&&... args) {
-          if (PROTOBUF_PREDICT_FALSE(arena == nullptr)) {
-            return new T(std::forward<Args>(args)...);
-          }
-          return new (arena->AllocateInternal<T>())
-              T(std::forward<Args>(args)...);
-        },
-        std::forward<Args>(args)...);
+    if constexpr (is_arena_constructable<T>::value) {
+      using Type = std::remove_const_t<T>;
+      // DefaultConstruct/CopyConstruct are optimized for messages, which
+      // are both arena constructible and destructor skippable and they
+      // assume much. Don't use these functions unless the invariants
+      // hold.
+      if constexpr (is_destructor_skippable<T>::value) {
+        constexpr auto construct_type = GetConstructType<T, Args&&...>();
+        // We delegate to DefaultConstruct/CopyConstruct where appropriate
+        // because protobuf generated classes have external templates for
+        // these functions for code size reasons. When `if constexpr` is not
+        // available always use the fallback.
+        if constexpr (construct_type == ConstructType::kDefault) {
+          return static_cast<Type*>(DefaultConstruct<Type>(arena));
+        } else if constexpr (construct_type == ConstructType::kCopy) {
+          return static_cast<Type*>(CopyConstruct<Type>(arena, &args...));
+        }
+      }
+      return CreateArenaCompatible<Type>(arena, std::forward<Args>(args)...);
+    } else {
+      if (PROTOBUF_PREDICT_FALSE(arena == nullptr)) {
+        return new T(std::forward<Args>(args)...);
+      }
+      return new (arena->AllocateInternal<T>()) T(std::forward<Args>(args)...);
+    }
   }
 
   // API to delete any objects not on an arena.  This can be used to safely
-- 
2.51.1

From 2174569b96209c967b2a7f6c40360f7a0bf2b77b Mon Sep 17 00:00:00 2001
From: Christian Blichmann <cblichmann@google.com>
Date: Thu, 20 Feb 2025 09:11:09 -0800
Subject: [PATCH 2/2] Remove `absl::if_constexpr` from list of used Abseil
 targets

This is a follow-up on 0ea5ccd61c69ff5000631781c6c9a3a50241392c, moving to C++'s
`if constexpr`.

PiperOrigin-RevId: 729136260
---
 cmake/abseil-cpp.cmake | 1 -
 1 file changed, 1 deletion(-)

diff --git cmake/abseil-cpp.cmake cmake/abseil-cpp.cmake
index 1b64affa50ca..9b99802340dd 100644
--- cmake/abseil-cpp.cmake
+++ cmake/abseil-cpp.cmake
@@ -72,7 +72,6 @@ else()
     absl::flat_hash_set
     absl::function_ref
     absl::hash
-    absl::if_constexpr
     absl::layout
     absl::log_initialize
     absl::log_globals
-- 
2.51.1

