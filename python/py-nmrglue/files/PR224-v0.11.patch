diff --git a/nmrglue/fileio/nmrml.py b/nmrglue/fileio/nmrml.py
index 4af0c94..8596d5b 100644
--- a/nmrglue/fileio/nmrml.py
+++ b/nmrglue/fileio/nmrml.py
@@ -71,6 +71,6 @@ def _get_nmrml_data(fid_dict, data_dtype):
     # convert to ndarray
     if data_dtype is None:
         data_dtype = BYTE_FORMAT_TO_DTYPE[byte_format]
-    data = np.fromstring(uncompressed_bytes, dtype=data_dtype)
+    data = np.frombuffer(uncompressed_bytes, dtype=data_dtype)
 
     return data
diff --git a/nmrglue/fileio/pipe.py b/nmrglue/fileio/pipe.py
index f4f8ef6..9964c2f 100644
--- a/nmrglue/fileio/pipe.py
+++ b/nmrglue/fileio/pipe.py
@@ -81,7 +81,7 @@ def read_table(filename):
     # print(dtd['names'],dtd['formats'])
     s = [l.encode('utf-8') for l in dl]
 
-    rec = np.recfromtxt(s, dtype=dtd, comments='XXXXXXXXXXX')
+    rec = np.genfromtxt(s, dtype=dtd, comments='XXXXXXXXXXX')
     return cl, pformat, np.atleast_1d(rec)
 
 
@@ -192,6 +192,7 @@ def make_uc(dic, data, dim=-1):
 # dictionary/data creation #
 ############################
 
+
 fd2dphase_dic = {"magnitude": 0, "tppi": 1, "states": 2, "image": 3}
 
 
@@ -318,7 +319,7 @@ def create_dic(udic, datetimeobj=datetime.datetime.now()):
 
     if ((dic["FDF1QUADFLAG"] == dic["FDF2QUADFLAG"] == dic["FDF3QUADFLAG"]) and
             (dic["FDF1QUADFLAG"] == dic["FDF4QUADFLAG"] == 1)):
-                dic["FDQUADFLAG"] = 1.0
+        dic["FDQUADFLAG"] = 1.0
 
     return dic
 
@@ -1111,7 +1112,7 @@ def write_slice_3D(filemask, dic, data, shape, slices):
             # file doesn't exist, create a empty one
             ndata = np.zeros((dy, dx), dtype=data.dtype)
             write_single(f, dic, data, False)
-            del(ndata)
+            del ndata
 
         # mmap the [new] file
         mdata = np.memmap(f, dtype='float32', offset=512 * 4, mode='r+')
@@ -1132,11 +1133,11 @@ def write_slice_3D(filemask, dic, data, shape, slices):
         if data.dtype == 'complex64':
             idata[sy, sx] = data.imag[i]
             idata.flush()
-            del(idata)
+            del idata
 
         # clean up
-        del(rdata)
-        del(mdata)
+        del rdata
+        del mdata
 
 # iter3D tools (xyz2pipe and pipe2xyz replacements)
 # Notes for iter3D implementation
@@ -1260,6 +1261,7 @@ class iter3D:
             ziter.write("ft/test%03d.ft3",XZplane,dic)
 
     """
+
     def __init__(self, filemask, in_lead="x", out_lead="DEFAULT"):
         """
         Create a iter3D object
@@ -1806,9 +1808,9 @@ class pipe_3d(fileiobase.data_nd):
         f3 = "FDF" + str(int(dic["FDDIMORDER3"]))
         quadrature_factor = [2, 1][int(dic[f3 + 'QUADFLAG'])]
 
-        #Checking whether "nmrPipe -fn EXT ..." has been applied to z-dim or not.
-        #If EXT has been applied, FDF*XN is not zero.
-        #If z-dim is in time-domain, data-size given by FDF*X1 and FDF*XN has to be doubled.
+        # Checking whether "nmrPipe -fn EXT ..." has been applied to z-dim or not.
+        # If EXT has been applied, FDF*XN is not zero.
+        # If z-dim is in time-domain, data-size given by FDF*X1 and FDF*XN has to be doubled.
         if dic[f3 + 'FTFLAG']:
 
             if int(dic[f3 + 'XN']) == 0:
@@ -1900,6 +1902,7 @@ class pipestream_3d(fileiobase.data_nd):
         Ordering of axes against file.
 
     """
+
     def __init__(self, filename, order=(0, 1, 2)):
         """
         Create and set up object
@@ -1995,6 +1998,7 @@ class pipe_4d(fileiobase.data_nd):
         set exist.  Raises a IOError if files are missing. Default is False.
 
     """
+
     def __init__(self, filemask, order=(0, 1, 2, 3), fcheck=False):
         """
         Create and set up object, check that files exist if fcheck is True
@@ -2195,6 +2199,7 @@ class pipestream_4d(fileiobase.data_nd):
         f.close()
         return out
 
+
 # data, see fdata.h
 fdata_nums = {
     'FDMAGIC': '0',
diff --git a/nmrglue/fileio/table.py b/nmrglue/fileio/table.py
index 16cb9ec..16c1726 100644
--- a/nmrglue/fileio/table.py
+++ b/nmrglue/fileio/table.py
@@ -144,7 +144,7 @@ def read(filename):
     dtd['formats'] = comments.pop(dl[0])[9:].split()
 
     # return the data as a records array
-    return comments, np.atleast_1d(np.recfromtxt(filename, dtype=dtd))
+    return comments, np.atleast_1d(np.genfromtxt(filename, dtype=dtd))
 
 
 def write(filename, comments, rec, overwrite=False):
diff --git a/nmrglue/fileio/tecmag.py b/nmrglue/fileio/tecmag.py
index a5931e3..d2d9b56 100644
--- a/nmrglue/fileio/tecmag.py
+++ b/nmrglue/fileio/tecmag.py
@@ -24,8 +24,8 @@ from . import fileiobase
 
 TNTMAGIC_RE = re.compile(br"^TNT1\.\d\d\d$")
 
-TNTMAGIC = np.dtype('a8')
-TNTTLV = np.dtype([('tag', 'a4'), ('bool', '<u4'), ('length', '<u4')])
+TNTMAGIC = np.dtype('S8')
+TNTTLV = np.dtype([('tag', 'S4'), ('bool', '<u4'), ('length', '<u4')])
 
 TNTTMAG = np.dtype([
     ('npts', '<i4', 4),
@@ -47,7 +47,7 @@ TNTTMAG = np.dtype([
     ('ref_freq', '<f8'),
     ('NMR_frequency', '<f8'),
     ('obs_channel', '<i2'),
-    ('space2', 'a42'),
+    ('space2', 'S42'),
 
     ('sw', '<f8', 4),
     ('dwell', '<f8', 4),
@@ -61,14 +61,14 @@ TNTTMAG = np.dtype([
     ('Type', '<i2'),
     ('bDigRec', '<u4'),
     ('nDigitalCenter', '<i4'),
-    ('space3', 'a16'),
+    ('space3', 'S16'),
 
     ('transmitter_gain', '<i2'),
     ('receiver_gain', '<i2'),
     ('NumberOfReceivers', '<i2'),
     ('RG2', '<i2'),
     ('receiver_phase', '<f8'),
-    ('space4', 'a4'),
+    ('space4', 'S4'),
 
     ('set_spin_rate', '<u2'),
     ('actual_spin_rate', '<u2'),
@@ -80,7 +80,7 @@ TNTTMAG = np.dtype([
     ('lock_freq_mhz', '<f8'),
     ('lock_ppm', '<f8'),
     ('H2O_freq_ref', '<f8'),
-    ('space5', 'a16'),
+    ('space5', 'S16'),
 
     ('set_temperature', '<f8'),
     ('actual_temperature', '<f8'),
@@ -93,21 +93,21 @@ TNTTMAG = np.dtype([
     ('DF_DN', '<i2'),
     ('F1_tran_mode', '<i2', 7),
     ('dec_BW', '<i2'),
-    ('grd_orientation', 'a4'),
+    ('grd_orientation', 'S4'),
     ('LatchLP', '<i4'),
     ('grd_Theta', '<f8'),
     ('grd_Phi', '<f8'),
-    ('space6', 'a264'),
+    ('space6', 'S264'),
 
     ('start_time', '<u4'),
     ('finish_time', '<u4'),
     ('elapsed_time', '<i4'),
 
-    ('date', 'a32'),
-    ('nuclei', 'a16', 4),
-    ('sequence', 'a32'),
-    ('lock_solvent', 'a16'),
-    ('lock_nucleus', 'a16')
+    ('date', 'S32'),
+    ('nuclei', 'S16', 4),
+    ('sequence', 'S32'),
+    ('lock_solvent', 'S16'),
+    ('lock_nucleus', 'S16')
 ])
 
 
@@ -122,8 +122,8 @@ TNTGRIDANDAXIS = np.dtype([
     ('showGridLabels', '<u4'),
     ('adjustOnZoom', '<u4'),
     ('showDistanceUnits', '<u4'),
-    ('axisName', 'a32'),
-    ('space', 'a52'),
+    ('axisName', 'S32'),
+    ('space', 'S52'),
 ])
 
 
@@ -217,18 +217,18 @@ TNTTMG2 = np.dtype([
     ('Poly_point_avr', '<i2'),
     ('Poly_order', '<i2'),
 
-    ('space', 'a610'),
-
-    ('line_simulation_name', 'a32'),
-    ('integral_template_name', 'a32'),
-    ('baseline_template_name', 'a32'),
-    ('layout_name', 'a32'),
-    ('relax_information_name', 'a32'),
-    ('username', 'a32'),
-    ('user_string_1', 'a16'),
-    ('user_string_2', 'a16'),
-    ('user_string_3', 'a16'),
-    ('user_string_4', 'a16')
+    ('space', 'S610'),
+
+    ('line_simulation_name', 'S32'),
+    ('integral_template_name', 'S32'),
+    ('baseline_template_name', 'S32'),
+    ('layout_name', 'S32'),
+    ('relax_information_name', 'S32'),
+    ('username', 'S32'),
+    ('user_string_1', 'S16'),
+    ('user_string_2', 'S16'),
+    ('user_string_3', 'S16'),
+    ('user_string_4', 'S16')
 ])
 
 
@@ -253,7 +253,7 @@ def read(filename):
 
     with open(filename, 'rb') as tntfile:
 
-        tntmagic = np.fromstring(tntfile.read(TNTMAGIC.itemsize),
+        tntmagic = np.frombuffer(tntfile.read(TNTMAGIC.itemsize),
                                  TNTMAGIC, count=1)[0]
 
         if not TNTMAGIC_RE.match(tntmagic):
@@ -263,25 +263,25 @@ def read(filename):
 
         # Read in the section headers
         tnthdrbytes = tntfile.read(TNTTLV.itemsize)
-        while(TNTTLV.itemsize == len(tnthdrbytes)):
-            tlv = np.fromstring(tnthdrbytes, TNTTLV)[0]
+        while TNTTLV.itemsize == len(tnthdrbytes):
+            tlv = np.frombuffer(tnthdrbytes, TNTTLV)[0]
             data_length = tlv['length']
             hdrdict = {'offset': tntfile.tell(),
                        'length': data_length,
                        'bool': bool(tlv['bool'])}
             if data_length <= 4096:
                 hdrdict['data'] = tntfile.read(data_length)
-                assert(len(hdrdict['data']) == data_length)
+                assert len(hdrdict['data']) == data_length
             else:
                 tntfile.seek(data_length, os.SEEK_CUR)
             tnt_sections[tlv['tag'].decode()] = hdrdict
             tnthdrbytes = tntfile.read(TNTTLV.itemsize)
 
-    assert(tnt_sections['TMAG']['length'] == TNTTMAG.itemsize)
+    assert tnt_sections['TMAG']['length'] == TNTTMAG.itemsize
     tmag = np.fromstring(tnt_sections['TMAG']['data'], TNTTMAG, count=1)[0]
 
-    assert(tnt_sections['DATA']['length'] ==
-           tmag['actual_npts'].prod() * 8)
+    assert (tnt_sections['DATA']['length'] ==
+            tmag['actual_npts'].prod() * 8)
     #  For some reason we can't set offset and shape together
     # DATA = np.memmap(tntfilename,np.dtype('<c8'), mode='r',
     #                  offset=self.tnt_sections['DATA']['offset'],
@@ -291,7 +291,7 @@ def read(filename):
                      shape=tmag['actual_npts'].prod())
     data = np.reshape(data, tmag['actual_npts'], order='F')
 
-    assert(tnt_sections['TMG2']['length'] == TNTTMG2.itemsize)
+    assert tnt_sections['TMG2']['length'] == TNTTMG2.itemsize
     tmg2 = np.fromstring(tnt_sections['TMG2']['data'], TNTTMG2, count=1)[0]
 
     dic = dict()
diff --git a/nmrglue/process/proc_lp.py b/nmrglue/process/proc_lp.py
index 4a8ef94..05012ea 100644
--- a/nmrglue/process/proc_lp.py
+++ b/nmrglue/process/proc_lp.py
@@ -528,8 +528,9 @@ def cadzow_single(x, M, K, min_var=False):
     U, s, Vh = scipy.linalg.svd(X)
 
     # correct the singular values and truncate the rank K
-    Ul = np.mat(U[:, :K])
-    Vlh = np.mat(Vh[:K, :])     # first K columns of V are first K rows of Vh
+    Ul = np.asmatrix(U[:, :K])
+    # first K columns of V are first K rows of Vh
+    Vlh = np.asmatrix(Vh[:K, :])
     sl = s[:K]
 
     if min_var:  # adjust singular values using minimum variance method
@@ -537,7 +538,7 @@ def cadzow_single(x, M, K, min_var=False):
         s2 = (1. / (M - K)) * np.power(s[K:], 2).sum()
         sl = np.array([l - s2 / l for l in sl])
 
-    Sl = np.mat(np.diag(sl))
+    Sl = np.asmatrix(np.diag(sl))
 
     # compute enhanced data vector for rank-reduced data matrix
     Xp = Ul * Sl * Vlh
@@ -656,7 +657,7 @@ def lp_model(trace, slice=slice(None), order=8, mode="f", mirror=None,
 
     # build the B matrix (a Vandermonde matrix) and solve for the coefficients
     poles = np.array(poles)
-    B = np.row_stack([poles ** (i) for i in range(len(x))])
+    B = np.vstack([poles ** (i) for i in range(len(x))])
     z, resid, rank, s = np.linalg.lstsq(B, np.array(x))
 
     # Now the z_n = amp_n*exp(phase_n*i), use this to determine the amplitudes
@@ -803,10 +804,11 @@ def find_lpc_svd(D, d):
     L = D.shape[0]
     m = D.shape[1]
     U, s, Vh = scipy.linalg.svd(D)  # SVD decomposition
-    U, Vh = np.mat(U), np.mat(Vh)   # make U and Vh matrices
+    U, Vh = np.asmatrix(U), np.asmatrix(Vh)   # make U and Vh matrices
     Si = pinv_diagsvd(s, m, L)      # construct the pseudo-inverse sigma matrix
     return np.array(Vh.H * Si * U.H * d)
 
+
 # the next 3 lines and the pinv_diagsvd function were adapted from the
 # scipy.linalg.pinv2 function - jjh
 eps = np.finfo('float').eps
@@ -833,7 +835,7 @@ def find_lpc_qr(D, d):
     Find linear prediction filter using QR decomposition.
     """
     q, r = scipy.linalg.qr(D)
-    q, r = np.mat(q), np.mat(r)
+    q, r = np.asmatrix(q), np.asmatrix(r)
 
     # SPEED
     # the next line is slow and the use of pinv2 should be avoided as
@@ -852,9 +854,9 @@ def find_lpc_cholesky(D, d):
     # form the normal equation (D.H*D)*a = D.H*d
     # SPEED
     # this can be improved by using the Hankel nature of D
-    D = np.mat(D)
-    DhD = np.mat(np.dot(D.H, D))
-    Dhd = np.mat(np.dot(D.H, d))
+    D = np.asmatrix(D)
+    DhD = np.asmatrix(np.dot(D.H, D))
+    Dhd = np.asmatrix(np.dot(D.H, d))
 
     c, lower = scipy.linalg.cho_factor(DhD)     # Compute Cholesky decomp.
     return scipy.linalg.cho_solve((c, lower), Dhd)  # solve normal equation
@@ -1018,7 +1020,7 @@ def find_lproots_hsvd(x, M, K, mode, zmethod='sm'):
 
     # SVD of data matrix and truncation of U to form Uk
     U, s, Vh = scipy.linalg.svd(X)
-    Uk = np.mat(U[:, :K])   # truncated U matrix of rank K
+    Uk = np.asmatrix(U[:, :K])   # truncated U matrix of rank K
     Ub = Uk[:-1]            # Uk with bottom row removed
     Ut = Uk[1:]             # Uk with top row removed
 
