--- src/3rdparty/chromium/base/numerics/safe_conversions_impl.h.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/base/numerics/safe_conversions_impl.h	2023-07-09 15:58:18.000000000 +0200
@@ -10,6 +10,8 @@
 #include <limits>
 #include <type_traits>
 
+#include "../template_util.h"
+
 #if defined(__GNUC__) || defined(__clang__)
 #define BASE_NUMERICS_LIKELY(x) __builtin_expect(!!(x), 1)
 #define BASE_NUMERICS_UNLIKELY(x) __builtin_expect(!!(x), 0)
@@ -87,7 +89,7 @@
 
 // TODO(jschuh): Switch to std::is_constant_evaluated() once C++20 is supported.
 // Alternately, the usage could be restructured for "consteval if" in C++23.
-#define IsConstantEvaluated() (__builtin_is_constant_evaluated())
+#define IsConstantEvaluated() (is_constant_evaluated())
 
 // TODO(jschuh): Debug builds don't reliably propagate constants, so we restrict
 // some accelerated runtime paths to release builds until this can be forced
--- src/3rdparty/chromium/third_party/snappy/src/snappy.cc.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/third_party/snappy/src/snappy.cc	2023-07-09 17:21:28.000000000 +0200
@@ -1041,7 +1041,7 @@
   size_t literal_len = *tag >> 2;
   size_t tag_type = *tag;
   bool is_literal;
-#if defined(__GNUC__) && defined(__x86_64__)
+#if defined(__GCC_ASM_FLAG_OUTPUTS__) && defined(__x86_64__)
   // TODO clang misses the fact that the (c & 3) already correctly
   // sets the zero flag.
   asm("and $3, %k[tag_type]\n\t"
--- src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/DeviceMTL.h.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/DeviceMTL.h	2023-07-09 21:49:33.000000000 +0200
@@ -142,8 +142,8 @@
         float mTimestampPeriod = 1.0f;
         // The base of CPU timestamp and GPU timestamp to measure the linear regression between GPU
         // and CPU timestamps.
-        MTLTimestamp mCpuTimestamp API_AVAILABLE(macos(10.15), ios(14.0)) = 0;
-        MTLTimestamp mGpuTimestamp API_AVAILABLE(macos(10.15), ios(14.0)) = 0;
+        uint64_t mCpuTimestamp API_AVAILABLE(macos(10.15), ios(14.0)) = 0;
+        uint64_t mGpuTimestamp API_AVAILABLE(macos(10.15), ios(14.0)) = 0;
         // The parameters for kalman filter
         std::unique_ptr<KalmanInfo> mKalmanInfo;
     };
--- src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/BackendMTL.mm.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/BackendMTL.mm	2023-07-09 21:55:42.000000000 +0200
@@ -176,6 +176,7 @@
 #endif
 
         DAWN_NOINLINE bool IsCounterSamplingBoundarySupport(id<MTLDevice> device)
+#if !TARGET_OS_OSX || MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
             API_AVAILABLE(macos(11.0), ios(14.0)) {
             bool isBlitBoundarySupported =
                 [device supportsCounterSampling:MTLCounterSamplingPointAtBlitBoundary];
@@ -187,6 +188,11 @@
             return isBlitBoundarySupported && isDispatchBoundarySupported &&
                    isDrawBoundarySupported;
         }
+#else
+        {
+            return false;
+        }
+#endif
 
         // This method has seen hard-to-debug crashes. See crbug.com/dawn/1102.
         // For now, it is written defensively, with many potentially unnecessary guards until
@@ -344,6 +350,7 @@
                 }
             }
 
+#if !TARGET_OS_OSX || MAC_OS_X_VERSION_MAX_ALLOWED >= 101500
             if (@available(macOS 10.15, iOS 14.0, *)) {
                 if (IsGPUCounterSupported(
                         *mDevice, MTLCommonCounterSetStatistic,
@@ -371,6 +378,7 @@
                     }
                 }
             }
+#endif
 
             if (@available(macOS 10.11, iOS 11.0, *)) {
                 mSupportedFeatures.EnableFeature(Feature::DepthClamping);
@@ -412,16 +420,16 @@
             // https://developer.apple.com/documentation/metal/mtldevice/detecting_gpu_features_and_metal_software_versions?language=objc
 
             if (@available(macOS 10.15, iOS 10.13, *)) {
-                if ([*mDevice supportsFamily:MTLGPUFamilyMac2]) {
+                if ([*mDevice supportsFamily:(::MTLGPUFamily(2002))]) { // MTLGPUFamilyMac2
                     return MTLGPUFamily::Mac2;
                 }
-                if ([*mDevice supportsFamily:MTLGPUFamilyMac1]) {
+                if ([*mDevice supportsFamily:(::MTLGPUFamily(2001))]) { // MTLGPUFamilyMac1
                     return MTLGPUFamily::Mac1;
                 }
-                if ([*mDevice supportsFamily:MTLGPUFamilyApple7]) {
+                if ([*mDevice supportsFamily:(::MTLGPUFamily(1007))]) { // MTLGPUFamilyApple7
                     return MTLGPUFamily::Apple7;
                 }
-                if ([*mDevice supportsFamily:MTLGPUFamilyApple6]) {
+                if ([*mDevice supportsFamily:(::MTLGPUFamily(1006))]) { // MTLGPUFamilyApple6
                     return MTLGPUFamily::Apple6;
                 }
                 if ([*mDevice supportsFamily:MTLGPUFamilyApple5]) {
--- src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/DeviceMTL.mm.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/DeviceMTL.mm	2023-07-09 21:57:05.000000000 +0200
@@ -70,8 +70,8 @@
         void API_AVAILABLE(macos(10.15), ios(14))
             UpdateTimestampPeriod(id<MTLDevice> device,
                                   KalmanInfo* info,
-                                  MTLTimestamp* cpuTimestampStart,
-                                  MTLTimestamp* gpuTimestampStart,
+                                  uint64_t* cpuTimestampStart,
+                                  uint64_t* gpuTimestampStart,
                                   float* timestampPeriod) {
             // The filter value is converged to an optimal value when the kalman gain is less than
             // 0.01. At this time, the weight of the measured value is too small to change the next
@@ -80,8 +80,13 @@
                 return;
             }
 
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
             MTLTimestamp cpuTimestampEnd = 0, gpuTimestampEnd = 0;
             [device sampleTimestamps:&cpuTimestampEnd gpuTimestamp:&gpuTimestampEnd];
+#else
+            uint64_t cpuTimestampEnd = 0, gpuTimestampEnd = 0;
+            [device sampleTimestamps:(NSUInteger *)&cpuTimestampEnd gpuTimestamp:(NSUInteger *)&gpuTimestampEnd];
+#endif
 
             // Update the timestamp start values when timestamp reset happens
             if (cpuTimestampEnd < *cpuTimestampStart || gpuTimestampEnd < *gpuTimestampStart) {
@@ -151,7 +156,11 @@
 
             if (@available(macos 10.15, iOS 14.0, *)) {
                 // Sample CPU timestamp and GPU timestamp for first time at device creation
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
                 [*mMtlDevice sampleTimestamps:&mCpuTimestamp gpuTimestamp:&mGpuTimestamp];
+#else
+                [*mMtlDevice sampleTimestamps:(NSUInteger *)&mCpuTimestamp gpuTimestamp:(NSUInteger *)&mGpuTimestamp];
+#endif
             }
         }
 
--- src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/ShaderModuleMTL.mm.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/ShaderModuleMTL.mm	2023-07-09 23:10:05.000000000 +0200
@@ -220,9 +220,11 @@
 
         NSRef<MTLCompileOptions> compileOptions = AcquireNSRef([[MTLCompileOptions alloc] init]);
         if (hasInvariantAttribute) {
+#if !TARGET_OS_OSX || MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
             if (@available(macOS 11.0, iOS 13.0, *)) {
                 (*compileOptions).preserveInvariance = true;
             }
+#endif
         }
         auto mtlDevice = ToBackend(GetDevice())->GetMTLDevice();
         NSError* error = nullptr;
--- src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/TextureMTL.mm.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/third_party/dawn/src/dawn/native/metal/TextureMTL.mm	2023-07-09 23:28:55.000000000 +0200
@@ -376,230 +376,230 @@
 
             case wgpu::TextureFormat::ETC2RGB8Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatETC2_RGB8;
+                    return MTLPixelFormat(180); // MTLPixelFormatETC2_RGB8
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ETC2RGB8UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatETC2_RGB8_sRGB;
+                    return MTLPixelFormat(181); // MTLPixelFormatETC2_RGB8_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ETC2RGB8A1Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatETC2_RGB8A1;
+                    return MTLPixelFormat(182); // MTLPixelFormatETC2_RGB8A1
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ETC2RGB8A1UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatETC2_RGB8A1_sRGB;
+                    return MTLPixelFormat(183); // MTLPixelFormatETC2_RGB8A1_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ETC2RGBA8Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatEAC_RGBA8;
+                    return MTLPixelFormat(178); // MTLPixelFormatEAC_RGBA8
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ETC2RGBA8UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatEAC_RGBA8_sRGB;
+                    return MTLPixelFormat(179); // MTLPixelFormatEAC_RGBA8_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::EACR11Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatEAC_R11Unorm;
+                    return MTLPixelFormat(170); // MTLPixelFormatEAC_R11Unorm
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::EACR11Snorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatEAC_R11Snorm;
+                    return MTLPixelFormat(172); // MTLPixelFormatEAC_R11Snorm
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::EACRG11Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatEAC_RG11Unorm;
+                    return MTLPixelFormat(174); // MTLPixelFormatEAC_RG11Unorm
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::EACRG11Snorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatEAC_RG11Snorm;
+                    return MTLPixelFormat(176); // MTLPixelFormatEAC_RG11Snorm
                 } else {
                     UNREACHABLE();
                 }
 
             case wgpu::TextureFormat::ASTC4x4Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_4x4_LDR;
+                    return MTLPixelFormat(204); // MTLPixelFormatASTC_4x4_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC4x4UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_4x4_sRGB;
+                    return MTLPixelFormat(186); // MTLPixelFormatASTC_4x4_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC5x4Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_5x4_LDR;
+                    return MTLPixelFormat(205); // MTLPixelFormatASTC_5x4_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC5x4UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_5x4_sRGB;
+                    return MTLPixelFormat(187); // MTLPixelFormatASTC_5x4_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC5x5Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_5x5_LDR;
+                    return MTLPixelFormat(206); // MTLPixelFormatASTC_5x5_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC5x5UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_5x5_sRGB;
+                    return MTLPixelFormat(188); // MTLPixelFormatASTC_5x5_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC6x5Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_6x5_LDR;
+                    return MTLPixelFormat(207); // MTLPixelFormatASTC_6x5_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC6x5UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_6x5_sRGB;
+                    return MTLPixelFormat(189); // MTLPixelFormatASTC_6x5_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC6x6Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_6x6_LDR;
+                    return MTLPixelFormat(208); // MTLPixelFormatASTC_6x6_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC6x6UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_6x6_sRGB;
+                    return MTLPixelFormat(190); // MTLPixelFormatASTC_6x6_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC8x5Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_8x5_LDR;
+                    return MTLPixelFormat(210); // MTLPixelFormatASTC_8x5_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC8x5UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_8x5_sRGB;
+                    return MTLPixelFormat(192); // MTLPixelFormatASTC_8x5_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC8x6Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_8x6_LDR;
+                    return MTLPixelFormat(211); // MTLPixelFormatASTC_8x6_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC8x6UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_8x6_sRGB;
+                    return MTLPixelFormat(193); // MTLPixelFormatASTC_8x6_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC8x8Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_8x8_LDR;
+                    return MTLPixelFormat(212); // MTLPixelFormatASTC_8x8_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC8x8UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_8x8_sRGB;
+                    return MTLPixelFormat(194); // MTLPixelFormatASTC_8x8_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC10x5Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_10x5_LDR;
+                    return MTLPixelFormat(213); // MTLPixelFormatASTC_10x5_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC10x5UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_10x5_sRGB;
+                    return MTLPixelFormat(195); // MTLPixelFormatASTC_10x5_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC10x6Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_10x6_LDR;
+                    return MTLPixelFormat(214); // MTLPixelFormatASTC_10x6_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC10x6UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_10x6_sRGB;
+                    return MTLPixelFormat(196); // MTLPixelFormatASTC_10x6_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC10x8Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_10x8_LDR;
+                    return MTLPixelFormat(215); // MTLPixelFormatASTC_10x8_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC10x8UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_10x8_sRGB;
+                    return MTLPixelFormat(197); // MTLPixelFormatASTC_10x8_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC10x10Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_10x10_LDR;
+                    return MTLPixelFormat(216); // MTLPixelFormatASTC_10x10_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC10x10UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_10x10_sRGB;
+                    return MTLPixelFormat(198); // MTLPixelFormatASTC_10x10_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC12x10Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_12x10_LDR;
+                    return MTLPixelFormat(217); // MTLPixelFormatASTC_12x10_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC12x10UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_12x10_sRGB;
+                    return MTLPixelFormat(199); // MTLPixelFormatASTC_12x10_sRGB
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC12x12Unorm:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_12x12_LDR;
+                    return MTLPixelFormat(218); // MTLPixelFormatASTC_12x12_LDR
                 } else {
                     UNREACHABLE();
                 }
             case wgpu::TextureFormat::ASTC12x12UnormSrgb:
                 if (@available(macOS 11.0, iOS 8.0, *)) {
-                    return MTLPixelFormatASTC_12x12_sRGB;
+                    return MTLPixelFormat(200); // MTLPixelFormatASTC_12x12_sRGB
                 } else {
                     UNREACHABLE();
                 }
--- src/3rdparty/chromium/ui/gfx/mac/io_surface.cc.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/ui/gfx/mac/io_surface.cc	2023-07-10 00:09:18.000000000 +0200
@@ -174,20 +174,28 @@
                                   ColorSpace::TransferID::PQ,
                                   ColorSpace::MatrixID::BT2020_NCL,
                                   ColorSpace::RangeID::LIMITED)) {
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
       if (__builtin_available(macos 11.0, *)) {
         color_space_name = kCGColorSpaceITUR_2100_PQ;
       } else {
+#endif
         return true;
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
       }
+#endif
     } else if (color_space == ColorSpace(ColorSpace::PrimaryID::BT2020,
                                          ColorSpace::TransferID::HLG,
                                          ColorSpace::MatrixID::BT2020_NCL,
                                          ColorSpace::RangeID::LIMITED)) {
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
       if (__builtin_available(macos 11.0, *)) {
         color_space_name = kCGColorSpaceITUR_2100_HLG;
       } else {
+#endif
         return true;
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
       }
+#endif
     }
   }
   if (color_space_name) {
--- src/3rdparty/chromium/net/socket/udp_socket_posix.cc.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/net/socket/udp_socket_posix.cc	2023-07-10 00:30:50.000000000 +0200
@@ -585,6 +585,7 @@
   if (!base::mac::IsAtLeastOS11()) {
     return ERR_NOT_IMPLEMENTED;
   }
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
   int val = 1;
   if (addr_family_ == AF_INET6) {
     int rv =
@@ -594,7 +595,7 @@
   }
   int rv = setsockopt(socket_, IPPROTO_IP, IP_DONTFRAG, &val, sizeof(val));
   return rv == 0 ? OK : MapSystemError(errno);
-
+#endif
 #else
   if (addr_family_ == AF_INET6) {
     int val = IPV6_PMTUDISC_DO;
--- src/3rdparty/chromium/media/gpu/mac/vt_video_decode_accelerator_mac.cc.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/media/gpu/mac/vt_video_decode_accelerator_mac.cc	2023-07-10 02:22:53.000000000 +0200
@@ -256,7 +256,7 @@
     absl::optional<gfx::HDRMetadata> hdr_metadata,
     const gfx::Size& coded_size) {
   base::ScopedCFTypeRef<CFMutableDictionaryRef> format_config(
-      CreateFormatExtensions(kCMVideoCodecType_VP9, profile, color_space,
+      CreateFormatExtensions(CMVideoCodecType('vp09'), profile, color_space,
                              hdr_metadata));
 
   base::ScopedCFTypeRef<CMFormatDescriptionRef> format;
@@ -266,7 +266,7 @@
   }
 
   OSStatus status = CMVideoFormatDescriptionCreate(
-      kCFAllocatorDefault, kCMVideoCodecType_VP9, coded_size.width(),
+      kCFAllocatorDefault, CMVideoCodecType('vp09'), coded_size.width(),
       coded_size.height(), format_config, format.InitializeInto());
   OSSTATUS_DLOG_IF(WARNING, status != noErr, status)
       << "CMVideoFormatDescriptionCreate()";
@@ -379,8 +379,9 @@
 
   session.reset();
 
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
   if (__builtin_available(macOS 11.0, *)) {
-    VTRegisterSupplementalVideoDecoderIfAvailable(kCMVideoCodecType_VP9);
+    VTRegisterSupplementalVideoDecoderIfAvailable(CMVideoCodecType('vp09'));
 
     // Create a VP9 decoding session.
     if (!CreateVideoToolboxSession(
@@ -393,6 +394,7 @@
       // We don't return false here since VP9 support is optional.
     }
   }
+#endif
 
 #if BUILDFLAG(ENABLE_PLATFORM_HEVC_DECODING)
   if (base::FeatureList::IsEnabled(media::kVideoToolboxHEVCDecoding)) {
@@ -2327,7 +2329,7 @@
       if (__builtin_available(macOS 10.13, *)) {
         if ((supported_profile == VP9PROFILE_PROFILE0 ||
              supported_profile == VP9PROFILE_PROFILE2) &&
-            !VTIsHardwareDecodeSupported(kCMVideoCodecType_VP9)) {
+            !VTIsHardwareDecodeSupported(CMVideoCodecType('vp09'))) {
           continue;
         }
 
--- src/3rdparty/chromium/media/gpu/mac/vt_video_encode_accelerator_mac.cc.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/media/gpu/mac/vt_video_encode_accelerator_mac.cc	2023-07-10 02:34:24.000000000 +0200
@@ -150,8 +150,10 @@
   profile.max_framerate_numerator = kMaxFrameRateNumerator;
   profile.max_framerate_denominator = kMaxFrameRateDenominator;
   profile.max_resolution = gfx::Size(kMaxResolutionWidth, kMaxResolutionHeight);
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110300
   if (__builtin_available(macOS LOW_LATENCY_FLAG_AVAILABLE_VER, *))
     profile.scalability_modes.push_back(SVCScalabilityMode::kL1T2);
+#endif
   for (const auto& supported_profile : kSupportedProfiles) {
     profile.profile = supported_profile;
     profiles.push_back(profile);
@@ -595,6 +597,7 @@
       kVTVideoEncoderSpecification_RequireHardwareAcceleratedVideoEncoder};
   std::vector<CFTypeRef> encoder_values{kCFBooleanTrue};
 
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110300
   if (__builtin_available(macOS LOW_LATENCY_FLAG_AVAILABLE_VER, *)) {
     if (require_low_delay_) {
       encoder_keys.push_back(
@@ -602,6 +605,7 @@
       encoder_values.push_back(kCFBooleanTrue);
     }
   }
+#endif
   base::ScopedCFTypeRef<CFDictionaryRef> encoder_spec =
       video_toolbox::DictionaryWithKeysAndValues(
           encoder_keys.data(), encoder_values.data(), encoder_keys.size());
@@ -669,6 +673,7 @@
   }
 
   if (num_temporal_layers_ == 2) {
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110300
     if (__builtin_available(macOS LOW_LATENCY_FLAG_AVAILABLE_VER, *)) {
       if (!session_property_setter.IsSupported(
               kVTCompressionPropertyKey_BaseLayerFrameRateFraction)) {
@@ -679,9 +684,12 @@
           kVTCompressionPropertyKey_BaseLayerFrameRateFraction, 0.5);
       DLOG_IF(ERROR, !rv) << " Setting BaseLayerFrameRate property failed.";
     } else {
+#endif
       DLOG(ERROR) << "SVC encoding is not supported on this OS version.";
       rv = false;
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110300
     }
+#endif
   }
 
   return rv;
--- src/3rdparty/chromium/ui/base/cocoa/permissions_utils.mm.orig	2023-03-12 04:16:34.000000000 +0100
+++ src/3rdparty/chromium/ui/base/cocoa/permissions_utils.mm	2023-07-10 12:05:26.000000000 +0200
@@ -19,9 +19,12 @@
 // heuristic methods on 10.15.
 
 bool IsScreenCaptureAllowed() {
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
   if (@available(macOS 11.0, *)) {
     return CGPreflightScreenCaptureAccess();
-  } else if (@available(macOS 10.15, *)) {
+  } else
+#endif
+  if (@available(macOS 10.15, *)) {
     // Screen Capture is considered allowed if the name of at least one normal
     // or dock window running on another process is visible.
     // See https://crbug.com/993692.
@@ -58,9 +61,12 @@
 }
 
 bool TryPromptUserForScreenCapture() {
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= 110000
   if (@available(macOS 11.0, *)) {
     return CGRequestScreenCaptureAccess();
-  } else if (@available(macOS 10.15, *)) {
+  } else
+#endif
+  if (@available(macOS 10.15, *)) {
     // On 10.15+, macOS will show the permissions prompt for Screen Recording
     // if we request to create a display stream and our application is not
     // in the applications list in System permissions. Stream creation will
