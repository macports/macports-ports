See https://github.com/chromium/chromium/commit/5b5551edd3961481e617e510276b9f015a35b861,
https://github.com/chromium/chromium/commit/9bfbbffdba73668fdb483e5a850911d2b64c35d7

diff --git a/base/containers/checked_iterators.h b/base/containers/checked_iterators.h
index 0c98b8fab4d003..5c8292bd68a2a4 100644
--- src/3rdparty/chromium/base/containers/checked_iterators.h
+++ src/3rdparty/chromium/base/containers/checked_iterators.h
@@ -31,10 +31,8 @@ class CheckedContiguousIterator {
 
   // Required for certain libc++ algorithm optimizations that are not available
   // for NaCl.
-#if defined(_LIBCPP_VERSION) && !BUILDFLAG(IS_NACL)
   template <typename Ptr>
   friend struct std::pointer_traits;
-#endif
 
   constexpr CheckedContiguousIterator() = default;
 
@@ -224,7 +222,6 @@ using CheckedContiguousConstIterator = CheckedContiguousIterator<const T>;
 
 }  // namespace base
 
-#if defined(_LIBCPP_VERSION) && !BUILDFLAG(IS_NACL)
 // Specialize both std::__is_cpp17_contiguous_iterator and std::pointer_traits
 // for CCI in case we compile with libc++ outside of NaCl. The former is
 // required to enable certain algorithm optimizations (e.g. std::copy can be a
@@ -244,9 +241,11 @@ using CheckedContiguousConstIterator = CheckedContiguousIterator<const T>;
 // [3] https://wg21.link/pointer.traits.optmem
 namespace std {
 
+#if defined(_LIBCPP_VERSION)
 template <typename T>
 struct __is_cpp17_contiguous_iterator<::base::CheckedContiguousIterator<T>>
     : true_type {};
+#endif
 
 template <typename T>
 struct pointer_traits<::base::CheckedContiguousIterator<T>> {
@@ -267,6 +266,5 @@ struct pointer_traits<::base::CheckedContiguousIterator<T>> {
 };
 
 }  // namespace std
-#endif
 
 #endif  // BASE_CONTAINERS_CHECKED_ITERATORS_H_
diff --git a/base/containers/checked_iterators.h b/base/containers/checked_iterators.h
index 5c8292bd68a2a4..b67a2db4bfa3be 100644
--- src/3rdparty/chromium/base/containers/checked_iterators.h
+++ src/3rdparty/chromium/base/containers/checked_iterators.h
@@ -24,6 +24,9 @@ class CheckedContiguousIterator {
   using pointer = T*;
   using reference = T&;
   using iterator_category = std::random_access_iterator_tag;
+#if __cplusplus >= 202002L
+  using iterator_concept = std::contiguous_iterator_tag;
+#endif
 
   // Required for converting constructor below.
   template <typename U>
@@ -239,14 +242,34 @@ using CheckedContiguousConstIterator = CheckedContiguousIterator<const T>;
 // [1] https://wg21.link/iterator.concept.contiguous
 // [2] https://wg21.link/std.iterator.tags
 // [3] https://wg21.link/pointer.traits.optmem
-namespace std {
 
 #if defined(_LIBCPP_VERSION)
+
+// TODO(crbug.com/1284275): Remove when C++20 is on by default, as the use
+// of `iterator_concept` above should suffice.
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+// TODO(crbug.com/1449299): https://reviews.llvm.org/D150801 renamed this from
+// `__is_cpp17_contiguous_iterator` to `__libcpp_is_contiguous_iterator`. Clean
+// up the old spelling after libc++ rolls.
+template <typename T>
+struct __is_cpp17_contiguous_iterator;
 template <typename T>
 struct __is_cpp17_contiguous_iterator<::base::CheckedContiguousIterator<T>>
     : true_type {};
+
+template <typename T>
+struct __libcpp_is_contiguous_iterator;
+template <typename T>
+struct __libcpp_is_contiguous_iterator<::base::CheckedContiguousIterator<T>>
+    : true_type {};
+
+_LIBCPP_END_NAMESPACE_STD
+
 #endif
 
+namespace std {
+
 template <typename T>
 struct pointer_traits<::base::CheckedContiguousIterator<T>> {
   using pointer = ::base::CheckedContiguousIterator<T>;
diff --git a/base/containers/checked_iterators_unittest.cc b/base/containers/checked_iterators_unittest.cc
index 4d7cffa1630314..07e628a10bafbd 100644
--- src/3rdparty/chromium/base/containers/checked_iterators_unittest.cc
+++ src/3rdparty/chromium/base/containers/checked_iterators_unittest.cc
@@ -85,11 +85,8 @@ TEST(CheckedContiguousIterator, ConvertingComparisonOperators) {
 
 }  // namespace base
 
-// ChromeOS does not use the in-tree libc++, but rather a shared library that
-// lags a bit behind.
-// TODO(crbug.com/1166360): Enable this test on ChromeOS once the shared libc++
-// is sufficiently modern.
-#if defined(_LIBCPP_VERSION) && !BUILDFLAG(IS_NACL) && !BUILDFLAG(IS_CHROMEOS)
+#if defined(_LIBCPP_VERSION)
+
 namespace {
 
 // Helper template that wraps an iterator and disables its dereference and
@@ -101,6 +98,8 @@ namespace {
 template <typename Iterator>
 struct DisableDerefAndIncr : Iterator {
   using Iterator::Iterator;
+
+  // NOLINTNEXTLINE(google-explicit-constructor)
   constexpr DisableDerefAndIncr(const Iterator& iter) : Iterator(iter) {}
 
   constexpr typename Iterator::reference operator*() {
@@ -121,16 +120,28 @@ struct DisableDerefAndIncr : Iterator {
 
 }  // namespace
 
-// Inherit `__is_cpp17_contiguous_iterator` and `pointer_traits` specializations
-// from the base class.
-namespace std {
+// Inherit `__libcpp_is_contiguous_iterator` and `pointer_traits`
+// specializations from the base class.
+
+// TODO(crbug.com/1284275): Remove when C++20 is on by default, as the use
+// of `iterator_concept` should suffice.
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+// TODO(crbug.com/1449299): https://reviews.llvm.org/D150801 renamed this from
+// `__is_cpp17_contiguous_iterator` to `__libcpp_is_contiguous_iterator`. Clean
+// up the old spelling after libc++ rolls.
 template <typename Iter>
 struct __is_cpp17_contiguous_iterator<DisableDerefAndIncr<Iter>>
     : __is_cpp17_contiguous_iterator<Iter> {};
 
+template <typename Iter>
+struct __libcpp_is_contiguous_iterator<DisableDerefAndIncr<Iter>>
+    : __libcpp_is_contiguous_iterator<Iter> {};
+
 template <typename Iter>
 struct pointer_traits<DisableDerefAndIncr<Iter>> : pointer_traits<Iter> {};
-}  // namespace std
+
+_LIBCPP_END_NAMESPACE_STD
 
 namespace base {
 
