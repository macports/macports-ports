https://github.com/scipopt/papilo/commit/53ec504638aaa72a6b6de71175e9db27e4d7b60b

diff --git CHANGELOG CHANGELOG
index c29d3041..145ef310 100644
--- CHANGELOG
+++ CHANGELOG
@@ -74,6 +74,7 @@ Fixed bugs
 - postsolving FixInfinityCol works also in primal case
 - store data for FixInfinityCol correct if bounds are both infinity
 - PaPILO shows some behavior on different OS
+- avoid abort because of calling extended_euclidean with negative coefficients
 
 
 Miscellaneous
diff --git src/papilo/presolvers/SimpleSubstitution.hpp src/papilo/presolvers/SimpleSubstitution.hpp
index faf6a399..fbb2e8cd 100644
--- src/papilo/presolvers/SimpleSubstitution.hpp
+++ src/papilo/presolvers/SimpleSubstitution.hpp
@@ -243,15 +243,10 @@ SimpleSubstitution<REAL>::perform_simple_subsitution_step(
          auto res = boost::integer::extended_euclidean(
             static_cast<int64_t>( abs( vals[stay] ) ),
             static_cast<int64_t>( abs( vals[subst] ) ) );
-         if( vals[stay] < 0 )
-            res.x *= -1;
-         if( vals[subst] < 0 )
-            res.y *= -1;
          if( !num.isIntegral( rhs / res.gcd ) )
             return PresolveStatus::kInfeasible;
          // TODO: ensure isConstraintsFeasibleWithGivenBounds() works for negative sign
-         else if( vals[stay] > 0 && vals[subst] > 0 &&
-            !isConstraintsFeasibleWithGivenBounds(
+         else if( !isConstraintsFeasibleWithGivenBounds(
                num, lower_bounds, upper_bounds, vals, rhs, subst, stay, res ) )
             return PresolveStatus::kInfeasible;
          else
@@ -321,6 +316,16 @@ SimpleSubstitution<REAL>::perform_simple_subsitution_step(
    reductions.aggregateFreeCol( inds[subst], i );
    return result;
 }
+
+/**
+ * check if the aggregated variable y of the equation a2x1 + a2x2 = b is within its bounds.
+ * 1. generate a solution for s a1 + t a2 = gcd(a1,a2)
+ * 2. substitute variable x1 = -a2 y + s and x2 = a1 y + t
+ * 3. check bounds of y
+ *
+ * see chapter 10.1.1 Constraint Integer Programming of Tobias Achterberg
+ *
+ */
 template <typename REAL>
 bool
 SimpleSubstitution<REAL>::isConstraintsFeasibleWithGivenBounds(
@@ -328,18 +333,24 @@ SimpleSubstitution<REAL>::isConstraintsFeasibleWithGivenBounds(
     const Vec<REAL>& upper_bounds, const REAL* vals, REAL rhs, int subst,
     int stay, const boost::integer::euclidean_result_t<int64_t>& res ) const
 {
-   REAL initial_solution_for_x = res.x * rhs;
-   REAL initial_solution_for_y = res.y * rhs;
+   int res_x = vals[stay] < 0 ? res.x * -1 : res.x;
+   int res_y = vals[subst] < 0 ? res.y * -1 : res.y;
+
+   REAL initial_solution_for_x = res_x * rhs;
+   REAL initial_solution_for_y = res_y * rhs;
    REAL factor = (int)(initial_solution_for_y * res.gcd / vals[stay]);
-   REAL solution_for_x =
-       initial_solution_for_x + factor / res.gcd * vals[subst];
-   REAL solution_for_y =
-       initial_solution_for_y - factor / res.gcd * vals[stay];
-
-   REAL ub_sol_y = ( solution_for_y - lower_bounds[stay] ) / vals[stay];
-   REAL lb_sol_y = ( solution_for_y - upper_bounds[stay] ) / vals[stay];
-   REAL ub_sol_x = ( upper_bounds[subst] - solution_for_x ) / vals[subst];
-   REAL lb_sol_x = ( lower_bounds[subst] - solution_for_x ) / vals[subst];
+
+   REAL s = initial_solution_for_x + factor / res.gcd * vals[subst];
+   REAL t = initial_solution_for_y - factor / res.gcd * vals[stay];
+
+   REAL ub_sol_y = ( t - lower_bounds[subst] ) / vals[stay];
+   REAL lb_sol_y = ( t - upper_bounds[subst] ) / vals[stay];
+   if( vals[stay] < 0 )
+      std::swap( ub_sol_y, lb_sol_y );
+   REAL ub_sol_x = ( upper_bounds[stay] - s ) / vals[subst];
+   REAL lb_sol_x = ( lower_bounds[stay] - s ) / vals[subst];
+   if( vals[subst] < 0 )
+      std::swap( ub_sol_x, lb_sol_x );
 
    return num.isFeasLE( num.epsCeil( lb_sol_y ), num.epsFloor( ub_sol_y ) ) &&
           num.isFeasLE( num.epsCeil( lb_sol_x ), num.epsFloor( ub_sol_x ) );
diff --git test/CMakeLists.txt test/CMakeLists.txt
index 9ed9064b..0211f195 100644
--- test/CMakeLists.txt
+++ test/CMakeLists.txt
@@ -176,13 +176,16 @@ set(unit_tests
         "happy-path-simple-probing-only-binary-positive-coefficient"
 
         #Simple Substitution
-        "happy-path-simple-substitution-for-2-int"
-        "happy-path-simple-substitution-for-2-continuous"
-        "happy-path-simple-substitution-for-continuous-and-integer"
-        "happy-path-simple-substitution-for-int-continuous-coeff"
-        "should_return_infeasible_if_gcd_of_coeff_is_in_rhs"
-        "should_return_feasible_if_gcd_of_coeff_is_in_rhs"
-        "failed-path-simple-substitution-for-2-int"
+        "simple-substitution-happy-path-for-2-int"
+        "simple-substitution-happy-path-for-2-continuous"
+        "simple-substitution-happy-path-for-continuous-and-integer"
+        "simple-substitution-happy-path-for-int-continuous-coeff"
+        "simple-substitution-should_return_infeasible_if_gcd_of_coeff_is_in_rhs"
+        "simple-substitution-should_return_feasible_if_gcd_of_coeff_is_in_rhs"
+        "simple-substitution-failed-path-for-2-int"
+        "simple-substitution-2-negative-integer"
+        "simple-substitution-feasible-gcd"
+        "simple-substitution-violated-gcd"
 
         #Simplify Inequality
         "happy-path-simplify-inequalities-only-greatest-divisor"
diff --git test/papilo/presolve/SimpleSubstitutionTest.cpp test/papilo/presolve/SimpleSubstitutionTest.cpp
index 81d37816..d4651f83 100644
--- test/papilo/presolve/SimpleSubstitutionTest.cpp
+++ test/papilo/presolve/SimpleSubstitutionTest.cpp
@@ -34,7 +34,9 @@ setupProblemWithSimpleSubstitution( uint8_t is_x_integer, uint8_t is_y_integer,
                                     double a_y );
 
 Problem<double>
-setupProblemWithInfeasibleBounds( double x, double y, double rhs );
+setupProblemWithInfeasibleBounds( double x, double y, double rhs, double coef1,
+                                  double coef2, double lb1, double ub1,
+                                  double lb2, double ub2 );
 
 Problem<double>
 setupProblemWithSimpleSubstitutionInfeasibleGcd();
@@ -42,7 +44,11 @@ setupProblemWithSimpleSubstitutionInfeasibleGcd();
 Problem<double>
 setupProblemWithSimpleSubstitutionFeasibleGcd();
 
-TEST_CASE( "happy-path-simple-substitution-for-2-int", "[presolve]" )
+PresolveStatus
+check_gcd_result_with_expectation(double x, double y, double rhs, double coef1,
+                                   double coef2, double lb1, double ub1, double lb2, double ub2 );
+
+TEST_CASE( "simple-substitution-happy-path-for-2-int", "[presolve]" )
 {
    Num<double> num{};
    double time = 0.0;
@@ -91,7 +97,7 @@ TEST_CASE( "happy-path-simple-substitution-for-2-int", "[presolve]" )
    REQUIRE( reductions.getReduction( 4 ).newval == 0 );
 }
 
-TEST_CASE( "happy-path-simple-substitution-for-int-continuous-coeff",
+TEST_CASE( "simple-substitution-happy-path-for-int-continuous-coeff",
            "[presolve]" )
 {
    Message msg {};
@@ -115,7 +121,7 @@ TEST_CASE( "happy-path-simple-substitution-for-int-continuous-coeff",
    REQUIRE( presolveStatus == PresolveStatus::kUnchanged );
 }
 
-TEST_CASE( "happy-path-simple-substitution-for-2-continuous", "[presolve]" )
+TEST_CASE( "simple-substitution-happy-path-for-2-continuous", "[presolve]" )
 {
    Num<double> num{};
    double time = 0.0;
@@ -154,7 +160,7 @@ TEST_CASE( "happy-path-simple-substitution-for-2-continuous", "[presolve]" )
    REQUIRE( reductions.getReduction( 2 ).newval == 0 );
 }
 
-TEST_CASE( "happy-path-simple-substitution-for-continuous-and-integer",
+TEST_CASE( "simple-substitution-happy-path-for-continuous-and-integer",
            "[presolve]" )
 {
    Num<double> num{};
@@ -194,7 +200,7 @@ TEST_CASE( "happy-path-simple-substitution-for-continuous-and-integer",
    REQUIRE( reductions.getReduction( 2 ).newval == 0 );
 }
 
-TEST_CASE( "failed-path-simple-substitution-for-2-int", "[presolve]" )
+TEST_CASE( "simple-substitution-simple-substitution-for-2-int", "[presolve]" )
 {
    Num<double> num{};
    double time = 0.0;
@@ -218,13 +224,58 @@ TEST_CASE( "failed-path-simple-substitution-for-2-int", "[presolve]" )
    REQUIRE( presolveStatus == PresolveStatus::kUnchanged );
 }
 
+TEST_CASE( "simple-substitution-2-negative-integer", "[presolve]" )
+{
+   // 2x - 2y = 4 with x,y in [0,3]
+   REQUIRE( check_gcd_result_with_expectation(
+                1.0, 1.0, 4.0, 2.0, 2.0, 0.0, 3.0, 0.0, 3.0 ) == PresolveStatus::kReduced );
+}
+
+TEST_CASE( "simple-substitution-feasible-gcd", "[presolve]" )
+{
+   // 3x + 8y = 37 with x in {0,7} y in {0,5} -> solution x = 7, y = 2
+   REQUIRE( check_gcd_result_with_expectation(
+                8.0, 3.0, 37.0, 3.0, 8.0, 0.0, 7.0, 0.0, 5.0 ) == PresolveStatus::kUnchanged );
+   // -3x -8y = 37 with x in {-7,0} y in {-5,0} -> solution x = -7, y = -2
+   REQUIRE( check_gcd_result_with_expectation(
+                8.0, 3.0, 37.0, -3.0, -8.0, -7.0, 0.0, -5.0, 0.0 ) == PresolveStatus::kUnchanged );
+   // -3x -8y = -37 with x in {0,7} y in {0,5} -> solution x = 7, y = 2
+   REQUIRE( check_gcd_result_with_expectation(
+                8.0, 3.0, -37.0, -3.0, -8.0, 0.0, 7.0, 0.0, 5.0 ) == PresolveStatus::kUnchanged );
+   // -3x + 8y = 37 with x in {-7,0} y in {0,5} -> solution x = -7, y = 2
+   REQUIRE( check_gcd_result_with_expectation(
+                8.0, 3.0, 37.0, -3.0, 8.0, -7.0, 0.0, 0.0, 5.0 ) == PresolveStatus::kUnchanged );
+   // 3x - 8y = 37 with x in {0,7} y in {-5,0} -> solution x = 7, y = -2
+   REQUIRE( check_gcd_result_with_expectation(
+                8.0, 3.0, 37.0, 3.0, -8.0, 0.0, 7.0, -5.0, 0.0 ) == PresolveStatus::kUnchanged );
+}
+
+TEST_CASE( "simple-substitution-violated-gcd", "[presolve]" )
+{
+   // -3x - 8y = 37 with x,y in {-5,0}
+   REQUIRE( check_gcd_result_with_expectation(
+                8.0, 3.0, 37.0, -3.0, 8.0, -5.0, 0.0, -5.0, 0.0 ) == PresolveStatus::kInfeasible );
+   // -3x - 8y = -37 with x,y in {0,5}
+   REQUIRE( check_gcd_result_with_expectation(
+                8.0, 3.0, -37.0, -3.0, -8.0, 0.0, 5.0, 0.0, 5.0 ) == PresolveStatus::kInfeasible );
+}
+
+
 TEST_CASE( "example_10_1_in_constraint_integer_programming", "[presolve]" )
+{
+   // 3x + 8y = 37 with x,y in {0,5}
+   REQUIRE( check_gcd_result_with_expectation(
+                8.0, 3.0, 37.0, 3.0, 8.0, 0.0, 5.0, 0.0, 5.0 ) == PresolveStatus::kInfeasible );
+}
+
+
+TEST_CASE( "should_return_feasible_if_gcd_of_coeff_is_in_rhs", "[presolve]" )
 {
    Message msg {};
    double time = 0.0;
    Timer t{ time };
    Num<double> num{};
-   Problem<double> problem = setupProblemWithInfeasibleBounds( 8.0, 3.0, 37.0 );
+   Problem<double> problem = setupProblemWithSimpleSubstitutionFeasibleGcd();
    Statistics statistics{};
    PresolveOptions presolveOptions{};
    presolveOptions.dualreds = 0;
@@ -238,17 +289,17 @@ TEST_CASE( "example_10_1_in_constraint_integer_programming", "[presolve]" )
 
    PresolveStatus presolveStatus =
        presolvingMethod.execute( problem, problemUpdate, num, reductions, t );
-   REQUIRE( presolveStatus == PresolveStatus::kInfeasible );
-}
 
+   REQUIRE( presolveStatus == PresolveStatus::kUnchanged );
+}
 
-TEST_CASE( "should_return_feasible_if_gcd_of_coeff_is_in_rhs", "[presolve]" )
+TEST_CASE( "should_return_infeasible_if_gcd_of_coeff_is_in_rhs", "[presolve]" )
 {
    Message msg {};
    double time = 0.0;
    Timer t{ time };
    Num<double> num{};
-   Problem<double> problem = setupProblemWithSimpleSubstitutionFeasibleGcd();
+   Problem<double> problem = setupProblemWithSimpleSubstitutionInfeasibleGcd();
    Statistics statistics{};
    PresolveOptions presolveOptions{};
    presolveOptions.dualreds = 0;
@@ -263,16 +314,20 @@ TEST_CASE( "should_return_feasible_if_gcd_of_coeff_is_in_rhs", "[presolve]" )
    PresolveStatus presolveStatus =
        presolvingMethod.execute( problem, problemUpdate, num, reductions, t );
 
-   REQUIRE( presolveStatus == PresolveStatus::kUnchanged );
+   REQUIRE( presolveStatus == PresolveStatus::kInfeasible );
 }
 
-TEST_CASE( "should_return_infeasible_if_gcd_of_coeff_is_in_rhs", "[presolve]" )
+PresolveStatus
+check_gcd_result_with_expectation( double x, double y, double rhs, double coef1,
+                                  double coef2, double lb1, double ub1,
+                                  double lb2, double ub2 )
 {
    Message msg {};
    double time = 0.0;
    Timer t{ time };
    Num<double> num{};
-   Problem<double> problem = setupProblemWithSimpleSubstitutionInfeasibleGcd();
+   Problem<double> problem = setupProblemWithInfeasibleBounds(
+       x, y, rhs, coef1, coef2, lb1, ub1, lb2, ub2 );
    Statistics statistics{};
    PresolveOptions presolveOptions{};
    presolveOptions.dualreds = 0;
@@ -284,30 +339,27 @@ TEST_CASE( "should_return_infeasible_if_gcd_of_coeff_is_in_rhs", "[presolve]" )
    Reductions<double> reductions{};
    problem.recomputeAllActivities();
 
-   PresolveStatus presolveStatus =
+   return
        presolvingMethod.execute( problem, problemUpdate, num, reductions, t );
-
-   REQUIRE( presolveStatus == PresolveStatus::kInfeasible );
 }
 
 Problem<double>
-setupProblemWithSimpleSubstitution( uint8_t is_x_integer, uint8_t is_y_integer,
-                                    double a_y )
+setupProblemWithInfeasibleBounds( double x, double y, double rhs, double coef1,
+                                  double coef2, double lb1, double ub1,
+                                  double lb2, double ub2 )
 {
-   // 2x + y = 4
-   // 0<= x,y y= 3
    Num<double> num{};
-   Vec<double> coefficients{ 3.0, 1.0 };
-   Vec<double> upperBounds{ 3.0, 3.0 };
-   Vec<double> lowerBounds{ 0.0, 0.0 };
-   Vec<uint8_t> isIntegral{ is_x_integer, is_y_integer };
+   Vec<double> coefficients{ x, y };
+   Vec<double> upperBounds{ ub1, ub2 };
+   Vec<double> lowerBounds{ lb1, lb2 };
+   Vec<uint8_t> isIntegral{ 1, 1 };
 
-   Vec<double> rhs{ 4.0 };
+   Vec<double> rhs_values{ rhs };
    Vec<std::string> rowNames{ "A1" };
    Vec<std::string> columnNames{ "c1", "c2" };
    Vec<std::tuple<int, int, double>> entries{
-       std::tuple<int, int, double>{ 0, 0, 2.0 },
-       std::tuple<int, int, double>{ 0, 1, a_y },
+       std::tuple<int, int, double>{ 0, 0, coef1 },
+       std::tuple<int, int, double>{ 0, 1, coef2 },
    };
 
    ProblemBuilder<double> pb;
@@ -319,49 +371,50 @@ setupProblemWithSimpleSubstitution( uint8_t is_x_integer, uint8_t is_y_integer,
    pb.setObjAll( coefficients );
    pb.setObjOffset( 0.0 );
    pb.setColIntegralAll( isIntegral );
-   pb.setRowRhsAll( rhs );
+   pb.setRowRhsAll( rhs_values );
    pb.addEntryAll( entries );
    pb.setColNameAll( columnNames );
-   pb.setProblemName( "matrix for testing simple probing" );
+   pb.setProblemName( "example 10.1 in Constraint Integer Programming" );
    Problem<double> problem = pb.build();
-   problem.getConstraintMatrix().modifyLeftHandSide( 0,num, rhs[0] );
+   problem.getConstraintMatrix().modifyLeftHandSide( 0,num, rhs );
    return problem;
 }
 
 Problem<double>
-setupProblemWithInfeasibleBounds( double x, double y, double rhs )
+setupProblemWithSimpleSubstitution( uint8_t is_x_integer, uint8_t is_y_integer,
+                                    double a_y )
 {
-   // 3x + 8y = 37
-   // 0<= x,y y= 5
+   // 2x + y = 4
+   // 0<= x,y y= 3
    Num<double> num{};
-   Vec<double> coefficients{ x, y };
-   Vec<double> upperBounds{ 5.0, 5.0 };
+   Vec<double> coefficients{ 3.0, 1.0 };
+   Vec<double> upperBounds{ 3.0, 3.0 };
    Vec<double> lowerBounds{ 0.0, 0.0 };
-   Vec<uint8_t> isIntegral{ 1, 1 };
+   Vec<uint8_t> isIntegral{ is_x_integer, is_y_integer };
 
-   Vec<double> rhs_values{ rhs };
+   Vec<double> rhs{ 4.0 };
    Vec<std::string> rowNames{ "A1" };
    Vec<std::string> columnNames{ "c1", "c2" };
    Vec<std::tuple<int, int, double>> entries{
-       std::tuple<int, int, double>{ 0, 0, 3.0 },
-       std::tuple<int, int, double>{ 0, 1, 8.0 },
+       std::tuple<int, int, double>{ 0, 0, 2.0 },
+       std::tuple<int, int, double>{ 0, 1, a_y },
    };
 
    ProblemBuilder<double> pb;
-   pb.reserve( entries.size(), rowNames.size(), columnNames.size() );
-   pb.setNumRows( rowNames.size() );
-   pb.setNumCols( columnNames.size() );
+   pb.reserve( (int) entries.size(), (int) rowNames.size(), (int) columnNames.size() );
+   pb.setNumRows( (int) rowNames.size() );
+   pb.setNumCols( (int) columnNames.size() );
    pb.setColUbAll( upperBounds );
    pb.setColLbAll( lowerBounds );
    pb.setObjAll( coefficients );
    pb.setObjOffset( 0.0 );
    pb.setColIntegralAll( isIntegral );
-   pb.setRowRhsAll( rhs_values );
+   pb.setRowRhsAll( rhs );
    pb.addEntryAll( entries );
    pb.setColNameAll( columnNames );
-   pb.setProblemName( "example 10.1 in Constraint Integer Programming" );
+   pb.setProblemName( "matrix for testing simple probing" );
    Problem<double> problem = pb.build();
-   problem.getConstraintMatrix().modifyLeftHandSide( 0,num, rhs );
+   problem.getConstraintMatrix().modifyLeftHandSide( 0,num, rhs[0] );
    return problem;
 }
 
