Index: dcop/dcopclient.cpp
===================================================================
RCS file: /home/kde/kdelibs/dcop/dcopclient.cpp,v
retrieving revision 1.167
diff -u -r1.167 dcopclient.cpp
--- dcop/dcopclient.cpp	8 Aug 2003 14:11:24 -0000	1.167
+++ dcop/dcopclient.cpp	15 Aug 2003 23:16:48 -0000
@@ -235,6 +235,8 @@
     QCString disp = getenv("DISPLAY");
 #elif defined(Q_WS_QWS)
     QCString disp = getenv("QWS_DISPLAY");
+#else
+    QCString disp;
 #endif
     if (disp.isEmpty())
         disp = "NODISPLAY";
Index: kdecore/kapplication.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kapplication.cpp,v
retrieving revision 1.606
diff -u -r1.606 kapplication.cpp
--- kdecore/kapplication.cpp	7 Aug 2003 17:34:52 -0000	1.606
+++ kdecore/kapplication.cpp	15 Aug 2003 23:16:51 -0000
@@ -96,7 +96,7 @@
 #include <errno.h>
 #include <string.h>
 #include <netdb.h>
-#ifndef Q_WS_QWS //FIXME(E): NetWM should talk to QWS...
+#ifdef Q_WS_X11 //FIXME(E): NetWM should talk to QWS...
 #include <netwm.h>
 #endif
 
@@ -117,6 +117,8 @@
 
 #ifdef Q_WS_X11
 #define DISPLAY "DISPLAY"
+#elif defined(Q_WS_MAC)
+#define DISPLAY "MAC_DISPLAY"
 #elif defined(Q_WS_QWS)
 #define DISPLAY "QWS_DISPLAY"
 #endif
@@ -180,9 +182,12 @@
 	overrideStyle( QString::null ),
 	startup_id( "0" ),
 	m_KAppDCOPInterface( 0L ),
-	session_save( false ),
+	session_save( false )
+#ifndef Q_WS_MAC
+	,
         oldXErrorHandler( NULL ),
         oldXIOErrorHandler( NULL )
+#endif
   {
   }
 
@@ -205,8 +210,10 @@
   QCString startup_id;
   KAppDCOPInterface *m_KAppDCOPInterface;
   bool session_save;
+#ifndef Q_WS_MAC
   int (*oldXErrorHandler)(Display*,XErrorEvent*);
   int (*oldXIOErrorHandler)(Display*);
+#endif
 
   class URLActionRule
   {
@@ -493,11 +500,11 @@
 #endif
 }
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 static SmcConn mySmcConnection = 0;
 static SmcConn tmpSmcConnection = 0;
 #else
-// FIXME(E): Implement for Qt Embedded
+// FIXME(E): Implement for Qt Embedded and Qt/Mac
 // Possibly "steal" XFree86's libSM?
 #endif
 static QTime* smModificationTime = 0;
@@ -588,6 +595,7 @@
 }
 #endif
 
+#ifdef Q_WS_X11
 int KApplication::xioErrhandler( Display* dpy )
 {
     if(kapp)
@@ -598,7 +606,9 @@
     exit( 1 );
     return 0;
 }
+#endif
 
+#ifdef Q_WS_X11
 int KApplication::xErrhandler( Display* dpy, void* err_ )
 { // no idea how to make forward decl. for XErrorEvent
     XErrorEvent* err = static_cast< XErrorEvent* >( err_ );
@@ -609,6 +619,7 @@
     }
     return 0;
 }
+#endif
 
 void KApplication::iceIOErrorHandler( _IceConn *conn )
 {
@@ -907,6 +918,7 @@
   // because disabling session management after konqueror startup
   // disabled it somehow. Forcing saveState() here for this application
   // seems to fix it.
+#ifdef Q_WS_X11
   if( mySmcConnection ) {
         SmcRequestSaveYourself( mySmcConnection, SmSaveLocal, False,
 				SmInteractStyleAny,
@@ -915,6 +927,7 @@
 	// flush the request
 	IceFlush(SmcGetIceConnection(mySmcConnection));
   }
+#endif
 }
 
 
@@ -1061,7 +1074,7 @@
 void KApplication::saveState( QSessionManager& sm )
 {
     d->session_save = true;
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
     static bool firstTime = true;
     mySmcConnection = (SmcConn) sm.handle();
 
@@ -1215,7 +1228,7 @@
   //FIXME: Check if other options are specific to Qt/X11
 #ifdef Q_WS_X11
    { "display <displayname>", I18N_NOOP("Use the X-server display 'displayname'."), 0},
-#else
+#elif defined(Q_WS_QWS)
    { "display <displayname>", I18N_NOOP("Use the QWS display 'displayname'."), 0},
 #endif
    { "session <sessionId>", I18N_NOOP("Restore the application for the given 'sessionId'."), 0},
@@ -1355,7 +1368,7 @@
             XFree( data );
     }
 #else
-    // FIXME(E): Implement for Qt Embedded
+    // FIXME(E): Implement for Qt Embedded and Qt/Mac
 #endif
 
     if (args->isSet("geometry"))
@@ -1423,17 +1436,19 @@
 
   KProcessController::deref();
 
+#ifdef Q_WS_X11
   if ( d->oldXErrorHandler != NULL )
       XSetErrorHandler( d->oldXErrorHandler );
   if ( d->oldXIOErrorHandler != NULL )
       XSetIOErrorHandler( d->oldXIOErrorHandler );
+#endif
   if ( d->oldIceIOErrorHandler != NULL )
       IceSetIOErrorHandler( d->oldIceIOErrorHandler );
 
   delete d;
   KApp = 0;
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
   mySmcConnection = 0;
   delete smModificationTime;
   smModificationTime = 0;
@@ -1444,7 +1459,7 @@
       tmpSmcConnection = 0;
   }
 #else
-  // FIXME(E): Implement for Qt Embedded
+  // FIXME(E): Implement for Qt Embedded and Qt/Mac
 #endif
 }
 
@@ -2355,7 +2370,7 @@
 {
   if( topWidget != 0 )
   {
-#ifdef Q_WS_X11 // FIXME(E): Implement for Qt/Embedded
+#ifdef Q_WS_X11 // FIXME(E): Implement for Qt/Embedded and Qt/Mac
     Window leader = topWidget->winId();
     char* argv = const_cast< char* >( KCmdLineArgs::appName());
     XSetCommand(display, leader, &argv, 1);
@@ -2381,7 +2396,7 @@
     // set the specified caption
     if ( !topWidget->inherits("KMainWindow") ) { // KMainWindow does this already for us
         topWidget->setCaption( caption() );
-#ifndef Q_WS_QWS // FIXME(E): Implement for Qt/Embedded
+#ifdef Q_WS_X11 // FIXME(E): Implement for Qt/Embedded and Qt/Mac
         NETWinInfo info(qt_xdisplay(), topWidget->winId(), qt_xrootwin(), NET::WMName );
         info.setName( caption().utf8().data() );
 #endif
@@ -2389,7 +2404,7 @@
 
     // set the specified icons
     topWidget->setIcon( icon() ); //standard X11
-#ifdef Q_WS_X11 // FIXME(E): Implement for Qt/Embedded
+#ifdef Q_WS_X11 // FIXME(E): Implement for Qt/Embedded and Qt/Mac
     KWin::setIcons(topWidget->winId(), icon(), miniIcon() ); // NET_WM hints for KWin
 
     // set the app startup notification window property
@@ -2586,6 +2601,7 @@
 
 uint KApplication::keyboardModifiers()
 {
+#ifndef Q_WS_MAC
     Window root;
     Window child;
     int root_x, root_y, win_x, win_y;
@@ -2593,10 +2609,12 @@
     XQueryPointer( qt_xdisplay(), qt_xrootwin(), &root, &child,
                    &root_x, &root_y, &win_x, &win_y, &keybstate );
     return keybstate & 0x00ff;
+#endif
 }
 
 uint KApplication::mouseState()
 {
+#ifndef Q_WS_MAC
     Window root;
     Window child;
     int root_x, root_y, win_x, win_y;
@@ -2604,6 +2622,7 @@
     XQueryPointer( qt_xdisplay(), qt_xrootwin(), &root, &child,
                    &root_x, &root_y, &win_x, &win_y, &keybstate );
     return keybstate & 0xff00;
+#endif
 }
 
 void KApplication::installSigpipeHandler()
Index: kdecore/kapplication.h
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kapplication.h,v
retrieving revision 1.291
diff -u -r1.291 kapplication.h
--- kdecore/kapplication.h	10 Aug 2003 03:11:33 -0000	1.291
+++ kdecore/kapplication.h	15 Aug 2003 23:16:53 -0000
@@ -32,7 +32,7 @@
 class DCOPObject;
 
 typedef unsigned long Atom;
-#ifdef Q_WS_QWS
+#if defined(Q_WS_QWS) || defined(Q_WS_X11)
 typedef void Display;
 #endif
 
@@ -114,7 +114,7 @@
    */
   KApplication( bool allowStyles=true, bool GUIenabled=true);
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
   /**
    * Constructor. Parses command-line arguments. Use this constructor to use KApplication
    * in a Motif or Xt program.
@@ -1056,12 +1056,16 @@
   /**
       @internal
     */
+#ifdef Q_WS_X11
   int xErrhandler( Display*, void* );
+#endif
 
   /**
       @internal
     */
+#ifdef Q_WS_X11
   int xioErrhandler( Display* );
+#endif
 
   /**
    * @internal
Index: kdecore/kcmdlineargs.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kcmdlineargs.cpp,v
retrieving revision 1.81
diff -u -r1.81 kcmdlineargs.cpp
--- kdecore/kcmdlineargs.cpp	4 Aug 2003 08:56:40 -0000	1.81
+++ kdecore/kcmdlineargs.cpp	15 Aug 2003 23:16:53 -0000
@@ -46,6 +46,8 @@
 #define DISPLAY "DISPLAY"
 #elif defined(Q_WS_QWS)
 #define DISPLAY "QWS_DISPLAY"
+#elif defined(Q_WS_MAC)
+#define DISPLAY "MAC_DISPLAY"
 #endif
 
 template class QAsciiDict<QCString>;
@@ -172,12 +174,14 @@
       exit(255);
    }
 
+#ifndef Q_WS_MAC
    // Strip path from argv[0]
    if (argc) {
      char *p = strrchr( argv[0], '/');
      if (p)
        argv[0] = p+1;
    }
+#endif
 
    about = _about;
    parsed = false;
Index: kdecore/kglobalaccel.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kglobalaccel.cpp,v
retrieving revision 1.89
diff -u -r1.89 kglobalaccel.cpp
--- kdecore/kglobalaccel.cpp	8 Jan 2003 21:44:15 -0000	1.89
+++ kdecore/kglobalaccel.cpp	15 Aug 2003 23:16:53 -0000
@@ -31,62 +31,156 @@
 	{ d->clearActions(); }
 */
 KAccelActions& KGlobalAccel::actions()
-	{ return d->actions(); }
+{
+#ifdef Q_WS_MAC
+	static KAccelActions ret;
+	return ret;
+#else
+	return d->actions();
+#endif
+}
 
 const KAccelActions& KGlobalAccel::actions() const
-	{ return d->actions(); }
+{
+#ifdef Q_WS_MAC
+	static KAccelActions ret;
+	return ret;
+#else
+	return d->actions();
+#endif
+}
 
 bool KGlobalAccel::isEnabled()
-	{ return ((KAccelBase*)d)->isEnabled(); }
+{
+#ifdef Q_WS_MAC
+	return false;
+#else
+	return ((KAccelBase*)d)->isEnabled();
+#endif
+}
 
 void KGlobalAccel::setEnabled( bool bEnabled )
-	{ d->setEnabled( bEnabled ); }
+{
+#ifndef Q_WS_MAC
+	d->setEnabled( bEnabled );
+#endif
+}
 
 KAccelAction* KGlobalAccel::insert( const QString& sAction, const QString& sDesc, const QString& sHelp,
 		const KShortcut& cutDef3, const KShortcut& cutDef4,
 		const QObject* pObjSlot, const char* psMethodSlot,
 		bool bConfigurable, bool bEnabled )
 {
+#ifdef Q_WS_MAC
+	return NULL;
+#else
 	return d->insert( sAction, sDesc, sHelp,
 		cutDef3, cutDef4,
 		pObjSlot, psMethodSlot,
 		bConfigurable, bEnabled );
+#endif
 }
 
 KAccelAction* KGlobalAccel::insert( const QString& sName, const QString& sDesc )
-	{ return d->insert( sName, sDesc ); }
+{
+#ifdef Q_WS_X11
+	return d->insert( sName, sDesc );
+#else
+	return NULL;
+#endif
+}
 bool KGlobalAccel::updateConnections()
-	{ return d->updateConnections(); }
+{
+#ifdef Q_WS_X11
+	return d->updateConnections();
+#else
+	return false;
+#endif
+}
 
 bool KGlobalAccel::remove( const QString& sAction )
-        { return d->remove( sAction ); }
+{
+#ifdef Q_WS_X11
+	return d->remove( sAction );
+#else
+	return false;
+#endif
+}
 
 const KShortcut& KGlobalAccel::shortcut( const QString& sAction ) const
 {
+#ifdef Q_WS_X11
 	const KAccelAction* pAction = d->actions().actionPtr( sAction );
 	return (pAction) ? pAction->shortcut() : KShortcut::null();
+#else
+	return KShortcut::null();
+#endif
 }
 
 bool KGlobalAccel::setShortcut( const QString& sAction, const KShortcut& cut )
-	{ return d->setShortcut( sAction, cut ); }
+{
+#ifdef Q_WS_X11
+	return d->setShortcut( sAction, cut );
+#else
+	return false;
+#endif
+}
+
 bool KGlobalAccel::setSlot( const QString& sAction, const QObject* pObjSlot, const char* psMethodSlot )
-	{ return d->setActionSlot( sAction, pObjSlot, psMethodSlot ); }
+{
+#ifdef Q_WS_X11
+	return d->setActionSlot( sAction, pObjSlot, psMethodSlot );
+#else
+	return false;
+#endif
+}
 
 const QString& KGlobalAccel::configGroup() const
-	{ return d->configGroup(); }
+{
+#ifdef Q_WS_X11
+	return d->configGroup();
+#else
+	return "";
+#endif
+}
+
 // for kdemultimedia/kmix
 void KGlobalAccel::setConfigGroup( const QString& s )
-	{ d->setConfigGroup( s ); }
+{
+#ifdef Q_WS_X11
+	d->setConfigGroup( s );
+#endif
+}
 
 bool KGlobalAccel::readSettings( KConfigBase* pConfig )
-	{ d->readSettings( pConfig ); return true; }
+{
+#ifdef Q_WS_X11
+	d->readSettings( pConfig );
+	return true;
+#else
+	return false;
+#endif
+}
+
 bool KGlobalAccel::writeSettings( KConfigBase* pConfig ) const
-	{ d->writeSettings( pConfig ); return true; }
+{
+#ifdef Q_WS_X11
+	d->writeSettings( pConfig );
+	return true;
+#else
+	return false;
+#endif
+}
+
 bool KGlobalAccel::writeSettings( KConfigBase* pConfig, bool bGlobal ) const
 {
+#ifdef Q_WS_X11
 	d->setConfigGlobal( bGlobal );
 	d->writeSettings( pConfig );
 	return true;
+#else
+	return false;
+#endif
 }
 
 bool KGlobalAccel::useFourModifierKeys()
@@ -94,5 +188,77 @@
 
 void KGlobalAccel::virtual_hook( int, void* )
 { /*BASE::virtual_hook( id, data );*/ }
+
+#ifdef Q_WS_MAC
+/* This is all temporary, they should get implemented appropriately later */
+KKeySequence::KKeySequence(const KKeyNative &)
+{
+	clear();
+}
+KKeyNative::KKeyNative(const KKey &)
+{
+}
+KKeyNative::KKeyNative()
+{
+}
+KKeyNative::~KKeyNative()
+{
+}
+void
+KKey::simplify()
+{
+}
+KKey
+KKeyNative::key() const
+{
+	return KKey();
+}
+int
+KKeyNative::keyCodeQt() const
+{
+	return 0;
+}
+bool
+KKeyNative::keyboardHasWinKey()
+{
+	return false;
+}
+KGlobalAccelPrivate::KGlobalAccelPrivate()
+{
+}
+void 
+KGlobalAccelPrivate::setEnabled( bool )
+{
+}
+bool 
+KGlobalAccelPrivate::connectKey( KAccelAction&, KKeySequence )
+{
+	return false;
+}
+bool 
+KGlobalAccelPrivate::disconnectKey( KAccelAction&, KKeySequence )
+{
+	return false;
+}
+bool
+KKeyServer::Key::init(const KKey &, bool)
+{
+	return false;
+}
+int 
+KKeyServer::Key::compare( const Key& key ) const
+{
+	return 0;
+}
+KKey
+KKeyServer::Key::key() const
+{
+	return KKey();
+}
+void
+KKeyServer::Variations::init(const KKey &, bool)
+{
+}
+#endif
 
 #include "kglobalaccel.moc"
Index: kdecore/kiconeffect.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kiconeffect.cpp,v
retrieving revision 1.45
diff -u -r1.45 kiconeffect.cpp
--- kdecore/kiconeffect.cpp	3 Jun 2003 00:28:50 -0000	1.45
+++ kdecore/kiconeffect.cpp	15 Aug 2003 23:16:54 -0000
@@ -361,7 +361,11 @@
 	int width  = img.width();
 	int height = img.height();
 	
+#ifdef Q_WS_X11
 	if (qt_use_xrender && qt_has_xft )
+#else
+        if ( true )
+#endif
 	  for (y=0; y<height; y++)
 	  {
 #ifdef WORDS_BIGENDIAN
@@ -427,7 +431,11 @@
 
 void KIconEffect::semiTransparent(QPixmap &pix)
 {
+#ifdef Q_WS_X11
     if ( qt_use_xrender && qt_has_xft )
+#else
+    if ( true )
+#endif
     {
 	QImage img=pix.convertToImage();
 	semiTransparent(img);
Index: kdecore/kiconloader.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kiconloader.cpp,v
retrieving revision 1.211
diff -u -r1.211 kiconloader.cpp
--- kdecore/kiconloader.cpp	19 Jun 2003 03:36:00 -0000	1.211
+++ kdecore/kiconloader.cpp	15 Aug 2003 23:16:54 -0000
@@ -370,8 +370,12 @@
     QString ext = name.right(4);
 
     static const QString &png_ext = KGlobal::staticQString(".png");
+#ifdef Q_WS_X11
     static const QString &xpm_ext = KGlobal::staticQString(".xpm");
     if (ext == png_ext || ext == xpm_ext)
+#else
+    if (ext == png_ext)
+#endif
       extensionLength=4;
 #ifdef HAVE_LIBART
     else
Index: kdecore/kipc.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kipc.cpp,v
retrieving revision 1.12
diff -u -r1.12 kipc.cpp
--- kdecore/kipc.cpp	28 Jul 2003 15:55:51 -0000	1.12
+++ kdecore/kipc.cpp	15 Aug 2003 23:16:55 -0000
@@ -37,7 +37,7 @@
 #include <kipc.h>
 
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 static long getSimpleProperty(Window w, Atom a)
 {
     Atom real_type;
@@ -105,5 +105,8 @@
     XSync(dpy,False);
 }
 #else
-	// FIXME(E): Implement in Qt Embedded
+void KIPC::sendMessageAll(Message msg, int data)
+{
+}
+// FIXME(E): Implement in Qt Embedded and Qt/Mac
 #endif
Index: kdecore/kkeynative.h
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kkeynative.h,v
retrieving revision 1.10
diff -u -r1.10 kkeynative.h
--- kdecore/kkeynative.h	6 Jun 2003 19:21:39 -0000	1.10
+++ kdecore/kkeynative.h	15 Aug 2003 23:16:55 -0000
@@ -79,7 +79,9 @@
 	 * @param xevent the XEvent that contains the key
 	 * @return true if succesful, false otherwise
 	 */
+#ifndef Q_WS_MAC
 	bool init( const XEvent* xevent );
+#endif
 
 	/**
 	 * Creates a new native key for the given KKey code.
Index: kdecore/klibloader.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/klibloader.cpp,v
retrieving revision 1.63
diff -u -r1.63 klibloader.cpp
--- kdecore/klibloader.cpp	17 Jun 2003 05:13:40 -0000	1.63
+++ kdecore/klibloader.cpp	15 Aug 2003 23:16:55 -0000
@@ -59,7 +59,7 @@
 
 
 extern "C" {
-extern int lt_dlopen_flag;
+extern int lt_dlopen_flag;
 }
 
 
@@ -541,7 +541,7 @@
 
 //    kdDebug(150) << "try to dlclose " << wrap->name << ": yes, done." << endl;
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
     if ( !deleted_one ) {
       /* Only do the hack once in this loop.
          WABA: *HACK*
@@ -567,7 +567,7 @@
       delete widgetlist;
     }
 #else
-    // FIXME(E): Implement in Qt Embedded
+    // FIXME(E): Implement in Qt Embedded and Qt/Mac
 #endif
 
     deleted_one = true;
Index: kdecore/kprocess.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kprocess.cpp,v
retrieving revision 1.125
diff -u -r1.125 kprocess.cpp
--- kdecore/kprocess.cpp	16 Jul 2003 20:58:22 -0000	1.125
+++ kdecore/kprocess.cpp	15 Aug 2003 23:16:56 -0000
@@ -69,6 +69,7 @@
 #include <pwd.h>
 #include <grp.h>
 
+#include <qdir.h>
 #include <qfile.h>
 #include <qsocketnotifier.h>
 #include <qapplication.h>
@@ -387,7 +388,23 @@
         const char *executable = arglist[0];
         if (!d->executable.isEmpty())
            executable = d->executable.data();
-        execvp(executable, arglist);
+#ifdef Q_OS_MACX
+	/* This tries to find the executable in an application bundle */
+	{
+	    QString bundle = executable;
+	    bundle += ".app/Contents/MacOS/" + bundle.section('/', -1);
+	    if(QFile::exists(bundle)) {
+		QFileInfo fileInfo(bundle);
+		if(fileInfo.isExecutable()) {
+		    QCString cstr(fileInfo.absFilePath().local8Bit());
+		    execvp(cstr.data(), arglist);
+		    executable = NULL;
+		}
+	    }
+	}
+#endif
+	if(executable)
+        	execvp(executable, arglist);
 
         char resultByte = 1;
         write(fd[1], &resultByte, 1);
Index: kdecore/krootprop.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/krootprop.cpp,v
retrieving revision 1.29
diff -u -r1.29 krootprop.cpp
--- kdecore/krootprop.cpp	28 Oct 2001 11:59:58 -0000	1.29
+++ kdecore/krootprop.cpp	15 Aug 2003 23:16:56 -0000
@@ -18,7 +18,7 @@
 */
 
 #include <qwidget.h>
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 #include "krootprop.h"
 #include "kglobal.h"
 #include "klocale.h"
Index: kdecore/kshortcut.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kshortcut.cpp,v
retrieving revision 1.21
diff -u -r1.21 kshortcut.cpp
--- kdecore/kshortcut.cpp	17 Apr 2003 16:08:03 -0000	1.21
+++ kdecore/kshortcut.cpp	15 Aug 2003 23:16:56 -0000
@@ -71,14 +71,18 @@
 	//KKeyServer::Sym sym;
 
 	//if( sym.initQt( keyQt )
+#ifndef Q_WS_MAC
 	if( KKeyServer::keyQtToSym( keyQt, m_sym )
 	    && KKeyServer::keyQtToMod( keyQt, m_mod ) )
 		return true;
 	else {
+#endif
 		m_sym = 0;
 		m_mod = 0;
 		return false;
+#ifndef Q_WS_MAC
 	}
+#endif
 }
 
 bool KKey::init( const QKeySequence& key )
@@ -128,8 +132,10 @@
 	}
 	// If there is one non-blank key left:
 	if( (i == rgs.size() - 1 && !rgs[i].isEmpty()) ) {
+#ifndef Q_WS_MAC
 		KKeyServer::Sym sym( rgs[i] );
 		m_sym = sym.m_sym;
+#endif
 	}
 
 	if( m_sym == 0 )
@@ -164,10 +170,12 @@
 {
 	QString s;
 
+#ifndef Q_WS_MAC
 	s = KKeyServer::modToStringUser( m_mod );
 	if( !s.isEmpty() )
 		s += '+';
 	s += KKeyServer::Sym(m_sym).toString();
+#endif
 
 	return s;
 }
@@ -179,10 +187,12 @@
 	//	<< " key = " << QString::number(m_sym, 16) << endl;
 	QString s;
 
+#ifndef Q_WS_MAC
 	s = KKeyServer::modToStringInternal( m_mod );
 	if( !s.isEmpty() )
 		s += '+';
 	s += KKeyServer::Sym(m_sym).toStringInternal();
+#endif
 	return s;
 }
 
@@ -197,7 +207,11 @@
 
 QString KKey::modFlagLabel( ModFlag modFlag )
 {
+#ifndef Q_WS_MAC
 	return KKeyServer::modToStringUser( modFlag );
+#else
+	return QString::null;
+#endif
 }
 
 //---------------------------------------------------------------------
@@ -496,10 +510,12 @@
 		os << "KShortcut::init( \"" << s << "\" ): ";
 		for( uint i = 0; i < m_nSeqs; i++ ) {
 			os << " m_rgseq[" << i << "]: ";
+#ifndef Q_WS_MAC
 			KKeyServer::Variations vars;
 			vars.init( m_rgseq[i].key(0), true );
 			for( uint j = 0; j < vars.count(); j++ )
 				os << QString::number(vars.m_rgkey[j].keyCodeQt(),16) << ',';
+#endif
 		}
 		kdDebug(125) << sDebug << endl;
 	}
Index: kdecore/kuniqueapplication.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kuniqueapplication.cpp,v
retrieving revision 1.59
diff -u -r1.59 kuniqueapplication.cpp
--- kdecore/kuniqueapplication.cpp	25 Jun 2003 22:32:12 -0000	1.59
+++ kdecore/kuniqueapplication.cpp	15 Aug 2003 23:16:56 -0000
@@ -46,8 +46,10 @@
 #include <netwm.h>
 #include <X11/Xlib.h>
 #define DISPLAY "DISPLAY"
-#else
+#elif defined(Q_WS_QWS)
 #define DISPLAY "QWS_DISPLAY"
+#elif defined(Q_WS_MAC)
+// no DISPLAY on Qt/Mac!
 #endif
 
 bool KUniqueApplication::s_nofork = false;
@@ -113,7 +115,11 @@
      kdError() << "KUniqueApplication: pipe() failed!" << endl;
      ::exit(255);
   }
+#ifdef Q_WS_MAC
+  int fork_result = vfork();
+#else
   int fork_result = fork();
+#endif
   switch(fork_result) {
   case -1:
      kdError() << "KUniqueApplication: fork() failed!" << endl;
@@ -130,6 +136,7 @@
         if (regName.isEmpty())
         {
            // Check DISPLAY
+#ifndef Q_WS_MAC
            if (QCString(getenv(DISPLAY)).isEmpty())
            {
               kdError() << "KUniqueApplication: Can't determine DISPLAY. Aborting." << endl;
@@ -137,6 +144,7 @@
               ::write(fd[1], &result, 1);
               ::exit(255);
            }
+#endif
 
            // Try to launch kdeinit.
            startKdeinit();
@@ -387,7 +395,7 @@
   d->processingRequest = false;
 }
 
-#ifndef Q_WS_QWS // FIXME(E): Implement for Qt/Embedded
+#ifdef Q_WS_X11 // FIXME(E): Implement for Qt/Embedded and Qt/Mac
 extern Time qt_x_time;
 #endif
 
@@ -395,7 +403,7 @@
 {
   if (!d->firstInstance)
   {
-#ifndef Q_WS_QWS // FIXME(E): Implement for Qt/Embedded
+#ifdef Q_WS_X11 // FIXME(E): Implement for Qt/Embedded and Qt/Mac
     if ( mainWidget() )
     {
       mainWidget()->show();
Index: kdecore/kwin.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kwin.cpp,v
retrieving revision 1.83
diff -u -r1.83 kwin.cpp
--- kdecore/kwin.cpp	11 Aug 2003 08:10:13 -0000	1.83
+++ kdecore/kwin.cpp	15 Aug 2003 23:16:56 -0000
@@ -32,7 +32,7 @@
 #include <qwhatsthis.h>
 #include <qcstring.h>
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 #include "kwin.h"
 #include "kapplication.h"
 
Index: kdecore/kxerrorhandler.h
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kxerrorhandler.h,v
retrieving revision 1.1
diff -u -r1.1 kxerrorhandler.h
--- kdecore/kxerrorhandler.h	28 Jul 2003 15:08:15 -0000	1.1
+++ kdecore/kxerrorhandler.h	15 Aug 2003 23:16:56 -0000
@@ -27,7 +27,9 @@
 
 #include <qvaluelist.h>
 #include <qwindowdefs.h>
+#ifdef Q_WS_X11
 #include <X11/Xlib.h>
+#endif
 
 /**
  * This class simplifies handling of X errors. It shouldn't be necessary to use
@@ -60,20 +62,26 @@
          * Creates error handler that will set error flag after encountering
          * any X error.
          */
+#ifdef Q_WS_X11
         KXErrorHandler( Display* dpy = qt_xdisplay());
+#endif
         /**
          * This constructor takes pointer to a function that will get request number,
          * error code number and resource id of the failed request, as provided
          * by XErrorEvent. If the function returns true, the error flag will be set.
          */
+#ifdef Q_WS_X11
         KXErrorHandler( bool (*handler)( int request, int error_code, unsigned long resource_id ), Display* dpy = qt_xdisplay());
+#endif
         /**
          * This constructor takes pointer to a function whose prototype matches
          * the one that's used with the XSetErrorHandler() Xlib function.
          * NOTE: For the error flag to be set, the function must return non-zero
          * value.
          */
+#ifdef Q_WS_X11
         KXErrorHandler( int (*handler)( Display*, XErrorEvent* ), Display* dpy = qt_xdisplay());
+#endif
         /**
          * This function returns true if the error flag is set (i.e. no custom handler
          * function was used and there was any error, or the custom handler indicated
@@ -86,6 +94,7 @@
         ~KXErrorHandler();
     private:
         void addHandler();
+#ifdef Q_WS_X11
         int handle( Display* dpy, XErrorEvent* e );
         bool (*user_handler1)( int request, int error_code, unsigned long resource_id );
         int (*user_handler2)( Display*, XErrorEvent* );
@@ -98,6 +107,7 @@
         static int pos;
         static int size;
         class KXErrorHandlerPrivate* d;
+#endif
     };
 
 #endif
Index: kdefx/kstyle.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdefx/kstyle.cpp,v
retrieving revision 1.38
diff -u -r1.38 kstyle.cpp
--- kdefx/kstyle.cpp	6 Jun 2003 23:59:07 -0000	1.38
+++ kdefx/kstyle.cpp	15 Aug 2003 23:16:58 -0000
@@ -1819,6 +1819,7 @@
 // This is meant to be ugly but fast.
 void TransparencyHandler::rightShadow(QImage& dst)
 {
+#if defined(Q_WS_X11)
 	if (dst.depth() != 32)
 		dst = dst.convertDepth(32);
 
@@ -1853,10 +1854,12 @@
 		*data++ = (unsigned char)((*data)*bottom_right_corner[i]);
 		data++;	// skip alpha
 	}
+#endif
 }
 
 void TransparencyHandler::bottomShadow(QImage& dst)
 {
+#if defined(Q_WS_X11)
 	if (dst.depth() != 32)
 		dst = dst.convertDepth(32);
 
@@ -1892,11 +1895,13 @@
 
 		strip_data = shadow_strip[++line];
 	}
+#endif
 }
 
 // Create a shadow of thickness 4.
 void TransparencyHandler::createShadowWindows(const QPopupMenu* p)
 {
+#if defined(Q_WS_X11)
 	int x2 = p->x()+p->width();
 	int y2 = p->y()+p->height();
 	QRect shadow1(x2, p->y() + 4, 4, p->height());
@@ -1908,8 +1913,10 @@
 	se.w2 = new QWidget(0, 0, WStyle_Customize | WType_Popup | WX11BypassWM );
 	se.w1->setGeometry(shadow1);
 	se.w2->setGeometry(shadow2);
+#if defined(Q_WS_X11)
 	XSelectInput(qt_xdisplay(), se.w1->winId(), StructureNotifyMask );
 	XSelectInput(qt_xdisplay(), se.w2->winId(), StructureNotifyMask );
+#endif
 
 	// Insert a new ShadowMap entry
 	shadowMap()[p] = se;
@@ -1936,10 +1943,12 @@
 	// Don't use QWidget::show() so we don't confuse QEffects, thus causing broken focus.
 	XMapWindow(qt_xdisplay(), se.w1->winId());
 	XMapWindow(qt_xdisplay(), se.w2->winId());
+#endif
 }
 
 void TransparencyHandler::removeShadowWindows(const QPopupMenu* p)
 {
+#if defined(Q_WS_X11)
 	ShadowMap::iterator it = shadowMap().find(p);
 	if (it != shadowMap().end())
 	{
@@ -1951,10 +1960,12 @@
 		delete se.w2;
 		shadowMap().erase(it);
 	}
+#endif
 }
 
 bool TransparencyHandler::eventFilter( QObject* object, QEvent* event )
 {
+#if defined(Q_WS_X11)
 	// Transparency idea was borrowed from KDE2's "MegaGradient" Style,
 	// Copyright (C) 2000 Daniel M. Duley <mosfet@kde.org>
 
@@ -2012,6 +2023,7 @@
 			p->setErasePixmap(QPixmap());
 	}
 
+#endif
 	return false;
 }
 
Index: kdeui/kcolordialog.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/kcolordialog.cpp,v
retrieving revision 1.107
diff -u -r1.107 kcolordialog.cpp
--- kdeui/kcolordialog.cpp	23 Jul 2003 05:02:50 -0000	1.107
+++ kdeui/kcolordialog.cpp	15 Aug 2003 23:16:59 -0000
@@ -64,12 +64,16 @@
 #include <config.h>
 #include <kdebug.h>
 
+#ifndef Q_WS_QWS
 #ifdef Q_WS_X11
 #include <X11/Xlib.h>
 
 // defined in qapplication_x11.cpp
 typedef int (*QX11EventFilter) (XEvent*);
 extern QX11EventFilter qt_set_x11_event_filter (QX11EventFilter filter);
+#elif defined(Q_WS_MAC)
+#include "qcolordialog.h"
+#endif
 
 static const char * const recentColors = "Recent_Colors";
 static const char * const customColors = "Custom_Colors";
@@ -887,7 +891,9 @@
     QCheckBox *cbDefaultColor;
     KColor defaultColor;
     KColor selColor;
+#ifdef Q_WS_X11
     QX11EventFilter oldfilter;
+#endif
 };
 
 
@@ -899,7 +905,9 @@
   d = new KColorDialogPrivate;
   d->bRecursion = true;
   d->bColorPicking = false;
+#ifdef Q_WS_X11
   d->oldfilter = 0;
+#endif
   d->cbDefaultColor = 0L;
   setHelp( QString::fromLatin1("kcolordialog.html"), QString::null );
   connect( this, SIGNAL(okClicked(void)),this,SLOT(slotWriteSettings(void)));
@@ -1131,8 +1139,10 @@
 
 KColorDialog::~KColorDialog()
 {
+#ifdef Q_WS_X11
     if (d->bColorPicking)
         qt_set_x11_event_filter(d->oldfilter);
+#endif
     delete d;
 }
 
@@ -1253,6 +1263,15 @@
 //
 int KColorDialog::getColor( QColor &theColor, QWidget *parent )
 {
+#ifdef Q_WS_MAC
+  //I want mac's color dialog because it will look like a native app!
+  QColor ret = QColorDialog::getColor(theColor, parent);
+  if(ret.isValid()) {
+    theColor = ret;
+    return Accepted;
+  }
+  return Rejected;
+#endif
   KColorDialog dlg( parent, "Color Selector", TRUE );
   if ( theColor.isValid() )
     dlg.setColor( theColor );
@@ -1271,6 +1290,15 @@
 //
 int KColorDialog::getColor( QColor &theColor, const QColor& defaultCol, QWidget *parent )
 {
+#ifdef Q_WS_MAC
+  //I want mac's color dialog because it will look like a native app!
+  QColor ret = QColorDialog::getColor(theColor, parent);
+  if(ret.isValid()) {
+    theColor = ret;
+    return Accepted;
+  }
+  return Rejected;
+#endif
   KColorDialog dlg( parent, "Color Selector", TRUE );
   dlg.setDefaultColor( defaultCol );
   dlg.setColor( theColor );
@@ -1433,6 +1461,7 @@
 
 static QWidget *kde_color_dlg_widget = 0;
 
+#ifdef Q_WS_X11
 static int kde_color_dlg_handler(XEvent *event)
 {
     if (event->type == ButtonRelease)
@@ -1444,12 +1473,15 @@
     }
     return FALSE;
 }
+#endif
 
 void
 KColorDialog::slotColorPicker()
 {
     d->bColorPicking = true;
+#ifdef Q_WS_X11
     d->oldfilter = qt_set_x11_event_filter(kde_color_dlg_handler);
+#endif
     kde_color_dlg_widget = this;
     grabMouse( crossCursor );
     grabKeyboard();
@@ -1461,8 +1493,10 @@
   if (d->bColorPicking)
   {
      d->bColorPicking = false;
+#ifdef Q_WS_X11
      qt_set_x11_event_filter(d->oldfilter);
      d->oldfilter = 0;
+#endif
      releaseMouse();
      releaseKeyboard();
      _setColor( grabColor( e->globalPos() ) );
@@ -1488,8 +1522,10 @@
      if (e->key() == Key_Escape)
      {
         d->bColorPicking = false;
+#ifdef Q_WS_X11
         qt_set_x11_event_filter(d->oldfilter);
         d->oldfilter = 0;
+#endif
         releaseMouse();
         releaseKeyboard();
      }
Index: kdeui/khelpmenu.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/khelpmenu.cpp,v
retrieving revision 1.52
diff -u -r1.52 khelpmenu.cpp
--- kdeui/khelpmenu.cpp	19 Feb 2003 15:27:41 -0000	1.52
+++ kdeui/khelpmenu.cpp	15 Aug 2003 23:16:59 -0000
@@ -277,7 +277,7 @@
   QWidget* w = QApplication::widgetAt( QCursor::pos(), TRUE );
   while ( w && !w->isTopLevel() && !w->inherits("QXEmbed")  )
       w = w->parentWidget();
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
    if ( w && w->inherits("QXEmbed") )
 	  (( QXEmbed*) w )->enterWhatsThisMode();
 #endif
Index: kdeui/klistbox.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/klistbox.cpp,v
retrieving revision 1.18
diff -u -r1.18 klistbox.cpp
--- kdeui/klistbox.cpp	4 Mar 2002 00:51:50 -0000	1.18
+++ kdeui/klistbox.cpp	15 Aug 2003 23:16:59 -0000
@@ -131,14 +131,14 @@
   setCurrentItem( m_pCurrentItem );
 
   if( m_pCurrentItem ) {
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
     //Shift pressed?
     if( (keybstate & ShiftMask) ) {
 #endif
       bool block = signalsBlocked();
       blockSignals( true );
 
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
       //No Ctrl? Then clear before!
       if( !(keybstate & ControlMask) )  
 	clearSelection(); 
@@ -171,7 +171,7 @@
       if( selectionMode() == QListBox::Single )
 	emit selectionChanged( m_pCurrentItem );
     }
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
     else if( (keybstate & ControlMask) )
       setSelected( m_pCurrentItem, !m_pCurrentItem->isSelected() );
 #endif
@@ -186,7 +186,7 @@
 
       setSelected( m_pCurrentItem, true );
     }
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
   }
   else
     kdDebug() << "That´s not supposed to happen!!!!" << endl;
@@ -206,13 +206,13 @@
     
   m_pAutoSelect->stop();
   
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
   //Don´t emit executed if in SC mode and Shift or Ctrl are pressed
   if( !( m_bUseSingle && ((keybstate & ShiftMask) || (keybstate & ControlMask)) ) ) {
 #endif
     emit executed( item );
     emit executed( item, pos );
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
   }
 #endif
 }
Index: kdeui/klistview.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/klistview.cpp,v
retrieving revision 1.202
diff -u -r1.202 klistview.cpp
--- kdeui/klistview.cpp	7 Jul 2003 04:31:36 -0000	1.202
+++ kdeui/klistview.cpp	15 Aug 2003 23:17:00 -0000
@@ -560,7 +560,7 @@
   QListViewItem* previousItem = currentItem();
   setCurrentItem( d->pCurrentItem );
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
   // FIXME(E): Implement for Qt Embedded
   if( d->pCurrentItem ) {
     //Shift pressed?
@@ -640,7 +640,7 @@
         }
         else
         {
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 	    // FIXME(E): Implement for Qt Embedded
             Window root;
             Window child;
Index: kdeui/kmainwindow.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/kmainwindow.cpp,v
retrieving revision 1.117
diff -u -r1.117 kmainwindow.cpp
--- kdeui/kmainwindow.cpp	29 Jul 2003 15:14:26 -0000	1.117
+++ kdeui/kmainwindow.cpp	15 Aug 2003 23:17:00 -0000
@@ -45,7 +45,7 @@
 #include <klocale.h>
 #include <kstandarddirs.h>
 #include <kstaticdeleter.h>
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 #include <netwm.h>
 #endif
 
@@ -269,7 +269,7 @@
     assert ( !kapp->geometryArgument().isNull() );
     assert ( d->care_about_geometry );
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
     // FIXME: (E) Implement something similar for Qt Embedded (or decide we don't need it)
     int x, y;
     int w, h;
@@ -517,7 +517,7 @@
 void KMainWindow::setPlainCaption( const QString &caption )
 {
     QMainWindow::setCaption( caption );
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
     NETWinInfo info( qt_xdisplay(), winId(), qt_xrootwin(), 0 );
     info.setName( caption.utf8().data() );
 #endif
@@ -820,6 +820,7 @@
 
 void KMainWindow::saveWindowSize( KConfig * config ) const
 {
+#ifdef Q_WS_X11
   int scnum = QApplication::desktop()->screenNumber(parentWidget());
   QRect desk = QApplication::desktop()->screenGeometry(scnum);
   // save maximalization as desktop size + 1 in that direction
@@ -839,10 +840,12 @@
      config->revertToDefault(heightString);
   else
      config->writeEntry(heightString, h );
+#endif
 }
 
 void KMainWindow::restoreWindowSize( KConfig * config )
 {
+#ifdef Q_WS_X11
     if (d->care_about_geometry) {
         parseGeometry(true);
     } else {
@@ -876,6 +879,7 @@
             KWin::setState( winId(), state );
         }
     }
+#endif
 }
 
 bool KMainWindow::initialGeometrySet() const
Index: kdeui/kmenubar.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/kmenubar.cpp,v
retrieving revision 1.171
diff -u -r1.171 kmenubar.cpp
--- kdeui/kmenubar.cpp	7 Aug 2003 13:34:39 -0000	1.171
+++ kdeui/kmenubar.cpp	15 Aug 2003 23:17:00 -0000
@@ -41,7 +41,7 @@
 #include <kmanagerselection.h>
 #include <qtimer.h>
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 #include <X11/Xatom.h>
@@ -66,13 +66,18 @@
     KMenuBarPrivate()
 	:   forcedTopLevel( false ),
 	    topLevel( false ),
-	    wasTopLevel( false ),
+	    wasTopLevel( false )
+#ifdef Q_WS_X11
+	    ,
             selection( NULL )
+#endif
 	{
 	}
     ~KMenuBarPrivate()
         {
+#ifdef Q_WS_X11
         delete selection;
+#endif
         }
     bool forcedTopLevel;
     bool topLevel;
@@ -81,11 +86,14 @@
     int lineWidth;  // dtto
     int margin;     // dtto
     bool fallback_mode; // dtto
+#ifdef Q_WS_X11
     KSelectionWatcher* selection;
     QTimer selection_timer;
     static Atom makeSelectionAtom();
+#endif
 };
 
+#ifdef Q_WS_X11
 static Atom selection_atom = None;
 static Atom msg_type_atom = None;
 
@@ -108,15 +116,20 @@
 	initAtoms();
     return selection_atom;
 }
+#endif
 
 KMenuBar::KMenuBar(QWidget *parent, const char *name)
   : QMenuBar(parent, name)
 {
+#ifndef Q_WS_MAC
     QXEmbed::initialize();
+#endif
 
     d = new KMenuBarPrivate;
+#ifndef Q_WS_MAC
     connect( &d->selection_timer, SIGNAL( timeout()),
         this, SLOT( selectionTimeout()));
+#endif
 
 #if (QT_VERSION-0 >= 0x030200) // XRANDR support
     connect( qApp->desktop(), SIGNAL( resized( int )), SLOT( updateFallbackSize()));
@@ -156,6 +169,7 @@
   d->topLevel = top_level;
   if ( isTopLevelMenu() )
   {
+#ifdef Q_WS_X11
       d->selection = new KSelectionWatcher( KMenuBarPrivate::makeSelectionAtom(),
           DefaultScreen( qt_xdisplay()));
       connect( d->selection, SIGNAL( newOwner( Window )),
@@ -163,13 +177,14 @@
       connect( d->selection, SIGNAL( lostOwner()),
           this, SLOT( updateFallbackSize()));
       kapp->installX11EventFilter( this );
+#endif
       d->frameStyle = frameStyle();
       d->lineWidth = lineWidth();
       d->margin = margin();
       d->fallback_mode = false;
       bool wasShown = !isHidden();
       reparent( parentWidget(), WType_TopLevel | WStyle_Tool | WStyle_NoBorder, QPoint(0,0), false );
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
       KWin::setType( winId(), NET::TopMenu );
 #endif
       QMenuBar::setFrameStyle( NoFrame );
@@ -180,9 +195,11 @@
           show();
   } else
   {
+#ifdef Q_WS_X11
       delete d->selection;
       d->selection = NULL;
       kapp->removeX11EventFilter( this );
+#endif
       setBackgroundMode( PaletteButton );
       setFrameStyle( d->frameStyle );
       setLineWidth( d->lineWidth );
@@ -253,6 +270,7 @@
 {
     if( !d->topLevel )
 	return;
+#ifdef Q_WS_X11
     if( d->selection->owner() != None )
     { // somebody is managing us, don't mess anything, undo changes
       // done in fallback mode if needed
@@ -270,6 +288,7 @@
     if( d->selection_timer.isActive())
 	return;
     d->selection_timer.start( 100, true );
+#endif
 }
 
 void KMenuBar::selectionTimeout()
@@ -288,7 +307,7 @@
 #endif
 	move(area.left() - margin, area.top() - margin); 
         setFixedSize(area.width() + 2* margin , heightForWidth( area.width() + 2 * margin ) );
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
         int strut_height = height() - margin;
         if( strut_height < 0 )
             strut_height = 0;
@@ -332,8 +351,10 @@
 
 void KMenuBar::checkResizingToParent( int& w, int& h )
 {
+#ifdef Q_WS_X11
     if( !d->topLevel || d->selection->owner() == None )
 	return;
+#endif
     if( parentWidget() && parentWidget()->width() == w )
     { // Menubar is possibly being attempted to be resized to match
       // mainwindow size. Resize to sizeHint() instead. Since
@@ -347,6 +368,7 @@
     }
 }
 
+#ifdef Q_WS_X11
 bool KMenuBar::x11Event( XEvent* ev )
 {
     if( ev->type == ClientMessage && ev->xclient.message_type == msg_type_atom
@@ -363,6 +385,7 @@
     }
     return QMenuBar::x11Event( ev );
 }
+#endif
 
 void KMenuBar::setFrameStyle( int style )
 {
Index: kdeui/kmenubar.h
===================================================================
RCS file: /home/kde/kdelibs/kdeui/kmenubar.h,v
retrieving revision 1.58
diff -u -r1.58 kmenubar.h
--- kdeui/kmenubar.h	6 Jun 2003 12:16:48 -0000	1.58
+++ kdeui/kmenubar.h	15 Aug 2003 23:17:00 -0000
@@ -88,7 +88,9 @@
     virtual void showEvent( QShowEvent* );
     virtual void resizeEvent( QResizeEvent* );
     virtual bool eventFilter(QObject *, QEvent *);
+#ifdef Q_WS_X11
     virtual bool x11Event( XEvent* );
+#endif
 private slots:
     void updateFallbackSize();
     void selectionTimeout();
Index: kdeui/kpassivepopup.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/kpassivepopup.cpp,v
retrieving revision 1.22
diff -u -r1.22 kpassivepopup.cpp
--- kdeui/kpassivepopup.cpp	13 Jul 2003 23:52:33 -0000	1.22
+++ kdeui/kpassivepopup.cpp	15 Aug 2003 23:17:01 -0000
@@ -162,6 +162,7 @@
 
 QRect KPassivePopup::defaultArea() const
 {
+#ifdef Q_WS_X11
     NETRootInfo info( qt_xdisplay(),
                       NET::NumberOfDesktops |
                       NET::CurrentDesktop |
@@ -172,12 +173,17 @@
     QRect r;
     r.setRect( workArea.pos.x, workArea.pos.y, 0, 0 ); // top left
     return r;
+#else
+    QPoint pt = QApplication::desktop()->availableGeometry(0).topLeft();
+    return QRect(pt, QSize(0, 0));
+#endif
 }
 
 void KPassivePopup::positionSelf()
 {
     QRect target;
 
+#ifdef Q_WS_X11
     if ( window == 0L ) {
         target = defaultArea();
     }
@@ -208,6 +214,9 @@
                 }
         }
     }
+#else
+    target = defaultArea();
+#endif
 
     moveNear( target );
 }
Index: kdeui/kpixmapio.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/kpixmapio.cpp,v
retrieving revision 1.28
diff -u -r1.28 kpixmapio.cpp
--- kdeui/kpixmapio.cpp	10 Mar 2003 20:42:34 -0000	1.28
+++ kdeui/kpixmapio.cpp	15 Aug 2003 23:17:01 -0000
@@ -27,7 +27,7 @@
 #include <kdebug.h>
 #include "kpixmapio.h"
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 #include <X11/X.h>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
@@ -50,7 +50,7 @@
     int threshold;
     int bpp;
     int byteorder;
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
     XImage *ximage;
 #ifdef HAVE_MITSHM
     XShmSegmentInfo *shminfo;
Index: kdeui/kprogress.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/kprogress.cpp,v
retrieving revision 1.49
diff -u -r1.49 kprogress.cpp
--- kdeui/kprogress.cpp	12 Jun 2003 01:10:07 -0000	1.49
+++ kdeui/kprogress.cpp	15 Aug 2003 23:17:02 -0000
@@ -170,7 +170,9 @@
       mShown(false),
       mMinDuration(2000)
 {
+#ifdef Q_WS_X11
     KWin::setIcons(winId(), kapp->icon(), kapp->miniIcon());
+#endif
     mShowTimer = new QTimer(this);
     
     showButton(KDialogBase::Close, false);
Index: kdeui/krootpixmap.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/krootpixmap.cpp,v
retrieving revision 1.20
diff -u -r1.20 krootpixmap.cpp
--- kdeui/krootpixmap.cpp	1 Jun 2003 01:49:31 -0000	1.20
+++ kdeui/krootpixmap.cpp	15 Aug 2003 23:17:02 -0000
@@ -73,9 +73,13 @@
 
 int KRootPixmap::currentDesktop() const
 {
+#ifdef Q_WS_X11
     NETRootInfo rinfo( qt_xdisplay(), NET::CurrentDesktop );
     rinfo.activate();
     return rinfo.currentDesktop();
+#else
+    return 0;
+#endif
 }
 
 
@@ -192,10 +196,12 @@
 
 QString KRootPixmap::pixmapName(int desk) {
     QString pattern = QString("DESKTOP%1");
+#ifdef Q_WS_X11
     int screen_number = DefaultScreen(qt_xdisplay());
     if (screen_number) {
         pattern = QString("SCREEN%1-DESKTOP").arg(screen_number) + "%1";
     }
+#endif
     return pattern.arg( desk );
 }
 
@@ -211,9 +217,11 @@
     args << 1;
 
     QCString appname( "kdesktop" );
+#ifdef Q_WS_X11
     int screen_number = DefaultScreen(qt_xdisplay());
     if ( screen_number )
         appname.sprintf("kdesktop-screen-%d", screen_number );
+#endif
 
     client->send( appname, "KBackgroundIface", "setExport(int)", data );
 }
Index: kdeui/ksharedpixmap.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/ksharedpixmap.cpp,v
retrieving revision 1.16
diff -u -r1.16 ksharedpixmap.cpp
--- kdeui/ksharedpixmap.cpp	15 Feb 2003 23:38:09 -0000	1.16
+++ kdeui/ksharedpixmap.cpp	15 Aug 2003 23:17:02 -0000
@@ -21,7 +21,7 @@
 #include <qwindowdefs.h>
 #include <qwidget.h>
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 
 #include <kapplication.h>
 #include <krootprop.h>
@@ -56,9 +56,11 @@
 class KSharedPixmapPrivate
 {
 public:
+#ifdef Q_WS_X11
   Atom pixmap;
   Atom target;
   Atom selection;
+#endif
   QRect rect;
 };
 
@@ -78,26 +80,33 @@
 
 void KSharedPixmap::init()
 {
+#ifdef Q_WS_X11
     d->pixmap = XInternAtom(qt_xdisplay(), "PIXMAP", false);
     QCString atom;
     atom.sprintf("target prop for window %lx", static_cast<unsigned long int>(winId()));
     d->target = XInternAtom(qt_xdisplay(), atom.data(), false);
     d->selection = None;
+#endif
 }
 
 
 bool KSharedPixmap::isAvailable(const QString & name) const
 {
+#ifdef Q_WS_X11
     QString str = QString("KDESHPIXMAP:%1").arg(name);
     Atom sel = XInternAtom(qt_xdisplay(), str.latin1(), true);
     if (sel == None)
 	return false;
     return XGetSelectionOwner(qt_xdisplay(), sel) != None;
+#else
+    return false;
+#endif
 }
 
 
 bool KSharedPixmap::loadFromShared(const QString & name, const QRect & rect)
 {
+#ifdef Q_WS_X11
     if (d->selection != None)
 	// already active
 	return false;
@@ -118,9 +127,12 @@
     XConvertSelection(qt_xdisplay(), d->selection, d->pixmap, d->target,
 	    winId(), CurrentTime);
     return true;
+#else
+    return false;
+#endif
 }
 
-
+#ifdef Q_WS_X11
 bool KSharedPixmap::x11Event(XEvent *event)
 {
     if (event->type != SelectionNotify)
@@ -218,6 +230,7 @@
     emit done(true);
     return true;
 }
+#endif
 
 
 #include "ksharedpixmap.moc"
Index: kdeui/ksharedpixmap.h
===================================================================
RCS file: /home/kde/kdelibs/kdeui/ksharedpixmap.h,v
retrieving revision 1.8
diff -u -r1.8 ksharedpixmap.h
--- kdeui/ksharedpixmap.h	18 Feb 2003 06:46:45 -0000	1.8
+++ kdeui/ksharedpixmap.h	15 Aug 2003 23:17:02 -0000
@@ -98,7 +98,9 @@
     void done(bool success);
 
 protected:
+#ifdef Q_WS_X11
     bool x11Event(XEvent *);
+#endif
     
 private:
     bool copy(const QString & id, const QRect & rect);
Index: kdeui/ksystemtray.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/ksystemtray.cpp,v
retrieving revision 1.32
diff -u -r1.32 ksystemtray.cpp
--- kdeui/ksystemtray.cpp	23 Jun 2003 22:29:22 -0000	1.32
+++ kdeui/ksystemtray.cpp	15 Aug 2003 23:17:02 -0000
@@ -30,7 +30,7 @@
 #include <qxembed.h>
 
 #include <qapplication.h>
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 #include <X11/Xlib.h>
 #ifndef KDE_USE_FINAL
 const int XFocusOut = FocusOut;
@@ -64,12 +64,14 @@
 KSystemTray::KSystemTray( QWidget* parent, const char* name )
     : QLabel( parent, name, WType_TopLevel )
 {
+#ifdef Q_WS_X11
     QXEmbed::initialize();
+#endif
     
     d = new KSystemTrayPrivate;
     d->actionCollection = new KActionCollection(this);
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
     // FIXME(E): Talk with QWS
     KWin::setSystemTrayWindowFor( winId(), parent?parent->topLevelWidget()->winId(): qt_xrootwin() );
     setBackgroundMode(X11ParentRelative);
@@ -86,8 +88,10 @@
         new KAction(i18n("Minimize"), KShortcut(),
                     this, SLOT( minimizeRestoreAction() ),
                     d->actionCollection, "minimizeRestore");
+#ifdef Q_WS_X11
 	KWin::WindowInfo info = KWin::windowInfo( parentWidget()->winId());
 	d->on_all_desktops = info.onAllDesktops();
+#endif
     }
     else
     {
@@ -128,7 +132,7 @@
 void KSystemTray::enterEvent( QEvent* e )
 {
 #if QT_VERSION < 0x030200
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
     // FIXME(E): Implement for Qt Embedded
     if ( !qApp->focusWidget() ) {
 	XEvent ev;
@@ -212,9 +216,14 @@
     if ( !pw )
 	return;
 
+#ifdef Q_WS_X11
     KWin::WindowInfo info = KWin::windowInfo( pw->winId() );
     // mapped = visible (but possibly obscured)
     bool mapped = (info.mappingState() != NET::Withdrawn);
+#else
+    bool mapped = false;
+#endif
+
 //    - not mapped -> show, raise, focus
 //    - mapped
 //        - obscured -> raise, focus
@@ -224,6 +233,7 @@
     else
     {
         KWinModule module;
+#ifdef Q_WS_X11
         for( QValueList< WId >::ConstIterator it = module.stackingOrder().fromLast();
              it != module.stackingOrder().end() && (*it) != pw->winId();
              --it )
@@ -236,6 +246,7 @@
                 return;
             }
         }
+#endif
         minimizeRestore( false ); // hide
     }
 }
@@ -245,10 +256,10 @@
     QWidget* pw = parentWidget();
     if( !pw )
 	return;
+#ifdef Q_WS_X11 //FIXME
     KWin::WindowInfo info = KWin::windowInfo( pw->winId(), NET::WMGeometry | NET::WMDesktop );
     if ( restore )
     {
-#ifndef Q_WS_QWS //FIXME
 	if( d->on_all_desktops )
 	    KWin::setOnAllDesktops( pw->winId(), true );
 	else
@@ -257,11 +268,11 @@
         pw->show();
         pw->raise();
 	KWin::setActiveWindow( pw->winId() );
-#endif
     } else {
 	d->on_all_desktops = info.onAllDesktops();
 	pw->hide();
     }
+#endif
 }
 
 KActionCollection* KSystemTray::actionCollection()
Index: kdeui/kwindowinfo.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/kwindowinfo.cpp,v
retrieving revision 1.3
diff -u -r1.3 kwindowinfo.cpp
--- kdeui/kwindowinfo.cpp	21 Jun 2002 13:01:22 -0000	1.3
+++ kdeui/kwindowinfo.cpp	15 Aug 2003 23:17:02 -0000
@@ -72,12 +72,14 @@
 
 void KWindowInfo::permanent( const QString &text )
 {
+#ifdef Q_WS_X11
     oldMiniIcon = KWin::icon( win->winId(), 16, 16, true );
     oldIcon = KWin::icon( win->winId(), 34, 34, false );
     if ( oldIcon.isNull() )
 	oldIcon = KWin::icon( win->winId(), 32, 32, true );
 
     permanent( text, oldIcon );
+#endif
 }
 
 void KWindowInfo::permanent( const QString &text, const QPixmap &pix )
@@ -115,11 +117,14 @@
 
     win->setCaption( text );
     win->setIcon( icon );
+#ifdef Q_WS_X11
     KWin::setIcons( win->winId(), icon, icon );
+#endif
 }
 
 void KWindowInfo::save()
 {
+#ifdef Q_WS_X11
     if ( !oldText.isNull() )
 	return;
 
@@ -143,6 +148,7 @@
 	else
 	    oldIcon.resize( 0, 0 );
     }
+#endif
 }
 
 void KWindowInfo::restore()
@@ -156,7 +162,9 @@
     }
 
     win->setIcon( oldIcon );
+#ifdef Q_WS_X11
     KWin::setIcons( win->winId(), oldIcon, oldMiniIcon );
+#endif
     win->setCaption( oldText );
     oldText = QString::null;
 
Index: kdeui/kwindowlistmenu.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdeui/kwindowlistmenu.cpp,v
retrieving revision 1.21
diff -u -r1.21 kwindowlistmenu.cpp
--- kdeui/kwindowlistmenu.cpp	2 Jul 2003 14:03:54 -0000	1.21
+++ kdeui/kwindowlistmenu.cpp	15 Aug 2003 23:17:03 -0000
@@ -29,7 +29,7 @@
 #include <kwinmodule.h>
 #include <klocale.h>
 #include <kstringhandler.h>
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
 #include <netwm.h>
 #endif
 #include <kapplication.h>
@@ -55,7 +55,7 @@
 
 int NameSortedInfoList::compareItems( QPtrCollection::Item s1, QPtrCollection::Item s2 )
 {
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
     KWin::WindowInfo *i1 = static_cast<KWin::WindowInfo *>(s1);
     KWin::WindowInfo *i2 = static_cast<KWin::WindowInfo *>(s2);
     QString title1, title2;
@@ -128,7 +128,7 @@
 KWindowListMenu::KWindowListMenu(QWidget *parent, const char *name)
   : KPopupMenu(parent, name)
 {
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
     kwin_module = new KWinModule(this);
 #endif
 
@@ -142,6 +142,7 @@
 
 static bool standaloneDialog( const KWin::WindowInfo* info, const NameSortedInfoList& list )
 {
+#ifdef Q_WS_X11
     WId group = info->groupLeader();
     if( group == 0 )
     {
@@ -153,6 +154,9 @@
         if( (*it)->groupLeader() == group )
             return false;
     return true;
+#else
+    return false;
+#endif
 }
 
 void KWindowListMenu::init()
@@ -160,7 +164,7 @@
     int i, d;
     i = 0;
 
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
     int nd = kwin_module->numberOfDesktops();
     int cd = kwin_module->currentDesktop();
     WId active_window = kwin_module->activeWindow();
@@ -242,7 +246,7 @@
 
 void KWindowListMenu::slotExec(int id)
 {
-#ifndef Q_WS_QWS //FIXME
+#ifdef Q_WS_X11 //FIXME
     if (id == 2000)
         ; // do nothing
     else if (id > 1000)
Index: kdeui/qxembed.h
===================================================================
RCS file: /home/kde/kdelibs/kdeui/qxembed.h,v
retrieving revision 1.16
diff -u -r1.16 qxembed.h
--- kdeui/qxembed.h	18 Mar 2003 09:12:29 -0000	1.16
+++ kdeui/qxembed.h	15 Aug 2003 23:17:03 -0000
@@ -24,7 +24,7 @@
 
 #include <qwidget.h>
 
-#ifndef Q_WS_QWS
+#ifdef Q_WS_X11
 
 /*
   Documentation for this class is in the cpp-file!
Index: libltdl/ltdl.c
===================================================================
RCS file: /home/kde/kdelibs/libltdl/ltdl.c,v
retrieving revision 1.24
diff -u -r1.24 ltdl.c
--- libltdl/ltdl.c	26 Jun 2003 23:46:28 -0000	1.24
+++ libltdl/ltdl.c	15 Aug 2003 23:17:07 -0000
@@ -29,6 +29,10 @@
 #  include <config.h>
 #endif
 
+#if HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+
 #if HAVE_STDIO_H
 #  include <stdio.h>
 #endif
@@ -57,19 +61,75 @@
 #  include <memory.h>
 #endif
 
-#ifdef _AIX
-#include <errno.h>
-#include <strings.h>
-#include <sys/ldr.h>
-#endif /* _AIX */
+#if HAVE_ERRNO_H
+#  include <errno.h>
+#endif
+
+
+#ifndef __WINDOWS__
+#  ifdef __WIN32__
+#    define __WINDOWS__
+#  endif
+#endif
+
+
+#undef LT_USE_POSIX_DIRENT
+#ifdef HAVE_CLOSEDIR
+#  ifdef HAVE_OPENDIR
+#    ifdef HAVE_READDIR
+#      ifdef HAVE_DIRENT_H
+#        define LT_USE_POSIX_DIRENT
+#      endif /* HAVE_DIRENT_H */
+#    endif /* HAVE_READDIR */
+#  endif /* HAVE_OPENDIR */
+#endif /* HAVE_CLOSEDIR */
+
+
+#undef LT_USE_WINDOWS_DIRENT_EMULATION
+#ifndef LT_USE_POSIX_DIRENT
+#  ifdef __WINDOWS__
+#    define LT_USE_WINDOWS_DIRENT_EMULATION
+#  endif /* __WINDOWS__ */
+#endif /* LT_USE_POSIX_DIRENT */
+
+
+#ifdef LT_USE_POSIX_DIRENT
+#  include <dirent.h>
+#  define LT_D_NAMLEN(dirent) (strlen((dirent)->d_name))
+#else
+#  ifdef LT_USE_WINDOWS_DIRENT_EMULATION
+#    define LT_D_NAMLEN(dirent) (strlen((dirent)->d_name))
+#  else
+#    define dirent direct
+#    define LT_D_NAMLEN(dirent) ((dirent)->d_namlen)
+#    if HAVE_SYS_NDIR_H
+#      include <sys/ndir.h>
+#    endif
+#    if HAVE_SYS_DIR_H
+#      include <sys/dir.h>
+#    endif
+#    if HAVE_NDIR_H
+#      include <ndir.h>
+#    endif
+#  endif
+#endif
+
+#if HAVE_ARGZ_H
+#  include <argz.h>
+#endif
+
+#if HAVE_ASSERT_H
+#  include <assert.h>
+#else
+#  define assert(arg)	((void) 0)
+#endif
 
 #include "ltdl.h"
 
-/* Bah.  We don't want inline.  Needs autoconf check, which we don't want.  */
-#ifdef inline
-#  undef inline
+#if WITH_DMALLOC
+#  include <dmalloc.h>
 #endif
-#define inline
+
 
 
 
@@ -90,12 +150,41 @@
 #  define LT_READTEXT_MODE "r"
 #endif
 
+#ifdef LT_USE_WINDOWS_DIRENT_EMULATION
+
+#include <windows.h>
+
+#define dirent lt_dirent
+#define DIR lt_DIR
+
+struct dirent
+{
+  char d_name[2048];
+  int  d_namlen;
+};
+
+typedef struct _DIR
+{
+  HANDLE hSearch;
+  WIN32_FIND_DATA Win32FindData;
+  BOOL firsttime;
+  struct dirent file_info;
+} DIR;
 
+#endif /* LT_USE_WINDOWS_DIRENT_EMULATION */
 
 
 /* --- MANIFEST CONSTANTS --- */
 
 
+/* Standard libltdl search path environment variable name  */
+#undef  LTDL_SEARCHPATH_VAR
+#define LTDL_SEARCHPATH_VAR	"LTDL_LIBRARY_PATH"
+
+/* Standard libtool archive file extension.  */
+#undef  LTDL_ARCHIVE_EXT
+#define LTDL_ARCHIVE_EXT	".la"
+
 /* max. filename length */
 #ifndef LT_FILENAME_MAX
 #  define LT_FILENAME_MAX	1024
@@ -112,6 +201,593 @@
 
 
 
+/* --- MEMORY HANDLING --- */
+
+
+/* These are the functions used internally.  In addition to making
+   use of the associated function pointers above, they also perform
+   error handling.  */
+static char   *lt_estrdup	LT_PARAMS((const char *str));
+static lt_ptr lt_emalloc	LT_PARAMS((size_t size));
+static lt_ptr lt_erealloc	LT_PARAMS((lt_ptr addr, size_t size));
+
+/* static lt_ptr rpl_realloc	LT_PARAMS((lt_ptr ptr, size_t size)); */
+#define rpl_realloc realloc
+
+/* These are the pointers that can be changed by the caller:  */
+LT_GLOBAL_DATA lt_ptr (*lt_dlmalloc)	LT_PARAMS((size_t size))
+ 			= (lt_ptr (*) LT_PARAMS((size_t))) malloc;
+LT_GLOBAL_DATA lt_ptr (*lt_dlrealloc)	LT_PARAMS((lt_ptr ptr, size_t size))
+ 			= (lt_ptr (*) LT_PARAMS((lt_ptr, size_t))) rpl_realloc;
+LT_GLOBAL_DATA void   (*lt_dlfree)	LT_PARAMS((lt_ptr ptr))
+ 			= (void (*) LT_PARAMS((lt_ptr))) free;
+
+/* The following macros reduce the amount of typing needed to cast
+   assigned memory.  */
+#if WITH_DMALLOC
+
+#define LT_DLMALLOC(tp, n)	((tp *) xmalloc ((n) * sizeof(tp)))
+#define LT_DLREALLOC(tp, p, n)	((tp *) xrealloc ((p), (n) * sizeof(tp)))
+#define LT_DLFREE(p)						\
+	LT_STMT_START { if (p) (p) = (xfree (p), (lt_ptr) 0); } LT_STMT_END
+
+#define LT_EMALLOC(tp, n)	((tp *) xmalloc ((n) * sizeof(tp)))
+#define LT_EREALLOC(tp, p, n)	((tp *) xrealloc ((p), (n) * sizeof(tp)))
+
+#else
+
+#define LT_DLMALLOC(tp, n)	((tp *) lt_dlmalloc ((n) * sizeof(tp)))
+#define LT_DLREALLOC(tp, p, n)	((tp *) rpl_realloc ((p), (n) * sizeof(tp)))
+#define LT_DLFREE(p)						\
+	LT_STMT_START { if (p) (p) = (lt_dlfree (p), (lt_ptr) 0); } LT_STMT_END
+
+#define LT_EMALLOC(tp, n)	((tp *) lt_emalloc ((n) * sizeof(tp)))
+#define LT_EREALLOC(tp, p, n)	((tp *) lt_erealloc ((p), (n) * sizeof(tp)))
+
+#endif
+
+#define LT_DLMEM_REASSIGN(p, q)			LT_STMT_START {	\
+	if ((p) != (q)) { if (p) lt_dlfree (p); (p) = (q); (q) = 0; }	\
+						} LT_STMT_END
+
+
+/* --- REPLACEMENT FUNCTIONS --- */
+
+
+#undef strdup
+#define strdup rpl_strdup
+
+static char *strdup LT_PARAMS((const char *str));
+
+static char *
+strdup(str)
+     const char *str;
+{
+  char *tmp = 0;
+
+  if (str)
+    {
+      tmp = LT_DLMALLOC (char, 1+ strlen (str));
+      if (tmp)
+	{
+	  strcpy(tmp, str);
+	}
+    }
+
+  return tmp;
+}
+
+
+#if ! HAVE_STRCMP
+
+#undef strcmp
+#define strcmp rpl_strcmp
+
+static int strcmp LT_PARAMS((const char *str1, const char *str2));
+
+static int
+strcmp (str1, str2)
+     const char *str1;
+     const char *str2;
+{
+  if (str1 == str2)
+    return 0;
+  if (str1 == 0)
+    return -1;
+  if (str2 == 0)
+    return 1;
+
+  for (;*str1 && *str2; ++str1, ++str2)
+    {
+      if (*str1 != *str2)
+	break;
+    }
+
+  return (int)(*str1 - *str2);
+}
+#endif
+
+
+#if ! HAVE_STRCHR
+
+#  if HAVE_INDEX
+#    define strchr index
+#  else
+#    define strchr rpl_strchr
+
+static const char *strchr LT_PARAMS((const char *str, int ch));
+
+static const char*
+strchr(str, ch)
+     const char *str;
+     int ch;
+{
+  const char *p;
+
+  for (p = str; *p != (char)ch && *p != LT_EOS_CHAR; ++p)
+    /*NOWORK*/;
+
+  return (*p == (char)ch) ? p : 0;
+}
+
+#  endif
+#endif /* !HAVE_STRCHR */
+
+
+#if ! HAVE_STRRCHR
+
+#  if HAVE_RINDEX
+#    define strrchr rindex
+#  else
+#    define strrchr rpl_strrchr
+
+static const char *strrchr LT_PARAMS((const char *str, int ch));
+
+static const char*
+strrchr(str, ch)
+     const char *str;
+     int ch;
+{
+  const char *p, *q = 0;
+
+  for (p = str; *p != LT_EOS_CHAR; ++p)
+    {
+      if (*p == (char) ch)
+	{
+	  q = p;
+	}
+    }
+
+  return q;
+}
+
+# endif
+#endif
+
+/* NOTE:  Neither bcopy nor the memcpy implementation below can
+          reliably handle copying in overlapping areas of memory.  Use
+          memmove (for which there is a fallback implmentation below)
+	  if you need that behaviour.  */
+#if ! HAVE_MEMCPY
+
+#  if HAVE_BCOPY
+#    define memcpy(dest, src, size)	bcopy (src, dest, size)
+#  else
+#    define memcpy rpl_memcpy
+
+static lt_ptr memcpy LT_PARAMS((lt_ptr dest, const lt_ptr src, size_t size));
+
+static lt_ptr
+memcpy (dest, src, size)
+     lt_ptr dest;
+     const lt_ptr src;
+     size_t size;
+{
+  size_t i = 0;
+
+  for (i = 0; i < size; ++i)
+    {
+      dest[i] = src[i];
+    }
+
+  return dest;
+}
+
+#  endif /* !HAVE_BCOPY */
+#endif   /* !HAVE_MEMCPY */
+
+#if ! HAVE_MEMMOVE
+#  define memmove rpl_memmove
+
+static lt_ptr memmove LT_PARAMS((lt_ptr dest, const lt_ptr src, size_t size));
+
+static lt_ptr
+memmove (dest, src, size)
+     lt_ptr dest;
+     const lt_ptr src;
+     size_t size;
+{
+  size_t i;
+
+  if (dest < src)
+    for (i = 0; i < size; ++i)
+      {
+	dest[i] = src[i];
+      }
+  else if (dest > src)
+    for (i = size -1; i >= 0; --i)
+      {
+	dest[i] = src[i];
+      }
+
+  return dest;
+}
+
+#endif /* !HAVE_MEMMOVE */
+
+#ifdef LT_USE_WINDOWS_DIRENT_EMULATION
+
+static void closedir LT_PARAMS((DIR *entry));
+
+static void
+closedir(entry)
+  DIR *entry;
+{
+  assert(entry != (DIR *) NULL);
+  FindClose(entry->hSearch);
+  lt_dlfree((lt_ptr)entry);
+}
+
+
+static DIR * opendir LT_PARAMS((const char *path));
+
+static DIR*
+opendir (path)
+  const char *path;
+{
+  char file_specification[LT_FILENAME_MAX];
+  DIR *entry;
+
+  assert(path != (char *) NULL);
+  (void) strncpy(file_specification,path,LT_FILENAME_MAX-1);
+  (void) strcat(file_specification,"\\");
+  entry = LT_DLMALLOC (DIR,sizeof(DIR));
+  if (entry != (DIR *) 0)
+    {
+      entry->firsttime = TRUE;
+      entry->hSearch = FindFirstFile(file_specification,&entry->Win32FindData);
+    }
+  if (entry->hSearch == INVALID_HANDLE_VALUE)
+    {
+      (void) strcat(file_specification,"\\*.*");
+      entry->hSearch = FindFirstFile(file_specification,&entry->Win32FindData);
+      if (entry->hSearch == INVALID_HANDLE_VALUE)
+        {
+          LT_DLFREE (entry);
+          return (DIR *) 0;
+        }
+    }
+  return(entry);
+}
+
+
+static struct dirent *readdir LT_PARAMS((DIR *entry));
+
+static struct dirent *readdir(entry)
+  DIR *entry;
+{
+  int
+    status;
+
+  if (entry == (DIR *) 0)
+    return((struct dirent *) 0);
+  if (!entry->firsttime)
+    {
+      status = FindNextFile(entry->hSearch,&entry->Win32FindData);
+      if (status == 0)
+        return((struct dirent *) 0);
+    }
+  entry->firsttime = FALSE;
+  (void) strncpy(entry->file_info.d_name,entry->Win32FindData.cFileName,
+    LT_FILENAME_MAX-1);
+  entry->file_info.d_namlen = strlen(entry->file_info.d_name);
+  return(&entry->file_info);
+}
+
+#endif /* LT_USE_WINDOWS_DIRENT_EMULATION */
+
+/* According to Alexandre Oliva <oliva@lsd.ic.unicamp.br>,
+    ``realloc is not entirely portable''
+   In any case we want to use the allocator supplied by the user without
+   burdening them with an lt_dlrealloc function pointer to maintain.
+   Instead implement our own version (with known boundary conditions)
+   using lt_dlmalloc and lt_dlfree. */
+
+/* #undef realloc
+   #define realloc rpl_realloc
+*/
+#if 0
+  /* You can't (re)define realloc unless you also (re)define malloc.
+     Right now, this code uses the size of the *destination* to decide
+     how much to copy.  That's not right, but you can't know the size
+     of the source unless you know enough about, or wrote malloc.  So
+     this code is disabled... */
+
+static lt_ptr
+realloc (ptr, size)
+     lt_ptr ptr;
+     size_t size;
+{
+  if (size == 0)
+    {
+      /* For zero or less bytes, free the original memory */
+      if (ptr != 0)
+	{
+	  lt_dlfree (ptr);
+	}
+
+      return (lt_ptr) 0;
+    }
+  else if (ptr == 0)
+    {
+      /* Allow reallocation of a NULL pointer.  */
+      return lt_dlmalloc (size);
+    }
+  else
+    {
+      /* Allocate a new block, copy and free the old block.  */
+      lt_ptr mem = lt_dlmalloc (size);
+
+      if (mem)
+	{
+	  memcpy (mem, ptr, size);
+	  lt_dlfree (ptr);
+	}
+
+      /* Note that the contents of PTR are not damaged if there is
+	 insufficient memory to realloc.  */
+      return mem;
+    }
+}
+#endif
+
+
+#if ! HAVE_ARGZ_APPEND
+#  define argz_append rpl_argz_append
+
+static error_t argz_append LT_PARAMS((char **pargz, size_t *pargz_len,
+					const char *buf, size_t buf_len));
+
+static error_t
+argz_append (pargz, pargz_len, buf, buf_len)
+     char **pargz;
+     size_t *pargz_len;
+     const char *buf;
+     size_t buf_len;
+{
+  size_t argz_len;
+  char  *argz;
+
+  assert (pargz);
+  assert (pargz_len);
+  assert ((*pargz && *pargz_len) || (!*pargz && !*pargz_len));
+
+  /* If nothing needs to be appended, no more work is required.  */
+  if (buf_len == 0)
+    return 0;
+
+  /* Ensure there is enough room to append BUF_LEN.  */
+  argz_len = *pargz_len + buf_len;
+  argz = LT_DLREALLOC (char, *pargz, argz_len);
+  if (!argz)
+    return ENOMEM;
+
+  /* Copy characters from BUF after terminating '\0' in ARGZ.  */
+  memcpy (argz + *pargz_len, buf, buf_len);
+
+  /* Assign new values.  */
+  *pargz = argz;
+  *pargz_len = argz_len;
+
+  return 0;
+}
+#endif /* !HAVE_ARGZ_APPEND */
+
+
+#if ! HAVE_ARGZ_CREATE_SEP
+#  define argz_create_sep rpl_argz_create_sep
+
+static error_t argz_create_sep LT_PARAMS((const char *str, int delim,
+					    char **pargz, size_t *pargz_len));
+
+static error_t
+argz_create_sep (str, delim, pargz, pargz_len)
+     const char *str;
+     int delim;
+     char **pargz;
+     size_t *pargz_len;
+{
+  size_t argz_len;
+  char *argz = 0;
+
+  assert (str);
+  assert (pargz);
+  assert (pargz_len);
+
+  /* Make a copy of STR, but replacing each occurence of
+     DELIM with '\0'.  */
+  argz_len = 1+ LT_STRLEN (str);
+  if (argz_len)
+    {
+      const char *p;
+      char *q;
+
+      argz = LT_DLMALLOC (char, argz_len);
+      if (!argz)
+	return ENOMEM;
+
+      for (p = str, q = argz; *p != LT_EOS_CHAR; ++p)
+	{
+	  if (*p == delim)
+	    {
+	      /* Ignore leading delimiters, and fold consecutive
+		 delimiters in STR into a single '\0' in ARGZ.  */
+	      if ((q > argz) && (q[-1] != LT_EOS_CHAR))
+		*q++ = LT_EOS_CHAR;
+	      else
+		--argz_len;
+	    }
+	  else
+	    *q++ = *p;
+	}
+      /* Copy terminating LT_EOS_CHAR.  */
+      *q = *p;
+    }
+
+  /* If ARGZ_LEN has shrunk to nothing, release ARGZ's memory.  */
+  if (!argz_len)
+    LT_DLFREE (argz);
+
+  /* Assign new values.  */
+  *pargz = argz;
+  *pargz_len = argz_len;
+
+  return 0;
+}
+#endif /* !HAVE_ARGZ_CREATE_SEP */
+
+
+#if ! HAVE_ARGZ_INSERT
+#  define argz_insert rpl_argz_insert
+
+static error_t argz_insert LT_PARAMS((char **pargz, size_t *pargz_len,
+					char *before, const char *entry));
+
+static error_t
+argz_insert (pargz, pargz_len, before, entry)
+     char **pargz;
+     size_t *pargz_len;
+     char *before;
+     const char *entry;
+{
+  assert (pargz);
+  assert (pargz_len);
+  assert (entry && *entry);
+
+  /* No BEFORE address indicates ENTRY should be inserted after the
+     current last element.  */
+  if (!before)
+    return argz_append (pargz, pargz_len, entry, 1+ LT_STRLEN (entry));
+
+  /* This probably indicates a programmer error, but to preserve
+     semantics, scan back to the start of an entry if BEFORE points
+     into the middle of it.  */
+  while ((before > *pargz) && (before[-1] != LT_EOS_CHAR))
+    --before;
+
+  {
+    size_t entry_len	= 1+ LT_STRLEN (entry);
+    size_t argz_len	= *pargz_len + entry_len;
+    size_t offset	= before - *pargz;
+    char   *argz	= LT_DLREALLOC (char, *pargz, argz_len);
+
+    if (!argz)
+      return ENOMEM;
+
+    /* Make BEFORE point to the equivalent offset in ARGZ that it
+       used to have in *PARGZ incase realloc() moved the block.  */
+    before = argz + offset;
+
+    /* Move the ARGZ entries starting at BEFORE up into the new
+       space at the end -- making room to copy ENTRY into the
+       resulting gap.  */
+    memmove (before + entry_len, before, *pargz_len - offset);
+    memcpy  (before, entry, entry_len);
+
+    /* Assign new values.  */
+    *pargz = argz;
+    *pargz_len = argz_len;
+  }
+
+  return 0;
+}
+#endif /* !HAVE_ARGZ_INSERT */
+
+
+#if ! HAVE_ARGZ_NEXT
+#  define argz_next rpl_argz_next
+
+static char *argz_next LT_PARAMS((char *argz, size_t argz_len,
+				    const char *entry));
+
+static char *
+argz_next (argz, argz_len, entry)
+     char *argz;
+     size_t argz_len;
+     const char *entry;
+{
+  assert ((argz && argz_len) || (!argz && !argz_len));
+
+  if (entry)
+    {
+      /* Either ARGZ/ARGZ_LEN is empty, or ENTRY points into an address
+	 within the ARGZ vector.  */
+      assert ((!argz && !argz_len)
+	      || ((argz <= entry) && (entry < (argz + argz_len))));
+
+      /* Move to the char immediately after the terminating
+	 '\0' of ENTRY.  */
+      entry = 1+ strchr (entry, LT_EOS_CHAR);
+
+      /* Return either the new ENTRY, or else NULL if ARGZ is
+	 exhausted.  */
+      return (entry >= argz + argz_len) ? 0 : (char *) entry;
+    }
+  else
+    {
+      /* This should probably be flagged as a programmer error,
+	 since starting an argz_next loop with the iterator set
+	 to ARGZ is safer.  To preserve semantics, handle the NULL
+	 case by returning the start of ARGZ (if any).  */
+      if (argz_len > 0)
+	return argz;
+      else
+	return 0;
+    }
+}
+#endif /* !HAVE_ARGZ_NEXT */
+
+
+
+#if ! HAVE_ARGZ_STRINGIFY
+#  define argz_stringify rpl_argz_stringify
+
+static void argz_stringify LT_PARAMS((char *argz, size_t argz_len,
+				       int sep));
+
+static void
+argz_stringify (argz, argz_len, sep)
+     char *argz;
+     size_t argz_len;
+     int sep;
+{
+  assert ((argz && argz_len) || (!argz && !argz_len));
+
+  if (sep)
+    {
+      --argz_len;		/* don't stringify the terminating EOS */
+      while (--argz_len > 0)
+	{
+	  if (argz[argz_len] == LT_EOS_CHAR)
+	    argz[argz_len] = sep;
+	}
+    }
+}
+#endif /* !HAVE_ARGZ_STRINGIFY */
+
+
+
+
 /* --- TYPE DEFINITIONS -- */
 
 
@@ -128,7 +804,7 @@
 
 
 /* Extract the diagnostic strings from the error table macro in the same
-   order as the enumberated indices in ltdl.h. */
+   order as the enumerated indices in ltdl.h. */
 
 static const char *lt_dlerror_strings[] =
   {
@@ -169,10 +845,6 @@
 #define LT_DLSET_FLAG(handle, flag) ((handle)->flags |= (flag))
 
 #define LT_DLRESIDENT_FLAG	    (0x01 << 0)
-#ifdef _AIX
-#define LT_DLNOTFOUND_FLAG	    (0x01 << 1) /* may be linked statically */
-#define LT_DLMEMBER_FLAG	    RTLD_MEMBER
-#endif /* _AIX */
 /* ...add more flags here... */
 
 #define LT_DLIS_RESIDENT(handle)    LT_DLGET_FLAG(handle, LT_DLRESIDENT_FLAG)
@@ -181,6 +853,7 @@
 #define LT_DLSTRERROR(name)	lt_dlerror_strings[LT_CONC(LT_ERROR_,name)]
 
 static	const char	objdir[]		= LTDL_OBJDIR;
+static	const char	archive_ext[]		= LTDL_ARCHIVE_EXT;
 #ifdef	LTDL_SHLIB_EXT
 static	const char	shlib_ext[]		= LTDL_SHLIB_EXT;
 #endif
@@ -194,29 +867,33 @@
 /* --- MUTEX LOCKING --- */
 
 
-/* Macros to make it easier to run the lock functions only if they have 
+/* Macros to make it easier to run the lock functions only if they have
    been registered.  The reason for the complicated lock macro is to
-   ensure that the stored error message from the last error is not 
+   ensure that the stored error message from the last error is not
    accidentally erased if the current function doesn't generate an
    error of its own.  */
-#define MUTEX_LOCK()				LT_STMT_START {	\
-	if (mutex_lock) (*mutex_lock)();	} LT_STMT_END
-#define MUTEX_UNLOCK()				LT_STMT_START { \
-	if (mutex_unlock) (*mutex_unlock)();	} LT_STMT_END
-#define MUTEX_SETERROR(errormsg)		LT_STMT_START {	\
-	if (mutex_seterror) (*mutex_seterror) (errormsg);	\
-	else last_error = (errormsg);		} LT_STMT_END
-#define MUTEX_GETERROR(errormsg)		LT_STMT_START {	\
-	if (mutex_seterror) errormsg = (*mutex_geterror)();	\
-	else (errormsg) = last_error;		} LT_STMT_END
+#define LT_DLMUTEX_LOCK()			LT_STMT_START {	\
+	if (lt_dlmutex_lock_func) (*lt_dlmutex_lock_func)();	\
+						} LT_STMT_END
+#define LT_DLMUTEX_UNLOCK()			LT_STMT_START { \
+	if (lt_dlmutex_unlock_func) (*lt_dlmutex_unlock_func)();\
+						} LT_STMT_END
+#define LT_DLMUTEX_SETERROR(errormsg)		LT_STMT_START {	\
+	if (lt_dlmutex_seterror_func)				\
+		(*lt_dlmutex_seterror_func) (errormsg);		\
+	else 	lt_dllast_error = (errormsg);	} LT_STMT_END
+#define LT_DLMUTEX_GETERROR(errormsg)		LT_STMT_START {	\
+	if (lt_dlmutex_seterror_func)				\
+		(errormsg) = (*lt_dlmutex_geterror_func) ();	\
+	else	(errormsg) = lt_dllast_error;	} LT_STMT_END
 
 /* The mutex functions stored here are global, and are necessarily the
    same for all threads that wish to share access to libltdl.  */
-static	lt_dlmutex_lock	    *mutex_lock	    = 0;
-static	lt_dlmutex_unlock   *mutex_unlock   = 0;
-static	lt_dlmutex_seterror *mutex_seterror = 0;
-static	lt_dlmutex_geterror *mutex_geterror = 0;
-static	const char	    *last_error	    = 0;
+static	lt_dlmutex_lock	    *lt_dlmutex_lock_func     = 0;
+static	lt_dlmutex_unlock   *lt_dlmutex_unlock_func   = 0;
+static	lt_dlmutex_seterror *lt_dlmutex_seterror_func = 0;
+static	lt_dlmutex_geterror *lt_dlmutex_geterror_func = 0;
+static	const char	    *lt_dllast_error	      = 0;
 
 
 /* Either set or reset the mutex functions.  Either all the arguments must
@@ -230,295 +907,129 @@
      lt_dlmutex_seterror *seterror;
      lt_dlmutex_geterror *geterror;
 {
-  lt_dlmutex_unlock *old_unlock = unlock;
-  int		     errors	= 0;
-
-  /* Lock using the old lock() callback, if any.  */
-  MUTEX_LOCK ();
-
-  if ((lock && unlock && seterror && geterror) 
-      || !(lock || unlock || seterror || geterror))
-    {
-      mutex_lock     = lock;
-      mutex_unlock   = unlock;
-      mutex_geterror = geterror;
-    }
-  else
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_MUTEX_ARGS));
-      ++errors;
-    }
-
-  /* Use the old unlock() callback we saved earlier, if any.  Otherwise
-     record any errors using internal storage.  */
-  if (old_unlock)
-    (*old_unlock) ();
-
-  /* Return the number of errors encountered during the execution of
-     this function.  */
-  return errors;
-}
-
-
-
-
-/* --- MEMORY HANDLING --- */
-
-
-LT_GLOBAL_DATA    lt_ptr	(*lt_dlmalloc)	LT_PARAMS((size_t size))
- 				    = (lt_ptr (*) LT_PARAMS((size_t))) malloc;
-LT_GLOBAL_DATA    void		(*lt_dlfree)	LT_PARAMS((lt_ptr ptr))
- 				    = (void (*) LT_PARAMS((lt_ptr))) free;
-
-static		  lt_ptr	rpl_realloc	LT_PARAMS((lt_ptr ptr,
-							   size_t size));
-
-#define LT_DLMALLOC(tp, n)	((tp *) lt_dlmalloc ((n) * sizeof(tp)))
-#define LT_DLREALLOC(tp, p, n)	((tp *) rpl_realloc ((p), (n) * sizeof(tp)))
-#define LT_DLFREE(p)						\
-	LT_STMT_START { if (p) (p) = (lt_dlfree (p), (lt_ptr) 0); } LT_STMT_END
-
-#define LT_DLMEM_REASSIGN(p, q)			LT_STMT_START {	\
-	if ((p) != (q)) { lt_dlfree (p); (p) = (q); }		\
-						} LT_STMT_END
-
-
-
-/* --- ERROR MESSAGES --- */
-
-
-static	const char    **user_error_strings	= 0;
-static	int		errorcount		= LT_ERROR_MAX;
-
-int
-lt_dladderror (diagnostic)
-     const char *diagnostic;
-{
-  int		_index	 = 0;
-  int		result	 = -1;
-  const char  **temp     = (const char **) 0;
-
-  MUTEX_LOCK ();
-
-  _index	 = errorcount - LT_ERROR_MAX;
-  temp = LT_DLREALLOC (const char *, user_error_strings, 1 + _index);
-  if (temp == 0)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-    }
-  else
-    {
-      user_error_strings	= temp;
-      user_error_strings[_index] = diagnostic;
-      result			= errorcount++;
-    }
-
-  MUTEX_UNLOCK ();
-
-  return result;
-}
-
-int
-lt_dlseterror (_index)
-     int _index;
-{
-  int		errors	 = 0;
-
-  MUTEX_LOCK ();
-
-  if (_index >= errorcount || _index < 0)
-    {
-      /* Ack!  Error setting the error message! */
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_ERRORCODE));
-      ++errors;
-    }
-  else if (_index < LT_ERROR_MAX)
-    {
-      /* No error setting the error message! */
-      MUTEX_SETERROR (lt_dlerror_strings[errorcount]);
-    }
-  else
-    {
-      /* No error setting the error message! */
-      MUTEX_SETERROR (user_error_strings[errorcount - LT_ERROR_MAX]);
-    }
-
-  MUTEX_UNLOCK ();
-
-  return errors;
-}
-
-
-
-
-/* --- REPLACEMENT FUNCTIONS --- */
-
-
-#undef strdup
-#define strdup rpl_strdup
-
-static inline char *
-strdup(str)
-     const char *str;
-{
-  char *tmp = 0;
-
-  if (str)
-    {
-      tmp = LT_DLMALLOC (char, 1+ strlen (str));
-      if (tmp)
-	{
-	  strcpy(tmp, str);
-	}
-    }
-
-  return tmp;
-}
-
-
-#if ! HAVE_STRCMP
-
-#undef strcmp
-#define strcmp rpl_strcmp
-
-static inline int
-strcmp (str1, str2)
-     const char *str1;
-     const char *str2;
-{
-  if (str1 == str2)
-    return 0;
-  if (str1 == 0)
-    return -1;
-  if (str2 == 0)
-    return 1;
+  lt_dlmutex_unlock *old_unlock = unlock;
+  int		     errors	= 0;
 
-  for (;*str1 && *str2; ++str1, ++str2)
+  /* Lock using the old lock() callback, if any.  */
+  LT_DLMUTEX_LOCK ();
+
+  if ((lock && unlock && seterror && geterror)
+      || !(lock || unlock || seterror || geterror))
     {
-      if (*str1 != *str2)
-	break;
+      lt_dlmutex_lock_func     = lock;
+      lt_dlmutex_unlock_func   = unlock;
+      lt_dlmutex_geterror_func = geterror;
+    }
+  else
+    {
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_MUTEX_ARGS));
+      ++errors;
     }
 
-  return (int)(*str1 - *str2);
-}
-#endif
-
+  /* Use the old unlock() callback we saved earlier, if any.  Otherwise
+     record any errors using internal storage.  */
+  if (old_unlock)
+    (*old_unlock) ();
 
-#if ! HAVE_STRCHR
+  /* Return the number of errors encountered during the execution of
+     this function.  */
+  return errors;
+}
 
-#  if HAVE_INDEX
-#    define strchr index
-#  else
-#    define strchr rpl_strchr
 
-static inline const char*
-strchr(str, ch)
-     const char *str;
-     int ch;
-{
-  const char *p;
 
-  for (p = str; *p != (char)ch && *p != '\0'; ++p)
-    /*NOWORK*/;
+
+/* --- ERROR HANDLING --- */
 
-  return (*p == (char)ch) ? p : 0;
-}
 
-#  endif
-#endif /* !HAVE_STRCHR */
+static	const char    **user_error_strings	= 0;
+static	int		errorcount		= LT_ERROR_MAX;
 
-#if ! HAVE_STRRCHR
+int
+lt_dladderror (diagnostic)
+     const char *diagnostic;
+{
+  int		errindex = 0;
+  int		result	 = -1;
+  const char  **temp     = (const char **) 0;
 
-#  if HAVE_RINDEX
-#    define strrchr rindex
-#  else
-#    define strrchr rpl_strrchr
+  assert (diagnostic);
 
-static inline const char*
-strrchr(str, ch)
-     const char *str;
-     int ch;
-{
-  const char *p, *q = 0;
+  LT_DLMUTEX_LOCK ();
 
-  for (p = str; *p != '\0'; ++p)
+  errindex = errorcount - LT_ERROR_MAX;
+  temp = LT_EREALLOC (const char *, user_error_strings, 1 + errindex);
+  if (temp)
     {
-      if (*p == (char) ch)
-	{
-	  q = p;
-	}
+      user_error_strings		= temp;
+      user_error_strings[errindex]	= diagnostic;
+      result				= errorcount++;
     }
 
-  return q;
-}
-
-# endif
-#endif
-
-/* NOTE:  Neither bcopy nor the memcpy implementation below can
-          reliably handle copying in overlapping areas of memory, so
-          do not rely on this behaviour when invoking memcpy later.  */
-#if ! HAVE_MEMCPY
+  LT_DLMUTEX_UNLOCK ();
 
-#  if HAVE_BCOPY
-#    define memcpy(dest, src, size)	bcopy (src, dest, size)
-#  else
-#    define memcpy rpl_memcpy
+  return result;
+}
 
-static inline char *
-memcpy (dest, src, size)
-     char *dest;
-     const char *src;
-     size_t size;
+int
+lt_dlseterror (errindex)
+     int errindex;
 {
-  size_t i = 0;
+  int		errors	 = 0;
 
-  for (i = 0; i < size; ++i)
+  LT_DLMUTEX_LOCK ();
+
+  if (errindex >= errorcount || errindex < 0)
     {
-      dest[i] = src[i];
+      /* Ack!  Error setting the error message! */
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_ERRORCODE));
+      ++errors;
+    }
+  else if (errindex < LT_ERROR_MAX)
+    {
+      /* No error setting the error message! */
+      LT_DLMUTEX_SETERROR (lt_dlerror_strings[errindex]);
+    }
+  else
+    {
+      /* No error setting the error message! */
+      LT_DLMUTEX_SETERROR (user_error_strings[errindex - LT_ERROR_MAX]);
     }
 
-  return dest;
-}
+  LT_DLMUTEX_UNLOCK ();
 
-#  endif
-#endif
+  return errors;
+}
 
-/* According to Alexandre Oliva <oliva@lsd.ic.unicamp.br>,
-    ``realloc is not entirely portable''
-   In any case we want to use the allocator supplied by the user without
-   burdening them with an lt_dlrealloc function pointer to maintain.
-   Instead implement our own version (with known boundary conditions)
-   using lt_dlmalloc and lt_dlfree. */
 static lt_ptr
-rpl_realloc (ptr, size)
-     lt_ptr ptr;
+lt_emalloc (size)
      size_t size;
 {
-  if (size < 1)
-    {
-      /* For zero or less bytes, free the original memory */
-      if (ptr != 0)
-	{
-	  lt_dlfree (ptr);
-	}
+  lt_ptr mem = lt_dlmalloc (size);
+  if (size && !mem)
+    LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
+  return mem;
+}
 
-      return (lt_ptr) 0;
-    }
-  else if (ptr == 0)
-    {
-      /* Allow reallocation of a NULL pointer.  */
-      return lt_dlmalloc (size);
-    }
-  else
-    {
-      /* Allocate a new block, copy and free the old block.  */
-      lt_ptr mem = (lt_ptr) realloc (ptr, size);
+static lt_ptr
+lt_erealloc (addr, size)
+     lt_ptr addr;
+     size_t size;
+{
+  lt_ptr mem = realloc (addr, size);
+  if (size && !mem)
+    LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
+  return mem;
+}
 
-      /* Note that the contents of PTR are not damaged if there is
-	 insufficient memory to realloc.  */
-      return mem;
-    }
+static char *
+lt_estrdup (str)
+     const char *str;
+{
+  char *copy = strdup (str);
+  if (LT_STRLEN (str) && !copy)
+    LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
+  return copy;
 }
 
 
@@ -526,11 +1037,8 @@
 
 /* --- DLOPEN() INTERFACE LOADER --- */
 
-/* The Cygwin dlopen implementation prints a spurious error message to
-   stderr if its call to LoadLibrary() fails for any reason.  We can
-   mitigate this by not using the Cygwin implementation, and falling
-   back to our own LoadLibrary() wrapper. */
-#if HAVE_LIBDL && !defined(__CYGWIN__)
+
+#if HAVE_LIBDL
 
 /* dynamic linking with dlopen/dlsym */
 
@@ -538,6 +1046,10 @@
 #  include <dlfcn.h>
 #endif
 
+#if HAVE_SYS_DL_H
+#  include <sys/dl.h>
+#endif
+
 #ifdef RTLD_GLOBAL
 #  define LT_GLOBAL		RTLD_GLOBAL
 #else
@@ -579,40 +1091,16 @@
 #  define DLERROR(arg)	LT_DLSTRERROR (arg)
 #endif
 
-int lt_dlopen_flag = LT_LAZY_OR_NOW;
-
-#ifdef _AIX
-/*------------------------------------------------------------------*/
-/* implementations found at the end                                 */
-/*------------------------------------------------------------------*/
-
-static void
-sys_dl_init( );
-
-static lt_dlhandle
-sys_dl_search_by_name( const char* name );
-
-static void
-sys_dl_not_found_entry( const char* tmp );
-#endif /* _AIX */
-
 static lt_module
 sys_dl_open (loader_data, filename)
      lt_user_data loader_data;
      const char *filename;
 {
-  lt_module module;
-#ifdef _AIX
-  /* If the basename is of the form "libname.a(member)",
-     set the appropriate flag. */
-  if (strrchr(filename, '('))
-    lt_dlopen_flag |= LT_DLMEMBER_FLAG;
-#endif
-  module = dlopen (filename, lt_dlopen_flag);
+  lt_module   module   = dlopen (filename, LT_GLOBAL | LT_LAZY_OR_NOW);
 
   if (!module)
     {
-      MUTEX_SETERROR (DLERROR (CANNOT_OPEN));
+      LT_DLMUTEX_SETERROR (DLERROR (CANNOT_OPEN));
     }
 
   return module;
@@ -627,7 +1115,7 @@
 
   if (dlclose (module) != 0)
     {
-      MUTEX_SETERROR (DLERROR (CANNOT_CLOSE));
+      LT_DLMUTEX_SETERROR (DLERROR (CANNOT_CLOSE));
       ++errors;
     }
 
@@ -644,7 +1132,7 @@
 
   if (!address)
     {
-      MUTEX_SETERROR (DLERROR (SYMBOL_NOT_FOUND));
+      LT_DLMUTEX_SETERROR (DLERROR (SYMBOL_NOT_FOUND));
     }
 
   return address;
@@ -659,8 +1147,7 @@
 #  endif
     sys_dl_open, sys_dl_close, sys_dl_sym, 0, 0 };
 
-#else
-int lt_dlopen_flag = 0;
+
 #endif /* HAVE_LIBDL */
 
 
@@ -720,20 +1207,33 @@
      lt_user_data loader_data;
      const char *filename;
 {
-  /* A NULL handle is used to get symbols from self and everything
-     else already loaded that was exported with -E compiler flag.  */
-  lt_module module = (lt_module) 0;
+  static shl_t self = (shl_t) 0;
+  lt_module module = shl_load (filename, LT_BIND_FLAGS, 0L);
 
-  if (filename)
+  /* Since searching for a symbol against a NULL module handle will also
+     look in everything else that was already loaded and exported with
+     the -E compiler flag, we always cache a handle saved before any
+     modules are loaded.  */
+  if (!self)
+    {
+      lt_ptr address;
+      shl_findsym (&self, "main", TYPE_UNDEFINED, &address);
+    }
+
+  if (!filename)
+    {
+      module = self;
+    }
+  else
     {
       module = shl_load (filename, LT_BIND_FLAGS, 0L);
 
       if (!module)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
 	}
     }
-  
+
   return module;
 }
 
@@ -746,7 +1246,7 @@
 
   if (module && (shl_unload ((shl_t) (module)) != 0))
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
       ++errors;
     }
 
@@ -759,23 +1259,20 @@
      lt_module module;
      const char *symbol;
 {
-  int    is_module_self = (module == (lt_module) 0);
-  lt_ptr address        = 0;
+  lt_ptr address = 0;
 
-  /* shl_findsym considers zero valued MODULE as an indicator to search
-     for a symbol among all loaded (and exported) symbols including those
-     in the main executable.  However, it sets MODULE to a valid module
-     address which breaks the semantics of libltdl's module management.  */
-  if (shl_findsym ((shl_t*) &module, symbol, TYPE_UNDEFINED, &address) == 0)
+  /* sys_shl_open should never return a NULL module handle */
+  if (module == (lt_module) 0)
+  {
+    LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+  }
+  else if (!shl_findsym((shl_t*) &module, symbol, TYPE_UNDEFINED, &address))
     {
       if (!address)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
 	}
     }
-  
-  if (is_module_self)
-    module = (lt_module) 0;
 
   return address;
 }
@@ -827,21 +1324,18 @@
   if (ext)
     {
       /* FILENAME already has an extension. */
-      searchname = strdup (filename);
+      searchname = lt_estrdup (filename);
     }
   else
     {
       /* Append a `.' to stop Windows from adding an
 	 implicit `.dll' extension. */
-      searchname = LT_DLMALLOC (char, 2+ strlen (filename));
-      if (!searchname)
-	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	  return 0;
-	}
-      strcpy (searchname, filename);
-      strcat (searchname, ".");
+      searchname = LT_EMALLOC (char, 2+ LT_STRLEN (filename));
+      if (searchname)
+	sprintf (searchname, "%s.", filename);
     }
+  if (!searchname)
+    return 0;
 
 #if __CYGWIN__
   {
@@ -862,7 +1356,7 @@
      We check whether LoadLibrary is returning a handle to
      an already loaded module, and simulate failure if we
      find one. */
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   cur = handles;
   while (cur)
     {
@@ -879,11 +1373,11 @@
 
       cur = cur->next;
   }
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   if (cur || !module)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
       module = 0;
     }
 
@@ -899,7 +1393,7 @@
 
   if (FreeLibrary(module) == 0)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
       ++errors;
     }
 
@@ -916,7 +1410,7 @@
 
   if (!address)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
     }
 
   return address;
@@ -961,7 +1455,7 @@
 
   if (image <= 0)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
       image = 0;
     }
 
@@ -977,7 +1471,7 @@
 
   if (unload_add_on ((image_id) module) != B_OK)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
       ++errors;
     }
 
@@ -995,7 +1489,7 @@
 
   if (get_image_symbol (image, symbol, B_SYMBOL_TYPE_ANY, address) != B_OK)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
       address = 0;
     }
 
@@ -1014,79 +1508,417 @@
 /* --- DLD_LINK() INTERFACE LOADER --- */
 
 
-#if HAVE_DLD
+#if HAVE_DLD
+
+/* dynamic linking with dld */
+
+#if HAVE_DLD_H
+#include <dld.h>
+#endif
+
+static lt_module
+sys_dld_open (loader_data, filename)
+     lt_user_data loader_data;
+     const char *filename;
+{
+  lt_module module = strdup (filename);
+
+  if (dld_link (filename) != 0)
+    {
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
+      LT_DLFREE (module);
+      module = 0;
+    }
+
+  return module;
+}
+
+static int
+sys_dld_close (loader_data, module)
+     lt_user_data loader_data;
+     lt_module module;
+{
+  int errors = 0;
+
+  if (dld_unlink_by_file ((char*)(module), 1) != 0)
+    {
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
+      ++errors;
+    }
+  else
+    {
+      LT_DLFREE (module);
+    }
+
+  return errors;
+}
+
+static lt_ptr
+sys_dld_sym (loader_data, module, symbol)
+     lt_user_data loader_data;
+     lt_module module;
+     const char *symbol;
+{
+  lt_ptr address = dld_get_func (symbol);
+
+  if (!address)
+    {
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
+    }
+
+  return address;
+}
+
+static struct lt_user_dlloader sys_dld = {
+  0, sys_dld_open, sys_dld_close, sys_dld_sym, 0, 0
+};
+
+#endif /* HAVE_DLD */
+
+/* --- DYLD() MACOSX/DARWIN INTERFACE LOADER --- */
+#if HAVE_DYLD
+
+
+#if HAVE_MACH_O_DYLD_H
+#if !defined(__APPLE_CC__) && !defined(__MWERKS__) && !defined(__private_extern__)
+/* Is this correct? Does it still function properly? */
+#define __private_extern__ extern
+#endif
+# include <mach-o/dyld.h>
+#endif
+#include <mach-o/getsect.h>
+
+/* We have to put some stuff here that isn't in older dyld.h files */
+#ifndef ENUM_DYLD_BOOL
+# define ENUM_DYLD_BOOL
+# undef FALSE
+# undef TRUE
+ enum DYLD_BOOL {
+    FALSE,
+    TRUE
+ };
+#endif
+#ifndef LC_REQ_DYLD
+# define LC_REQ_DYLD 0x80000000
+#endif
+#ifndef LC_LOAD_WEAK_DYLIB
+# define LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)
+#endif
+static const struct mach_header * (*ltdl_NSAddImage)(const char *image_name, unsigned long options) = 0;
+static NSSymbol (*ltdl_NSLookupSymbolInImage)(const struct mach_header *image,const char *symbolName, unsigned long options) = 0;
+static enum DYLD_BOOL (*ltdl_NSIsSymbolNameDefinedInImage)(const struct mach_header *image, const char *symbolName) = 0;
+static enum DYLD_BOOL (*ltdl_NSMakePrivateModulePublic)(NSModule module) = 0;
+
+#ifndef NSADDIMAGE_OPTION_NONE
+#define NSADDIMAGE_OPTION_NONE                          0x0
+#endif
+#ifndef NSADDIMAGE_OPTION_RETURN_ON_ERROR
+#define NSADDIMAGE_OPTION_RETURN_ON_ERROR               0x1
+#endif
+#ifndef NSADDIMAGE_OPTION_WITH_SEARCHING
+#define NSADDIMAGE_OPTION_WITH_SEARCHING                0x2
+#endif
+#ifndef NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED
+#define NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED         0x4
+#endif
+#ifndef NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME
+#define NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME 0x8
+#endif
+#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND
+#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND            0x0
+#endif
+#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW
+#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW        0x1
+#endif
+#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY
+#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY      0x2
+#endif
+#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR
+#define NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR 0x4
+#endif
+
+
+static const char *
+lt_int_dyld_error(othererror)
+	char* othererror;
+{
+/* return the dyld error string, or the passed in error string if none */
+	NSLinkEditErrors ler;
+	int lerno;
+	const char *errstr;
+	const char *file;
+	NSLinkEditError(&ler,&lerno,&file,&errstr);
+	if (!errstr || !strlen(errstr)) errstr = othererror;
+	return errstr;
+}
+
+static const struct mach_header *
+lt_int_dyld_get_mach_header_from_nsmodule(module)
+	NSModule module;
+{
+/* There should probably be an apple dyld api for this */
+	int i=_dyld_image_count();
+	int j;
+	const char *modname=NSNameOfModule(module);
+	const struct mach_header *mh=NULL;
+	if (!modname) return NULL;
+	for (j = 0; j < i; j++)
+	{
+		if (!strcmp(_dyld_get_image_name(j),modname))
+		{
+			mh=_dyld_get_image_header(j);
+			break;
+		}
+	}
+	return mh;
+}
+
+static const char* lt_int_dyld_lib_install_name(mh)
+	const struct mach_header *mh;
+{
+/* NSAddImage is also used to get the loaded image, but it only works if the lib
+   is installed, for uninstalled libs we need to check the install_names against
+   each other. Note that this is still broken if DYLD_IMAGE_SUFFIX is set and a
+   different lib was loaded as a result
+*/
+	int j;
+	struct load_command *lc;
+	unsigned long offset = sizeof(struct mach_header);
+	const char* retStr=NULL;
+	for (j = 0; j < mh->ncmds; j++)
+	{
+		lc = (struct load_command*)(((unsigned long)mh) + offset);
+		if (LC_ID_DYLIB == lc->cmd)
+		{
+			retStr=(char*)(((struct dylib_command*)lc)->dylib.name.offset +
+									(unsigned long)lc);
+		}
+		offset += lc->cmdsize;
+	}
+	return retStr;
+}
+
+static const struct mach_header *
+lt_int_dyld_match_loaded_lib_by_install_name(const char *name)
+{
+	int i=_dyld_image_count();
+	int j;
+	const struct mach_header *mh=NULL;
+	const char *id=NULL;
+	for (j = 0; j < i; j++)
+	{
+		id=lt_int_dyld_lib_install_name(_dyld_get_image_header(j));
+		if ((id) && (!strcmp(id,name)))
+		{
+			mh=_dyld_get_image_header(j);
+			break;
+		}
+	}
+	return mh;
+}
 
-/* dynamic linking with dld */
+static NSSymbol
+lt_int_dyld_NSlookupSymbolInLinkedLibs(symbol,mh)
+	const char *symbol;
+	const struct mach_header *mh;
+{
+	/* Safe to assume our mh is good */
+	int j;
+	struct load_command *lc;
+	unsigned long offset = sizeof(struct mach_header);
+	NSSymbol retSym = 0;
+	const struct mach_header *mh1;
+	if ((ltdl_NSLookupSymbolInImage) && NSIsSymbolNameDefined(symbol) )
+	{
+		for (j = 0; j < mh->ncmds; j++)
+		{
+			lc = (struct load_command*)(((unsigned long)mh) + offset);
+			if ((LC_LOAD_DYLIB == lc->cmd) || (LC_LOAD_WEAK_DYLIB == lc->cmd))
+			{
+				mh1=lt_int_dyld_match_loaded_lib_by_install_name((char*)(((struct dylib_command*)lc)->dylib.name.offset +
+										(unsigned long)lc));
+				if (!mh1)
+				{
+					/* Maybe NSAddImage can find it */
+					mh1=ltdl_NSAddImage((char*)(((struct dylib_command*)lc)->dylib.name.offset +
+										(unsigned long)lc),
+										NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED +
+										NSADDIMAGE_OPTION_WITH_SEARCHING +
+										NSADDIMAGE_OPTION_RETURN_ON_ERROR );
+				}
+				if (mh1)
+				{
+					retSym = ltdl_NSLookupSymbolInImage(mh1,
+											symbol,
+											NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW
+											| NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR
+											);
+					if (retSym) break;
+				}
+			}
+			offset += lc->cmdsize;
+		}
+	}
+	return retSym;
+}
 
-#if HAVE_DLD_H
-#include <dld.h>
-#endif
+static int
+sys_dyld_init()
+{
+	int retCode = 0;
+	int err = 0;
+	if (!_dyld_present()) {
+		retCode=1;
+	}
+	else {
+      err = _dyld_func_lookup("__dyld_NSAddImage",(unsigned long*)&ltdl_NSAddImage);
+      err = _dyld_func_lookup("__dyld_NSLookupSymbolInImage",(unsigned long*)&ltdl_NSLookupSymbolInImage);
+      err = _dyld_func_lookup("__dyld_NSIsSymbolNameDefinedInImage",(unsigned long*)&ltdl_NSIsSymbolNameDefinedInImage);
+      err = _dyld_func_lookup("__dyld_NSMakePrivateModulePublic",(unsigned long*)&ltdl_NSMakePrivateModulePublic);
+    }
+ return retCode;
+}
 
 static lt_module
-sys_dld_open (loader_data, filename)
+sys_dyld_open (loader_data, filename)
      lt_user_data loader_data;
      const char *filename;
 {
-  lt_module module = strdup (filename);
-
-  if (!module)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-      module = 0;
-    }
-  else if (dld_link (filename) != 0)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
-      LT_DLFREE (module);
-      module = 0;
-    }
-
+	lt_module   module   = 0;
+	NSObjectFileImage ofi = 0;
+	NSObjectFileImageReturnCode ofirc;
+
+  	if (!filename)
+  		return (lt_module)-1;
+	ofirc = NSCreateObjectFileImageFromFile(filename, &ofi);
+	switch (ofirc)
+	{
+		case NSObjectFileImageSuccess:
+			module = NSLinkModule(ofi, filename,
+						NSLINKMODULE_OPTION_RETURN_ON_ERROR
+						 | NSLINKMODULE_OPTION_PRIVATE
+						 | NSLINKMODULE_OPTION_BINDNOW);
+			NSDestroyObjectFileImage(ofi);
+			if (module)
+				ltdl_NSMakePrivateModulePublic(module);
+			break;
+		case NSObjectFileImageInappropriateFile:
+		    if (ltdl_NSIsSymbolNameDefinedInImage && ltdl_NSLookupSymbolInImage)
+		    {
+				module = (lt_module)ltdl_NSAddImage(filename, NSADDIMAGE_OPTION_RETURN_ON_ERROR);
+				break;
+			}
+		default:
+			LT_DLMUTEX_SETERROR (lt_int_dyld_error(LT_DLSTRERROR(CANNOT_OPEN)));
+			return 0;
+	}
+	if (!module) LT_DLMUTEX_SETERROR (lt_int_dyld_error(LT_DLSTRERROR(CANNOT_OPEN)));
   return module;
 }
 
 static int
-sys_dld_close (loader_data, module)
+sys_dyld_close (loader_data, module)
      lt_user_data loader_data;
      lt_module module;
 {
-  int errors = 0;
-
-  if (dld_unlink_by_file ((char*)(module), 1) != 0)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (CANNOT_CLOSE));
-      ++errors;
-    }
-  else
-    {
-      LT_DLFREE (module);
-    }
+	int retCode = 0;
+	int flags = 0;
+	if (module == (lt_module)-1) return 0;
+#ifdef __BIG_ENDIAN__
+  	if (((struct mach_header *)module)->magic == MH_MAGIC)
+#else
+    if (((struct mach_header *)module)->magic == MH_CIGAM)
+#endif
+	{
+	  LT_DLMUTEX_SETERROR("Can not close a dylib");
+	  retCode = 1;
+	}
+	else
+	{
+#if 1
+/* Currently, if a module contains c++ static destructors and it is unloaded, we
+   get a segfault in atexit(), due to compiler and dynamic loader differences of
+   opinion, this works around that.
+*/
+		if ((const struct section *)NULL !=
+		   getsectbynamefromheader(lt_int_dyld_get_mach_header_from_nsmodule(module),
+		   "__DATA","__mod_term_func"))
+		{
+			flags += NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED;
+		}
+#endif
+#ifdef __ppc__
+			flags += NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES;
+#endif
+		if (!NSUnLinkModule(module,flags))
+		{
+			retCode=1;
+			LT_DLMUTEX_SETERROR (lt_int_dyld_error(LT_DLSTRERROR(CANNOT_CLOSE)));
+		}
+	}
 
-  return errors;
+ return retCode;
 }
 
 static lt_ptr
-sys_dld_sym (loader_data, module, symbol)
+sys_dyld_sym (loader_data, module, symbol)
      lt_user_data loader_data;
      lt_module module;
      const char *symbol;
 {
-  lt_ptr address = dld_get_func (symbol);
-
-  if (!address)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
-    }
+	lt_ptr address = 0;
+  	NSSymbol *nssym = 0;
+  	void *unused;
+  	const struct mach_header *mh=NULL;
+  	char saveError[256] = "Symbol not found";
+  	if (module == (lt_module)-1)
+  	{
+  		_dyld_lookup_and_bind(symbol,(unsigned long*)&address,&unused);
+  		return address;
+  	}
+#ifdef __BIG_ENDIAN__
+  	if (((struct mach_header *)module)->magic == MH_MAGIC)
+#else
+    if (((struct mach_header *)module)->magic == MH_CIGAM)
+#endif
+  	{
+  	    if (ltdl_NSIsSymbolNameDefinedInImage && ltdl_NSLookupSymbolInImage)
+  	    {
+  	    	mh=module;
+			if (ltdl_NSIsSymbolNameDefinedInImage((struct mach_header*)module,symbol))
+			{
+				nssym = ltdl_NSLookupSymbolInImage((struct mach_header*)module,
+											symbol,
+											NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW
+											| NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR
+											);
+			}
+	    }
 
-  return address;
+  	}
+  else {
+	nssym = NSLookupSymbolInModule(module, symbol);
+	}
+	if (!nssym)
+	{
+		strncpy(saveError, lt_int_dyld_error(LT_DLSTRERROR(SYMBOL_NOT_FOUND)), 255);
+		saveError[255] = 0;
+		if (!mh) mh=lt_int_dyld_get_mach_header_from_nsmodule(module);
+		nssym = lt_int_dyld_NSlookupSymbolInLinkedLibs(symbol,mh);
+	}
+	if (!nssym)
+	{
+		LT_DLMUTEX_SETERROR (saveError);
+		return NULL;
+	}
+	return NSAddressOfSymbol(nssym);
 }
 
-static struct lt_user_dlloader sys_dld = {
-  0, sys_dld_open, sys_dld_close, sys_dld_sym, 0, 0
-};
-
-#endif /* HAVE_DLD */
+static struct lt_user_dlloader sys_dyld =
+  { "_", sys_dyld_open, sys_dyld_close, sys_dyld_sym, 0, 0 };
 
 
+#endif /* HAVE_DYLD */
 
 
 /* --- DLPREOPEN() INTERFACE LOADER --- */
@@ -1109,7 +1941,7 @@
 {
   int errors = 0;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
 
   preloaded_symbols = 0;
   if (default_preloaded_symbols)
@@ -1117,7 +1949,7 @@
       errors = lt_dlpreload (default_preloaded_symbols);
     }
 
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return errors;
 }
@@ -1127,7 +1959,7 @@
 {
   lt_dlsymlists_t *lists;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
 
   lists = preloaded_symbols;
   while (lists)
@@ -1139,7 +1971,7 @@
     }
   preloaded_symbols = 0;
 
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return 0;
 }
@@ -1160,7 +1992,7 @@
   lt_dlsymlists_t *lists;
   int		   errors   = 0;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
 
   lists = preloaded_symbols;
   while (lists)
@@ -1172,21 +2004,21 @@
       lists = lists->next;
     }
 
-  tmp = LT_DLMALLOC (lt_dlsymlists_t, 1);
+  tmp = LT_EMALLOC (lt_dlsymlists_t, 1);
   if (tmp)
     {
+      memset (tmp, 0, sizeof(lt_dlsymlists_t));
       tmp->syms = preloaded;
       tmp->next = preloaded_symbols;
       preloaded_symbols = tmp;
     }
   else
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
       ++errors;
     }
 
  done:
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
   return errors;
 }
 
@@ -1198,15 +2030,19 @@
   lt_dlsymlists_t *lists;
   lt_module	   module = (lt_module) 0;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   lists = preloaded_symbols;
 
   if (!lists)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (NO_SYMBOLS));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_SYMBOLS));
       goto done;
     }
 
+  /* Can't use NULL as the reflective symbol header, as NULL is
+     used to mark the end of the entire symbol list.  Self-dlpreopened
+     symbols follow this magic number, chosen to be an unlikely
+     clash with a real module name.  */
   if (!filename)
     {
       filename = "@PROGRAM@";
@@ -1229,10 +2065,10 @@
       lists = lists->next;
     }
 
-  MUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
+  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
 
  done:
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
   return module;
 }
 
@@ -1265,7 +2101,7 @@
     ++syms;
   }
 
-  MUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
+  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
 
   return 0;
 }
@@ -1281,6 +2117,70 @@
 /* --- DYNAMIC MODULE LOADING --- */
 
 
+/* The type of a function used at each iteration of  foreach_dirinpath().  */
+typedef int	foreach_callback_func LT_PARAMS((char *filename, lt_ptr data1,
+						 lt_ptr data2));
+
+static	int	foreach_dirinpath     LT_PARAMS((const char *search_path,
+						 const char *base_name,
+						 foreach_callback_func *func,
+						 lt_ptr data1, lt_ptr data2));
+
+static	int	find_file_callback    LT_PARAMS((char *filename, lt_ptr data,
+						 lt_ptr ignored));
+static	int	find_handle_callback  LT_PARAMS((char *filename, lt_ptr data,
+						 lt_ptr ignored));
+static	int	foreachfile_callback  LT_PARAMS((char *filename, lt_ptr data1,
+						 lt_ptr data2));
+
+
+static	int     canonicalize_path     LT_PARAMS((const char *path,
+						 char **pcanonical));
+static	int	argzize_path 	      LT_PARAMS((const char *path,
+						 char **pargz,
+						 size_t *pargz_len));
+static	FILE   *find_file	      LT_PARAMS((const char *search_path,
+						 const char *base_name,
+						 char **pdir));
+static	lt_dlhandle *find_handle      LT_PARAMS((const char *search_path,
+						 const char *base_name,
+						 lt_dlhandle *handle));
+static	int	find_module	      LT_PARAMS((lt_dlhandle *handle,
+						 const char *dir,
+						 const char *libdir,
+						 const char *dlname,
+						 const char *old_name,
+						 int installed));
+static	int	free_vars	      LT_PARAMS((char *dlname, char *oldname,
+						 char *libdir, char *deplibs));
+static	int	load_deplibs	      LT_PARAMS((lt_dlhandle handle,
+						 char *deplibs));
+static	int	trim		      LT_PARAMS((char **dest,
+						 const char *str));
+static	int	try_dlopen	      LT_PARAMS((lt_dlhandle *handle,
+						 const char *filename));
+static	int	tryall_dlopen	      LT_PARAMS((lt_dlhandle *handle,
+						 const char *filename));
+static	int	unload_deplibs	      LT_PARAMS((lt_dlhandle handle));
+static	int	lt_argz_insert	      LT_PARAMS((char **pargz,
+						 size_t *pargz_len,
+						 char *before,
+						 const char *entry));
+static	int	lt_argz_insertinorder LT_PARAMS((char **pargz,
+						 size_t *pargz_len,
+						 const char *entry));
+static	int	lt_argz_insertdir     LT_PARAMS((char **pargz,
+						 size_t *pargz_len,
+						 const char *dirnam,
+						 struct dirent *dp));
+static	int	lt_dlpath_insertdir   LT_PARAMS((char **ppath,
+						 char *before,
+						 const char *dir));
+static	int	list_files_by_dir     LT_PARAMS((const char *dirnam,
+						 char **pargz,
+						 size_t *pargz_len));
+static	int	file_not_found	      LT_PARAMS((void));
+
 static	char	       *user_search_path= 0;
 static	lt_dlloader    *loaders		= 0;
 static	lt_dlhandle	handles 	= 0;
@@ -1292,7 +2192,7 @@
 {
   int	      errors   = 0;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
 
   /* Initialize only at first call. */
   if (++initialized == 1)
@@ -1300,11 +2200,8 @@
       handles = 0;
       user_search_path = 0; /* empty search path */
 
-#if HAVE_LIBDL && !defined(__CYGWIN__)
+#if HAVE_LIBDL
       errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dl, "dlopen");
-#ifdef _AIX
-      sys_dl_init();
-#endif /* _AIX */
 #endif
 #if HAVE_SHL_LOAD
       errors += lt_dlloader_add (lt_dlloader_next (0), &sys_shl, "dlopen");
@@ -1318,21 +2215,25 @@
 #if HAVE_DLD
       errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dld, "dld");
 #endif
+#if HAVE_DYLD
+       errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dyld, "dyld");
+       errors += sys_dyld_init();
+#endif
       errors += lt_dlloader_add (lt_dlloader_next (0), &presym, "dlpreload");
 
       if (presym_init (presym.dlloader_data))
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (INIT_LOADER));
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INIT_LOADER));
 	  ++errors;
 	}
       else if (errors != 0)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (DLOPEN_NOT_SUPPORTED));
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (DLOPEN_NOT_SUPPORTED));
 	  ++errors;
 	}
     }
 
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return errors;
 }
@@ -1349,16 +2250,14 @@
     }
   else
     {
-      const char *errormsg = 0;
-
       presym_free_symlists();
-  
-      MUTEX_LOCK ();
+
+      LT_DLMUTEX_LOCK ();
       if (default_preloaded_symbols)
 	{
 	  errors = lt_dlpreload (default_preloaded_symbols);
 	}
-      MUTEX_UNLOCK ();
+      LT_DLMUTEX_UNLOCK ();
     }
 
   return errors;
@@ -1368,9 +2267,9 @@
 lt_dlpreload_default (preloaded)
      const lt_dlsymlist *preloaded;
 {
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   default_preloaded_symbols = preloaded;
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
   return 0;
 }
 
@@ -1379,15 +2278,14 @@
 {
   /* shut down libltdl */
   lt_dlloader *loader;
-  const char  *errormsg;
   int	       errors   = 0;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   loader = loaders;
 
   if (!initialized)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (SHUTDOWN));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SHUTDOWN));
       ++errors;
       goto done;
     }
@@ -1406,11 +2304,14 @@
       for (level = 1; handles; ++level)
 	{
 	  lt_dlhandle cur = handles;
+	  int saw_nonresident = 0;
 
 	  while (cur)
 	    {
 	      lt_dlhandle tmp = cur;
 	      cur = cur->next;
+	      if (!LT_DLIS_RESIDENT (tmp))
+		saw_nonresident = 1;
 	      if (!LT_DLIS_RESIDENT (tmp) && tmp->info.ref_count <= level)
 		{
 		  if (lt_dlclose (tmp))
@@ -1419,6 +2320,9 @@
 		    }
 		}
 	    }
+	  /* done if only resident modules are left */
+	  if (!saw_nonresident)
+	    break;
 	}
 
       /* close all loaders */
@@ -1437,7 +2341,7 @@
     }
 
  done:
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
   return errors;
 }
 
@@ -1451,8 +2355,8 @@
   const char	*saved_error;
   int		 errors		= 0;
 
-  MUTEX_GETERROR (saved_error);
-  MUTEX_LOCK ();
+  LT_DLMUTEX_GETERROR (saved_error);
+  LT_DLMUTEX_LOCK ();
 
   cur	 = handles;
   loader = loaders;
@@ -1485,18 +2389,27 @@
   cur = *handle;
   if (filename)
     {
-      LT_DLFREE( cur->info.filename );
-      cur->info.filename = strdup (filename);
+      /* Comment out the check of file permissions using access.
+	 This call seems to always return -1 with error EACCES.
+      */
+      /* We need to catch missing file errors early so that
+	 file_not_found() can detect what happened.
+      if (access (filename, R_OK) != 0)
+	{
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
+	  ++errors;
+	  goto done;
+	} */
+
+      cur->info.filename = lt_estrdup (filename);
       if (!cur->info.filename)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
 	  ++errors;
 	  goto done;
 	}
     }
   else
     {
-      LT_DLFREE( cur->info.filename );
       cur->info.filename = 0;
     }
 
@@ -1521,15 +2434,66 @@
     }
 
   cur->loader	= loader;
-  last_error	= saved_error;
-  
+  LT_DLMUTEX_SETERROR (saved_error);
+
  done:
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return errors;
 }
 
 static int
+tryall_dlopen_module (handle, prefix, dirname, dlname)
+     lt_dlhandle *handle;
+     const char *prefix;
+     const char *dirname;
+     const char *dlname;
+{
+  int      error	= 0;
+  char     *filename	= 0;
+  size_t   filename_len	= 0;
+  size_t   dirname_len	= LT_STRLEN (dirname);
+
+  assert (handle);
+  assert (dirname);
+  assert (dlname);
+#ifdef LT_DIRSEP_CHAR
+  /* Only canonicalized names (i.e. with DIRSEP chars already converted)
+     should make it into this function:  */
+  assert (strchr (dirname, LT_DIRSEP_CHAR) == 0);
+#endif
+
+  if (dirname_len > 0)
+    if (dirname[dirname_len -1] == '/')
+      --dirname_len;
+  filename_len = dirname_len + 1 + LT_STRLEN (dlname);
+
+  /* Allocate memory, and combine DIRNAME and MODULENAME into it.
+     The PREFIX (if any) is handled below.  */
+  filename  = LT_EMALLOC (char, dirname_len + 1 + filename_len + 1);
+  if (!filename)
+    return 1;
+
+  sprintf (filename, "%.*s/%s", (int) dirname_len, dirname, dlname);
+
+  /* Now that we have combined DIRNAME and MODULENAME, if there is
+     also a PREFIX to contend with, simply recurse with the arguments
+     shuffled.  Otherwise, attempt to open FILENAME as a module.  */
+  if (prefix)
+    {
+      error += tryall_dlopen_module (handle,
+				     (const char *) 0, prefix, filename);
+    }
+  else if (tryall_dlopen (handle, filename) != 0)
+    {
+      ++error;
+    }
+
+  LT_DLFREE (filename);
+  return error;
+}
+
+static int
 find_module (handle, dir, libdir, dlname, old_name, installed)
      lt_dlhandle *handle;
      const char *dir;
@@ -1538,252 +2502,304 @@
      const char *old_name;
      int installed;
 {
-  int	error;
-  char	*filename;
-
-  /* try to open the old library first; if it was dlpreopened,
+  /* Try to open the old library first; if it was dlpreopened,
      we want the preopened version of it, even if a dlopenable
-     module is available */
-  if (old_name && tryall_dlopen(handle, old_name) == 0)
+     module is available.  */
+  if (old_name && tryall_dlopen (handle, old_name) == 0)
     {
       return 0;
     }
 
-  /* try to open the dynamic library */
+  /* Try to open the dynamic library.  */
   if (dlname)
     {
-      size_t len;
-
       /* try to open the installed module */
       if (installed && libdir)
 	{
-	  len	    = strlen (libdir) + 1 + strlen (dlname);
-	  filename  = LT_DLMALLOC (char, 1+ len);
-
-	  if (!filename)
-	    {
-	      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	      return 1;
-	    }
-
-	  sprintf (filename, "%s/%s", libdir, dlname);
-	  error = (tryall_dlopen (handle, filename) != 0);
-	  LT_DLFREE (filename);
-
-	  if (!error)
-	    {
-	      return 0;
-	    }
+	  if (tryall_dlopen_module (handle,
+				    (const char *) 0, libdir, dlname) == 0)
+	    return 0;
 	}
 
       /* try to open the not-installed module */
       if (!installed)
 	{
-	  len = (dir ? strlen (dir) : 0) + strlen (objdir) + strlen (dlname);
-	  filename = LT_DLMALLOC (char, 1+ len);
-
-	  if (!filename)
-	    {
-	      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	      return 1;
-	    }
-
-	  if (dir)
-	    {
-	      strcpy (filename, dir);
-	    }
-	  else
-	    {
-	      *filename = 0;
-	    }
-	  strcat(filename, objdir);
-	  strcat(filename, dlname);
-
-	  error = tryall_dlopen (handle, filename) != 0;
-	  LT_DLFREE (filename);
-	  if (!error)
-	    {
-	      return 0;
-	    }
+	  if (tryall_dlopen_module (handle, dir, objdir, dlname) == 0)
+	    return 0;
 	}
 
       /* maybe it was moved to another directory */
       {
-	len	 = (dir ? strlen (dir) : 0) + strlen (dlname);
-	filename = LT_DLMALLOC (char, 1+ len);
+	  if (tryall_dlopen_module (handle,
+				    (const char *) 0, dir, dlname) == 0)
+	    return 0;
+      }
+    }
+
+  return 1;
+}
 
-	if (dir)
+
+static int
+canonicalize_path (path, pcanonical)
+     const char *path;
+     char **pcanonical;
+{
+  char *canonical = 0;
+
+  assert (path && *path);
+  assert (pcanonical);
+
+  canonical = LT_EMALLOC (char, 1+ LT_STRLEN (path));
+  if (!canonical)
+    return 1;
+
+  {
+    size_t dest = 0;
+    size_t src;
+    for (src = 0; path[src] != LT_EOS_CHAR; ++src)
+      {
+	/* Path separators are not copied to the beginning or end of
+	   the destination, or if another separator would follow
+	   immediately.  */
+	if (path[src] == LT_PATHSEP_CHAR)
 	  {
-	    strcpy (filename, dir);
+	    if ((dest == 0)
+		|| (path[1+ src] == LT_PATHSEP_CHAR)
+		|| (path[1+ src] == LT_EOS_CHAR))
+	      continue;
 	  }
-	else
+
+	/* Anything other than a directory separator is copied verbatim.  */
+	if ((path[src] != '/')
+#ifdef LT_DIRSEP_CHAR
+	    && (path[src] != LT_DIRSEP_CHAR)
+#endif
+	    )
 	  {
-	    *filename = 0;
+	    canonical[dest++] = path[src];
 	  }
-	strcat(filename, dlname);
-
-	error = (tryall_dlopen (handle, filename) != 0);
-	LT_DLFREE (filename);
-	if (!error)
+	/* Directory separators are converted and copied only if they are
+	   not at the end of a path -- i.e. before a path separator or
+	   NULL terminator.  */
+	else if ((path[1+ src] != LT_PATHSEP_CHAR)
+		 && (path[1+ src] != LT_EOS_CHAR)
+#ifdef LT_DIRSEP_CHAR
+		 && (path[1+ src] != LT_DIRSEP_CHAR)
+#endif
+		 && (path[1+ src] != '/'))
 	  {
-	    return 0;
+	    canonical[dest++] = '/';
 	  }
       }
-    }
 
-  return 1;
+    /* Add an end-of-string marker at the end.  */
+    canonical[dest] = LT_EOS_CHAR;
+  }
+
+  /* Assign new value.  */
+  *pcanonical = canonical;
+
+  return 0;
 }
 
-static char*
-canonicalize_path (path)
+static int
+argzize_path (path, pargz, pargz_len)
      const char *path;
+     char **pargz;
+     size_t *pargz_len;
 {
-  char *canonical = 0;
+  error_t error;
 
-  if (path && *path)
-    {
-      char *ptr = strdup (path);
-      canonical = ptr;
+  assert (path);
+  assert (pargz);
+  assert (pargz_len);
 
-#ifdef LT_DIRSEP_CHAR
-      /* Avoid this overhead where '/' is the only separator. */
-      while (ptr = strchr (ptr, LT_DIRSEP_CHAR))
+  if ((error = argz_create_sep (path, LT_PATHSEP_CHAR, pargz, pargz_len)))
+    {
+      switch (error)
 	{
-	  *ptr++ = '/';
+	case ENOMEM:
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
+	  break;
+	default:
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (UNKNOWN));
+	  break;
 	}
-#endif
+
+      return 1;
     }
 
-  return canonical;
+  return 0;
 }
 
-static lt_ptr
-find_file (basename, search_path, pdir, handle)
-     const char *basename;
+/* Repeatedly call FUNC with each LT_PATHSEP_CHAR delimited element
+   of SEARCH_PATH and references to DATA1 and DATA2, until FUNC returns
+   non-zero or all elements are exhausted.  If BASE_NAME is non-NULL,
+   it is appended to each SEARCH_PATH element before FUNC is called.  */
+static int
+foreach_dirinpath (search_path, base_name, func, data1, data2)
      const char *search_path;
-     char **pdir;
-     lt_dlhandle *handle;
-{
-  /* When handle != NULL search a library, otherwise a file
-     return NULL on failure, otherwise the file/handle.  */
+     const char *base_name;
+     foreach_callback_func *func;
+     lt_ptr data1;
+     lt_ptr data2;
+{
+  int	 result		= 0;
+  int	 filenamesize	= 0;
+  size_t lenbase	= LT_STRLEN (base_name);
+  size_t argz_len	= 0;
+  char *argz		= 0;
+  char *filename	= 0;
+  char *canonical	= 0;
 
-  lt_ptr    result	= 0;
-  char	   *filename	= 0;
-  int	    filenamesize= 0;
-  int	    lenbase	= strlen (basename);
-  char	   *canonical	= 0;
-  char	   *next	= 0;
-
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
 
   if (!search_path || !*search_path)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
       goto cleanup;
     }
 
-  canonical = canonicalize_path (search_path);
-  if (!canonical)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-      goto cleanup;
-    }
+  if (canonicalize_path (search_path, &canonical) != 0)
+    goto cleanup;
 
-  next = canonical;
-  while (next)
-    {
-      int lendir;
-      char *cur = next;
+  if (argzize_path (canonical, &argz, &argz_len) != 0)
+    goto cleanup;
 
-      next = strchr (cur, LT_PATHSEP_CHAR);
-      if (!next)
-	{
-	  next = cur + strlen (cur);
-	}
+  {
+    char *dir_name = 0;
+    while ((dir_name = argz_next (argz, argz_len, dir_name)))
+      {
+	size_t lendir = LT_STRLEN (dir_name);
 
-      lendir = next - cur;
-      if (*next == LT_PATHSEP_CHAR)
+	if (lendir +1 +lenbase >= filenamesize)
 	{
-	  ++next;
-	}
-      else
-	{
-	  next = 0;
+	  LT_DLFREE (filename);
+	  filenamesize	= lendir +1 +lenbase +1; /* "/d" + '/' + "f" + '\0' */
+	  filename	= LT_EMALLOC (char, filenamesize);
+	  if (!filename)
+	    goto cleanup;
 	}
 
-      if (lendir == 0)
-	{
-	  continue;
-	}
+	assert (filenamesize > lendir);
+	strcpy (filename, dir_name);
 
-      if (lendir + 1 + lenbase >= filenamesize)
-	{
-	  LT_DLFREE (filename);
-	  filenamesize = lendir + 1 + lenbase + 1;
-	  filename = LT_DLMALLOC (char, filenamesize);
+	if (base_name && *base_name)
+	  {
+	    if (filename[lendir -1] != '/')
+	      filename[lendir++] = '/';
+	    strcpy (filename +lendir, base_name);
+	  }
 
-	  if (!filename)
-	    {
-	      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	      goto cleanup;
-	    }
-	}
+	if ((result = (*func) (filename, data1, data2)))
+	  {
+	    break;
+	  }
+      }
+  }
 
-      strncpy(filename, cur, lendir);
-      if (filename[lendir-1] != '/')
-	{
-	  filename[lendir++] = '/';
-	}
-      strcpy(filename+lendir, basename);
-      if (handle)
-	{
-	  if (tryall_dlopen (handle, filename) == 0)
-	    {
-	      result = (lt_ptr) handle;
-	      goto cleanup;
-	    }
-	}
-      else
-	{
-	  FILE *file = fopen (filename, LT_READTEXT_MODE);
-	  if (file)
-	    {
-	      LT_DLFREE (*pdir);
+ cleanup:
+  LT_DLFREE (argz);
+  LT_DLFREE (canonical);
+  LT_DLFREE (filename);
 
-	      filename[lendir] = '\0';
-	      *pdir = strdup(filename);
-	      if (!*pdir)
-		{
-		  /* We could have even avoided the strdup,
-		     but there would be some memory overhead. */
-		  *pdir = filename;
-		  filename = 0;
-		}
+  LT_DLMUTEX_UNLOCK ();
+
+  return result;
+}
+
+/* If FILEPATH can be opened, store the name of the directory component
+   in DATA1, and the opened FILE* structure address in DATA2.  Otherwise
+   DATA1 is unchanged, but DATA2 is set to a pointer to NULL.  */
+static int
+find_file_callback (filename, data1, data2)
+     char *filename;
+     lt_ptr data1;
+     lt_ptr data2;
+{
+  char	     **pdir	= (char **) data1;
+  FILE	     **pfile	= (FILE **) data2;
+  int	     is_done	= 0;
+
+  assert (filename && *filename);
+  assert (pdir);
+  assert (pfile);
+
+  if ((*pfile = fopen (filename, LT_READTEXT_MODE)))
+    {
+      char *dirend = strrchr (filename, '/');
+
+      if (dirend > filename)
+	*dirend   = LT_EOS_CHAR;
+
+      LT_DLFREE (*pdir);
+      *pdir   = lt_estrdup (filename);
+      is_done = (*pdir == 0) ? -1 : 1;
+    }
+
+  return is_done;
+}
+
+static FILE *
+find_file (search_path, base_name, pdir)
+     const char *search_path;
+     const char *base_name;
+     char **pdir;
+{
+  FILE *file = 0;
+
+  foreach_dirinpath (search_path, base_name, find_file_callback, pdir, &file);
+
+  return file;
+}
+
+static int
+find_handle_callback (filename, data, ignored)
+     char *filename;
+     lt_ptr data;
+     lt_ptr ignored;
+{
+  lt_dlhandle  *handle		= (lt_dlhandle *) data;
+  int		notfound	= access (filename, R_OK);
+
+  /* Bail out if file cannot be read...  */
+  if (notfound)
+    return 0;
 
-	      result = (lt_ptr) file;
-	      goto cleanup;
-	    }
-	}
-    }
+  /* Try to dlopen the file, but do not continue searching in any
+     case.  */
+  if (tryall_dlopen (handle, filename) != 0)
+    *handle = 0;
 
-  MUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
+  return 1;
+}
 
- cleanup:
-  LT_DLFREE (filename);
-  LT_DLFREE (canonical);
+/* If HANDLE was found return it, otherwise return 0.  If HANDLE was
+   found but could not be opened, *HANDLE will be set to 0.  */
+static lt_dlhandle *
+find_handle (search_path, base_name, handle)
+     const char *search_path;
+     const char *base_name;
+     lt_dlhandle *handle;
+{
+  if (!search_path)
+    return 0;
 
-  MUTEX_UNLOCK ();
+  if (!foreach_dirinpath (search_path, base_name, find_handle_callback,
+			  handle, 0))
+    return 0;
 
-  return result;
+  return handle;
 }
 
 static int
-load_deplibs(handle, deplibs)
+load_deplibs (handle, deplibs)
      lt_dlhandle handle;
      char *deplibs;
 {
 #if LTDL_DLOPEN_DEPLIBS
-  char	*p, *save_search_path;
+  char	*p, *save_search_path = 0;
   int   depcount = 0;
   int	i;
   char	**names = 0;
@@ -1799,12 +2815,12 @@
     }
   ++errors;
 
-  MUTEX_LOCK ();
-  save_search_path = strdup (user_search_path);
-  if (user_search_path && !save_search_path)
+  LT_DLMUTEX_LOCK ();
+  if (user_search_path)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-      goto cleanup;
+      save_search_path = lt_estrdup (user_search_path);
+      if (!save_search_path)
+	goto cleanup;
     }
 
   /* extract search paths and count deplibs */
@@ -1846,7 +2862,7 @@
   LT_DLFREE (user_search_path);
   user_search_path = save_search_path;
 
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   if (!depcount)
     {
@@ -1854,11 +2870,9 @@
       goto cleanup;
     }
 
-  names = LT_DLMALLOC (char *, depcount * sizeof (char*));
+  names = LT_EMALLOC (char *, depcount * sizeof (char*));
   if (!names)
-    {
-      goto cleanup;
-    }
+    goto cleanup;
 
   /* now only extract the actual deplibs */
   depcount = 0;
@@ -1884,25 +2898,18 @@
 	      *end = 0; /* set a temporary string terminator */
 	      if (strncmp(p, "-l", 2) == 0)
 		{
-		  name = LT_DLMALLOC (char, 3+ /* "lib" */ strlen (p+2) + 1);
+		  size_t name_len = 3+ /* "lib" */ LT_STRLEN (p + 2);
+		  name = LT_EMALLOC (char, 1+ name_len);
 		  if (name)
-		    {
-		      sprintf (name, "lib%s", p+2);
-		    }
+		    sprintf (name, "lib%s", p+2);
 		}
 	      else
-		{
-		  name = strdup(p);
-		}
+		name = lt_estrdup(p);
 
-	      if (name)
-		{
-		  names[depcount++] = name;
-		}
-	      else
-		{
-		  goto cleanup_names;
-		}
+	      if (!name)
+		goto cleanup_names;
+
+	      names[depcount++] = name;
 	      *end = save;
 	    }
 	  p = end;
@@ -1918,11 +2925,9 @@
     {
       int	j = 0;
 
-      handle->deplibs = (lt_dlhandle*) LT_DLMALLOC (lt_dlhandle *, depcount);
+      handle->deplibs = (lt_dlhandle*) LT_EMALLOC (lt_dlhandle *, depcount);
       if (!handle->deplibs)
-	    {
-	  goto cleanup;
-	    }
+	goto cleanup;
 
       for (i = 0; i < depcount; ++i)
 	{
@@ -1951,7 +2956,7 @@
 }
 
 static int
-unload_deplibs(handle)
+unload_deplibs (handle)
      lt_dlhandle handle;
 {
   int i;
@@ -1971,7 +2976,7 @@
   return errors;
 }
 
-static inline int
+static int
 trim (dest, str)
      char **dest;
      const char *str;
@@ -1979,22 +2984,19 @@
   /* remove the leading and trailing "'" from str
      and store the result in dest */
   const char *end   = strrchr (str, '\'');
-  int	len	    = strlen  (str);
+  size_t len	    = LT_STRLEN (str);
   char *tmp;
 
   LT_DLFREE (*dest);
 
   if (len > 3 && str[0] == '\'')
     {
-      tmp = LT_DLMALLOC (char, end - str);
+      tmp = LT_EMALLOC (char, end - str);
       if (!tmp)
-	{
-	  last_error = LT_DLSTRERROR (NO_MEMORY);
-	  return 1;
-	}
+	return 1;
 
       strncpy(tmp, &str[1], (end - str) - 1);
-      tmp[len-3] = '\0';
+      tmp[len-3] = LT_EOS_CHAR;
       *dest = tmp;
     }
   else
@@ -2005,8 +3007,8 @@
   return 0;
 }
 
-static inline int
-free_vars( dlname, oldname, libdir, deplibs)
+static int
+free_vars (dlname, oldname, libdir, deplibs)
      char *dlname;
      char *oldname;
      char *libdir;
@@ -2020,87 +3022,93 @@
   return 0;
 }
 
-lt_dlhandle
-lt_dlopen (filename)
+static int
+try_dlopen (phandle, filename)
+     lt_dlhandle *phandle;
      const char *filename;
 {
-  lt_dlhandle handle = 0, newhandle;
-  const char *ext;
-  const char *saved_error;
-  char	*canonical = 0, *basename = 0, *dir = 0, *name = 0;
+  const char *	ext		= 0;
+  const char *	saved_error	= 0;
+  char *	canonical	= 0;
+  char *	base_name	= 0;
+  char *	dir		= 0;
+  char *	name		= 0;
+  int		errors		= 0;
+  lt_dlhandle	newhandle;
+
+  assert (phandle);
+  assert (*phandle == 0);
 
-  MUTEX_GETERROR (saved_error);
+  LT_DLMUTEX_GETERROR (saved_error);
 
   /* dlopen self? */
   if (!filename)
     {
-      handle = (lt_dlhandle) LT_DLMALLOC (struct lt_dlhandle_struct, 1);
-      if (!handle)
-	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	  return 0;
-	}
-      memset( handle, 0, sizeof( struct lt_dlhandle_struct ) );
+      *phandle = (lt_dlhandle) LT_EMALLOC (struct lt_dlhandle_struct, 1);
+      if (*phandle == 0)
+	return 1;
 
-      handle->info.ref_count	= 0;
-      handle->depcount		= 0;
-      handle->deplibs		= 0;
-      handle->caller_data	= 0;
-      newhandle			= handle;
+      memset (*phandle, 0, sizeof(struct lt_dlhandle_struct));
+      newhandle	= *phandle;
 
       /* lt_dlclose()ing yourself is very bad!  Disallow it.  */
-      LT_DLSET_FLAG (handle, LT_DLRESIDENT_FLAG);
+      LT_DLSET_FLAG (*phandle, LT_DLRESIDENT_FLAG);
 
       if (tryall_dlopen (&newhandle, 0) != 0)
 	{
-	  LT_DLFREE (handle);
-	  return 0;
+	  LT_DLFREE (*phandle);
+	  return 1;
 	}
+
       goto register_handle;
     }
 
-  canonical = canonicalize_path (filename);
-  if (!canonical)
+  assert (filename && *filename);
+
+  /* Doing this immediately allows internal functions to safely
+     assume only canonicalized paths are passed.  */
+  if (canonicalize_path (filename, &canonical) != 0)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-      LT_DLFREE (handle);
-      return 0;
+      ++errors;
+      goto cleanup;
     }
 
   /* If the canonical module name is a path (relative or absolute)
      then split it into a directory part and a name part.  */
-  basename = strrchr (canonical, '/');
-  if (basename)
+  base_name = strrchr (canonical, '/');
+  if (base_name)
     {
-      ++basename;
-      dir = LT_DLMALLOC (char, basename - canonical + 1);
+      size_t dirlen = (1+ base_name) - canonical;
+
+      dir = LT_EMALLOC (char, 1+ dirlen);
       if (!dir)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	  handle = 0;
+	  ++errors;
 	  goto cleanup;
 	}
 
-      strncpy (dir, canonical, basename - canonical);
-      dir[basename - canonical] = '\0';
+      strncpy (dir, canonical, dirlen);
+      dir[dirlen] = LT_EOS_CHAR;
+
+      ++base_name;
     }
   else
-    {
-      basename = canonical;
-    }
+    LT_DLMEM_REASSIGN (base_name, canonical);
+
+  assert (base_name && *base_name);
 
   /* Check whether we are opening a libtool module (.la extension).  */
-  ext = strrchr(basename, '.');
-  if (ext && strcmp(ext, ".la") == 0)
+  ext = strrchr (base_name, '.');
+  if (ext && strcmp (ext, archive_ext) == 0)
     {
       /* this seems to be a libtool module */
-      FILE     *file = 0;
-      int	i;
-      char     *dlname = 0, *old_name = 0;
-      char     *libdir = 0, *deplibs = 0;
-      char     *line;
+      FILE *	file	 = 0;
+      char *	dlname	 = 0;
+      char *	old_name = 0;
+      char *	libdir	 = 0;
+      char *	deplibs	 = 0;
+      char *    line	 = 0;
       size_t	line_len;
-      int	error = 0;
 
       /* if we can't find the installed flag, it is probably an
 	 installed libtool archive, produced with an old version
@@ -2108,403 +3116,644 @@
       int	installed = 1;
 
       /* extract the module name from the file name */
-      name = LT_DLMALLOC (char, ext - basename + 1);
+      name = LT_EMALLOC (char, ext - base_name + 1);
       if (!name)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	  handle = 0;
+	  ++errors;
 	  goto cleanup;
-      }
+	}
 
-    /* canonicalize the module name */
-    for (i = 0; i < ext - basename; ++i)
+      /* canonicalize the module name */
       {
-	if (isalnum ((int)(basename[i])))
-	  {
-	    name[i] = basename[i];
-	  }
-	else
+        size_t i;
+        for (i = 0; i < ext - base_name; ++i)
 	  {
-	    name[i] = '_';
+	    if (isalnum ((int)(base_name[i])))
+	      {
+	        name[i] = base_name[i];
+	      }
+	    else
+	      {
+	        name[i] = '_';
+	      }
 	  }
+        name[ext - base_name] = LT_EOS_CHAR;
       }
 
-    name[ext - basename] = '\0';
+      /* Now try to open the .la file.  If there is no directory name
+         component, try to find it first in user_search_path and then other
+         prescribed paths.  Otherwise (or in any case if the module was not
+         yet found) try opening just the module name as passed.  */
+      if (!dir)
+	{
+	  const char *search_path;
 
-    /* Now try to open the .la file.  If there is no directory name
-       component, try to find it first in user_search_path and then other
-       prescribed paths.  Otherwise (or in any case if the module was not
-       yet found) try opening just the module name as passed.  */
-    if (!dir)
-      {
-	file = (FILE*) find_file(basename, user_search_path, &dir, 0);
-	if (!file)
-	  {
-	    file = (FILE*) find_file(basename, getenv("LTDL_LIBRARY_PATH"),
-				     &dir, 0);
-	  }
+	  LT_DLMUTEX_LOCK ();
+	  search_path = user_search_path;
+	  if (search_path)
+	    file = find_file (user_search_path, base_name, &dir);
+	  LT_DLMUTEX_UNLOCK ();
+
+	  if (!file)
+	    {
+	      search_path = getenv (LTDL_SEARCHPATH_VAR);
+	      if (search_path)
+		file = find_file (search_path, base_name, &dir);
+	    }
 
 #ifdef LTDL_SHLIBPATH_VAR
-	if (!file)
-	  {
-	    file = (FILE*) find_file(basename, getenv(LTDL_SHLIBPATH_VAR),
-				     &dir, 0);
-	  }
+	  if (!file)
+	    {
+	      search_path = getenv (LTDL_SHLIBPATH_VAR);
+	      if (search_path)
+		file = find_file (search_path, base_name, &dir);
+	    }
 #endif
 #ifdef LTDL_SYSSEARCHPATH
-	if (!file)
-	  {
-	    file = (FILE*) find_file(basename, sys_search_path, &dir, 0);
-	  }
+	  if (!file && sys_search_path)
+	    {
+	      file = find_file (sys_search_path, base_name, &dir);
+	    }
 #endif
-      }
-    if (!file)
-      {
-	file = fopen (filename, LT_READTEXT_MODE);
-      }
-    if (!file)
-      {
-	MUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
-      }
-
-    if (!file)
-      {
-	handle = 0;
-	goto cleanup;
-      }
+	}
+      if (!file)
+	{
+	  file = fopen (filename, LT_READTEXT_MODE);
+	}
 
-    line_len = LT_FILENAME_MAX;
-    line = LT_DLMALLOC (char, line_len);
-    if (!line)
-      {
-	fclose (file);
-	MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	handle = 0;
-	goto cleanup;
-      }
+      /* If we didn't find the file by now, it really isn't there.  Set
+	 the status flag, and bail out.  */
+      if (!file)
+	{
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
+	  ++errors;
+	  goto cleanup;
+	}
 
-    /* read the .la file */
-    while (!feof(file))
-      {
-	if (!fgets (line, line_len, file))
-	  {
-	    break;
-	  }
+      line_len = LT_FILENAME_MAX;
+      line = LT_EMALLOC (char, line_len);
+      if (!line)
+	{
+	  fclose (file);
+	  ++errors;
+	  goto cleanup;
+	}
 
+      /* read the .la file */
+      while (!feof (file))
+	{
+	  if (!fgets (line, (int) line_len, file))
+	    {
+	      break;
+	    }
 
-	/* Handle the case where we occasionally need to read a line 
-	   that is longer than the initial buffer size.  */
-	while (line[strlen(line) -1] != '\n')
-	  {
-	    line = LT_DLREALLOC (char, line, line_len *2);
-	    if (!fgets (&line[line_len -1], line_len +1, file))
-	      {
-		break;
-	      }
-	    line_len *= 2;
-	  }
+	  /* Handle the case where we occasionally need to read a line
+	     that is longer than the initial buffer size.  */
+	  while ((line[LT_STRLEN(line) -1] != '\n') && (!feof (file)))
+	    {
+	      line = LT_DLREALLOC (char, line, line_len *2);
+	      if (!fgets (&line[line_len -1], (int) line_len +1, file))
+		{
+		  break;
+		}
+	      line_len *= 2;
+	    }
 
-	if (line[0] == '\n' || line[0] == '#')
-	  {
-	    continue;
-	  }
+	  if (line[0] == '\n' || line[0] == '#')
+	    {
+	      continue;
+	    }
 
 #undef  STR_DLNAME
 #define STR_DLNAME	"dlname="
-	if (strncmp (line, STR_DLNAME, sizeof (STR_DLNAME) - 1) == 0)
-	  {
-	    error = trim (&dlname, &line[sizeof (STR_DLNAME) - 1]);
-	  }
+	  if (strncmp (line, STR_DLNAME, sizeof (STR_DLNAME) - 1) == 0)
+	    {
+	      errors += trim (&dlname, &line[sizeof (STR_DLNAME) - 1]);
+	    }
 
 #undef  STR_OLD_LIBRARY
 #define STR_OLD_LIBRARY	"old_library="
-	else if (strncmp (line, STR_OLD_LIBRARY,
-			  sizeof (STR_OLD_LIBRARY) - 1) == 0)
-	  {
-	    error = trim (&old_name, &line[sizeof (STR_OLD_LIBRARY) - 1]);
-	  }
+	  else if (strncmp (line, STR_OLD_LIBRARY,
+			    sizeof (STR_OLD_LIBRARY) - 1) == 0)
+	    {
+	      errors += trim (&old_name, &line[sizeof (STR_OLD_LIBRARY) - 1]);
+	    }
 #undef  STR_LIBDIR
 #define STR_LIBDIR	"libdir="
-	else if (strncmp (line, STR_LIBDIR, sizeof (STR_LIBDIR) - 1) == 0)
-	  {
-	    error = trim (&libdir, &line[sizeof(STR_LIBDIR) - 1]);
-	  }
+	  else if (strncmp (line, STR_LIBDIR, sizeof (STR_LIBDIR) - 1) == 0)
+	    {
+	      errors += trim (&libdir, &line[sizeof(STR_LIBDIR) - 1]);
+	    }
 
 #undef  STR_DL_DEPLIBS
 #define STR_DL_DEPLIBS	"dependency_libs="
-	else if (strncmp (line, STR_DL_DEPLIBS,
-			  sizeof (STR_DL_DEPLIBS) - 1) == 0)
-	  {
-	    error = trim (&deplibs, &line[sizeof (STR_DL_DEPLIBS) - 1]);
-	  }
-	else if (strcmp (line, "installed=yes\n") == 0)
-	  {
-	    installed = 1;
-	  }
-	else if (strcmp (line, "installed=no\n") == 0)
-	  {
-	    installed = 0;
-	  }
+	  else if (strncmp (line, STR_DL_DEPLIBS,
+			    sizeof (STR_DL_DEPLIBS) - 1) == 0)
+	    {
+	      errors += trim (&deplibs, &line[sizeof (STR_DL_DEPLIBS) - 1]);
+	    }
+	  else if (strcmp (line, "installed=yes\n") == 0)
+	    {
+	      installed = 1;
+	    }
+	  else if (strcmp (line, "installed=no\n") == 0)
+	    {
+	      installed = 0;
+	    }
 
 #undef  STR_LIBRARY_NAMES
 #define STR_LIBRARY_NAMES "library_names="
-	else if (! dlname && strncmp (line, STR_LIBRARY_NAMES,
-				      sizeof (STR_LIBRARY_NAMES) - 1) == 0)
-	  {
-	    char *last_libname;
-	    error = trim (&dlname, &line[sizeof (STR_LIBRARY_NAMES) - 1]);
-	    if (! error && dlname &&
-		(last_libname = strrchr (dlname, ' ')) != NULL)
-	      {
-		last_libname = strdup (last_libname + 1);
-		LT_DLMEM_REASSIGN (dlname, last_libname);
-	      }
-	  }
+	  else if (! dlname && strncmp (line, STR_LIBRARY_NAMES,
+					sizeof (STR_LIBRARY_NAMES) - 1) == 0)
+	    {
+	      char *last_libname;
+	      errors += trim (&dlname, &line[sizeof (STR_LIBRARY_NAMES) - 1]);
+	      if (!errors
+		  && dlname
+		  && (last_libname = strrchr (dlname, ' ')) != 0)
+		{
+		  last_libname = lt_estrdup (last_libname + 1);
+		  if (!last_libname)
+		    {
+		      ++errors;
+		      goto cleanup;
+		    }
+		  LT_DLMEM_REASSIGN (dlname, last_libname);
+		}
+	    }
 
-	if (error)
-	  {
+	  if (errors)
 	    break;
-	  }
-      }
+	}
 
-    fclose (file);
-    LT_DLFREE (line);
+      fclose (file);
+      LT_DLFREE (line);
 
-    /* allocate the handle */
-    handle = (lt_dlhandle) LT_DLMALLOC (struct lt_dlhandle_struct, 1);
-    if (!handle || error)
-      {
-        LT_DLFREE (handle);
-	if (!error)
-	  {
-	    MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	  }
+      /* allocate the handle */
+      *phandle = (lt_dlhandle) LT_EMALLOC (struct lt_dlhandle_struct, 1);
+      if (*phandle == 0)
+	++errors;
 
-	free_vars (dlname, old_name, libdir, deplibs);
-	/* handle is already set to 0 */
-	goto cleanup;
-      }
-    memset( handle, 0, sizeof( struct lt_dlhandle_struct ) );
+      if (errors)
+	{
+	  free_vars (dlname, old_name, libdir, deplibs);
+	  LT_DLFREE (*phandle);
+	  goto cleanup;
+	}
 
-    handle->info.ref_count = 0;
-    if (load_deplibs (handle, deplibs) == 0)
-      {
-	newhandle = handle;
-	/* find_module may replace newhandle */
-	if (find_module (&newhandle, dir, libdir, dlname, old_name, installed))
-	  {
-	    unload_deplibs (handle);
-	    error = 1;
-	  }
-      }
-    else
-      {
-	error = 1;
-      }
+      assert (*phandle);
 
-    free_vars (dlname, old_name, libdir, deplibs);
-    if (error)
-      {
-	LT_DLFREE (handle);
-	goto cleanup;
-      }
+      memset (*phandle, 0, sizeof(struct lt_dlhandle_struct));
+      if (load_deplibs (*phandle, deplibs) == 0)
+	{
+	  newhandle = *phandle;
+	  /* find_module may replace newhandle */
+	  if (find_module (&newhandle, dir, libdir, dlname, old_name, installed))
+	    {
+	      unload_deplibs (*phandle);
+	      ++errors;
+	    }
+	}
+      else
+	{
+	  ++errors;
+	}
 
-    if (handle != newhandle)
-      {
-	unload_deplibs (handle);
-      } else {
-	LT_DLFREE( handle->info.filename );
-	handle->info.filename = strdup( filename );
-      }
+      free_vars (dlname, old_name, libdir, deplibs);
+      if (errors)
+	{
+	  LT_DLFREE (*phandle);
+	  goto cleanup;
+	}
+
+      if (*phandle != newhandle)
+	{
+	  unload_deplibs (*phandle);
+	}
     }
   else
     {
       /* not a libtool module */
-      handle = (lt_dlhandle) LT_DLMALLOC (struct lt_dlhandle_struct, 1);
-      if (!handle)
+      *phandle = (lt_dlhandle) LT_EMALLOC (struct lt_dlhandle_struct, 1);
+      if (*phandle == 0)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	  /* handle is already set to 0 */
+	  ++errors;
 	  goto cleanup;
 	}
-      memset( handle, 0, sizeof( struct lt_dlhandle_struct ) );
-      handle->info.ref_count = 0;
-      /* non-libtool modules don't have dependencies */
-      handle->depcount    = 0;
-      handle->deplibs	  = 0;
-      newhandle	    	  = handle;
+
+      memset (*phandle, 0, sizeof (struct lt_dlhandle_struct));
+      newhandle = *phandle;
 
       /* If the module has no directory name component, try to find it
 	 first in user_search_path and then other prescribed paths.
 	 Otherwise (or in any case if the module was not yet found) try
 	 opening just the module name as passed.  */
-      if ((dir || (!find_file (basename, user_search_path, 0, &newhandle)
-		      && !find_file (basename, getenv ("LTDL_LIBRARY_PATH"),
-				     0, &newhandle)
+      if ((dir || (!find_handle (user_search_path, base_name, &newhandle)
+		   && !find_handle (getenv (LTDL_SEARCHPATH_VAR), base_name,
+				    &newhandle)
 #ifdef LTDL_SHLIBPATH_VAR
-		      && !find_file (basename, getenv (LTDL_SHLIBPATH_VAR),
-				     0, &newhandle)
+		   && !find_handle (getenv (LTDL_SHLIBPATH_VAR), base_name,
+				    &newhandle)
 #endif
 #ifdef LTDL_SYSSEARCHPATH
-		      && !find_file (basename, sys_search_path, 0, &newhandle)
+		   && !find_handle (sys_search_path, base_name, &newhandle)
 #endif
-		   )) && tryall_dlopen (&newhandle, filename))
+		   )))
 	{
-	  LT_DLFREE (handle);
+          if (tryall_dlopen (&newhandle, filename) != 0)
+            {
+              newhandle = NULL;
+            }
+	}
+
+      if (!newhandle)
+	{
+	  LT_DLFREE (*phandle);
+	  ++errors;
 	  goto cleanup;
 	}
     }
 
  register_handle:
-  LT_DLMEM_REASSIGN (handle, newhandle);
+  LT_DLMEM_REASSIGN (*phandle, newhandle);
 
-  if (handle->info.ref_count == 0)
+  if ((*phandle)->info.ref_count == 0)
     {
-      handle->info.ref_count	= 1;
-      handle->info.name		= name;
-      handle->next		= handles;
+      (*phandle)->info.ref_count	= 1;
+      LT_DLMEM_REASSIGN ((*phandle)->info.name, name);
 
-      MUTEX_LOCK ();
-      handles			= handle;
-      MUTEX_UNLOCK ();
-
-      name = 0;	/* don't free this during `cleanup' */
+      LT_DLMUTEX_LOCK ();
+      (*phandle)->next		= handles;
+      handles			= *phandle;
+      LT_DLMUTEX_UNLOCK ();
     }
 
-  MUTEX_SETERROR (saved_error);
+  LT_DLMUTEX_SETERROR (saved_error);
 
  cleanup:
   LT_DLFREE (dir);
   LT_DLFREE (name);
   LT_DLFREE (canonical);
 
+  return errors;
+}
+
+lt_dlhandle
+lt_dlopen (filename)
+     const char *filename;
+{
+  lt_dlhandle handle = 0;
+
+  /* Just incase we missed a code path in try_dlopen() that reports
+     an error, but forgets to reset handle... */
+  if (try_dlopen (&handle, filename) != 0)
+    return 0;
+
   return handle;
 }
 
+/* If the last error messge store was `FILE_NOT_FOUND', then return
+   non-zero.  */
+static int
+file_not_found ()
+{
+  const char *error = 0;
+
+  LT_DLMUTEX_GETERROR (error);
+  if (error == LT_DLSTRERROR (FILE_NOT_FOUND))
+    return 1;
+
+  return 0;
+}
+
+/* If FILENAME has an ARCHIVE_EXT or SHLIB_EXT extension, try to
+   open the FILENAME as passed.  Otherwise try appending ARCHIVE_EXT,
+   and if a file is still not found try again with SHLIB_EXT appended
+   instead.  */
 lt_dlhandle
 lt_dlopenext (filename)
      const char *filename;
 {
-  lt_dlhandle handle;
-  char	*tmp;
-  int	len;
-  const char *saved_error;
-
-  MUTEX_GETERROR (saved_error);
+  lt_dlhandle	handle		= 0;
+  char *	tmp		= 0;
+  char *	ext		= 0;
+  size_t	len;
+  int		errors		= 0;
 
   if (!filename)
     {
       return lt_dlopen (filename);
     }
 
-  len = strlen (filename);
-  if (!len)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
-      return 0;
-    }
-
-  tmp = LT_DLMALLOC (char, len+4);
-  if (!tmp)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-      return 0;
-    }
-  strcpy (tmp, filename);
+  assert (filename);
 
-#ifdef _AIX
-  tmp[len] = '\0';
+  len = LT_STRLEN (filename);
+  ext = strrchr (filename, '.');
 
-  /* find by info.name in the list */
-  handle = sys_dl_search_by_name( tmp );
-  if (handle)
+  /* If FILENAME already bears a suitable extension, there is no need
+     to try appending additional extensions.  */
+  if (ext && ((strcmp (ext, archive_ext) == 0)
+#ifdef LTDL_SHLIB_EXT
+	      || (strcmp (ext, shlib_ext) == 0)
+#endif
+      ))
     {
-      if( LT_DLGET_FLAG (handle, LT_DLNOTFOUND_FLAG) )
-        {
-          /* don't search libm and libstdc++ over and over again,
-           * they are hardlinked and symbols are exported by the
-           * executable */
-          MUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
-          LT_DLFREE (tmp);
-          return 0;
-        }
-      MUTEX_SETERROR (saved_error);
-      LT_DLFREE (tmp);
-      return handle;
+      return lt_dlopen (filename);
     }
-#endif /* _AIX */
 
-  /* try "filename.la" */
-  strcat (tmp, ".la");
-  handle = lt_dlopen (tmp);
-  if (handle)
-    {
-      MUTEX_SETERROR (saved_error);
-      LT_DLFREE (tmp);
-      return handle;
-    }
+  /* First try appending ARCHIVE_EXT.  */
+  tmp = LT_EMALLOC (char, len + LT_STRLEN (archive_ext) + 1);
+  if (!tmp)
+    return 0;
 
+  strcpy (tmp, filename);
+  strcat (tmp, archive_ext);
+  errors = try_dlopen (&handle, tmp);
 
-#ifdef _AIX
-  tmp[len] = '\0'; /* delete the ".la" again.  */
-  
-  /* versioned shared objects can be in .a's */
-  strcat(tmp, ".a");
-  handle = lt_dlopen (tmp);
-  if (handle)
+  /* If we found FILENAME, stop searching -- whether we were able to
+     load the file as a module or not.  If the file exists but loading
+     failed, it is better to return an error message here than to
+     report FILE_NOT_FOUND when the alternatives (foo.so etc) are not
+     in the module search path.  */
+  if (handle || ((errors > 0) && !file_not_found ()))
     {
-      MUTEX_SETERROR (saved_error);
       LT_DLFREE (tmp);
       return handle;
     }
-#endif /* _AIX */
 
 #ifdef LTDL_SHLIB_EXT
-  /* try "filename.EXT" */
-  if (strlen(shlib_ext) > 3)
+  /* Try appending SHLIB_EXT.   */
+  if (LT_STRLEN (shlib_ext) > LT_STRLEN (archive_ext))
     {
       LT_DLFREE (tmp);
-      tmp = LT_DLMALLOC (char, len + strlen (shlib_ext) + 1);
+      tmp = LT_EMALLOC (char, len + LT_STRLEN (shlib_ext) + 1);
       if (!tmp)
-	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	  return 0;
-	}
+	return 0;
+
       strcpy (tmp, filename);
     }
   else
     {
-      tmp[len] = '\0';
+      tmp[len] = LT_EOS_CHAR;
     }
 
   strcat(tmp, shlib_ext);
-  handle = lt_dlopen (tmp);
-  if (handle)
+  errors = try_dlopen (&handle, tmp);
+
+  /* As before, if the file was found but loading failed, return now
+     with the current error message.  */
+  if (handle || ((errors > 0) && !file_not_found ()))
     {
-      MUTEX_SETERROR (saved_error);
       LT_DLFREE (tmp);
       return handle;
     }
 #endif
 
-  /* try the normal file name */
-  handle = lt_dlopen (filename);
-  if (handle)
+  /* Still here?  Then we really did fail to locate any of the file
+     names we tried.  */
+  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
+  LT_DLFREE (tmp);
+  return 0;
+}
+
+
+static int
+lt_argz_insert (pargz, pargz_len, before, entry)
+     char **pargz;
+     size_t *pargz_len;
+     char *before;
+     const char *entry;
+{
+  error_t error;
+
+  if ((error = argz_insert (pargz, pargz_len, before, entry)))
     {
-      return handle;
+      switch (error)
+	{
+	case ENOMEM:
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
+	  break;
+	default:
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (UNKNOWN));
+	  break;
+	}
+      return 1;
     }
 
-#ifdef _AIX
-  /* put into the can't be found list */
-  tmp[len] = '\0';
-  sys_dl_not_found_entry( tmp );
-#endif /* _AIX */
-
-  MUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
-  LT_DLFREE (tmp);
   return 0;
 }
 
+static int
+lt_argz_insertinorder (pargz, pargz_len, entry)
+     char **pargz;
+     size_t *pargz_len;
+     const char *entry;
+{
+  char *before = 0;
+
+  assert (pargz);
+  assert (pargz_len);
+  assert (entry && *entry);
+
+  if (*pargz)
+    while ((before = argz_next (*pargz, *pargz_len, before)))
+      {
+	int cmp = strcmp (entry, before);
+
+	if (cmp < 0)  break;
+	if (cmp == 0) return 0;	/* No duplicates! */
+      }
+
+  return lt_argz_insert (pargz, pargz_len, before, entry);
+}
+
+static int
+lt_argz_insertdir (pargz, pargz_len, dirnam, dp)
+     char **pargz;
+     size_t *pargz_len;
+     const char *dirnam;
+     struct dirent *dp;
+{
+  char   *buf	    = 0;
+  size_t buf_len    = 0;
+  char   *end	    = 0;
+  size_t end_offset = 0;
+  size_t dir_len    = 0;
+  int    errors	    = 0;
+
+  assert (pargz);
+  assert (pargz_len);
+  assert (dp);
+
+  dir_len = LT_STRLEN (dirnam);
+  end     = dp->d_name + LT_D_NAMLEN(dp);
+
+  /* Ignore version numbers.  */
+  {
+    char *p;
+    for (p = end; p -1 > dp->d_name; --p)
+      if (strchr (".0123456789", p[-1]) == 0)
+	break;
+
+    if (*p == '.')
+      end = p;
+  }
+
+  /* Ignore filename extension.  */
+  {
+    char *p;
+    for (p = end -1; p > dp->d_name; --p)
+      if (*p == '.')
+	{
+	  end = p;
+	  break;
+	}
+  }
+
+  /* Prepend the directory name.  */
+  end_offset	= end - dp->d_name;
+  buf_len	= dir_len + 1+ end_offset;
+  buf		= LT_EMALLOC (char, 1+ buf_len);
+  if (!buf)
+    return ++errors;
+
+  assert (buf);
+
+  strcpy  (buf, dirnam);
+  strcat  (buf, "/");
+  strncat (buf, dp->d_name, end_offset);
+  buf[buf_len] = LT_EOS_CHAR;
+
+  /* Try to insert (in order) into ARGZ/ARGZ_LEN.  */
+  if (lt_argz_insertinorder (pargz, pargz_len, buf) != 0)
+    ++errors;
+
+  LT_DLFREE (buf);
+
+  return errors;
+}
+
+static int
+list_files_by_dir (dirnam, pargz, pargz_len)
+     const char *dirnam;
+     char **pargz;
+     size_t *pargz_len;
+{
+  DIR	*dirp	  = 0;
+  int    errors	  = 0;
+
+  assert (dirnam && *dirnam);
+  assert (pargz);
+  assert (pargz_len);
+  assert (dirnam[LT_STRLEN(dirnam) -1] != '/');
+
+  dirp = opendir (dirnam);
+  if (dirp)
+    {
+      struct dirent *dp	= 0;
+
+      while ((dp = readdir (dirp)))
+	if (dp->d_name[0] != '.')
+	  if (lt_argz_insertdir (pargz, pargz_len, dirnam, dp))
+	    {
+	      ++errors;
+	      break;
+	    }
+
+      closedir (dirp);
+    }
+  else
+    ++errors;
+
+  return errors;
+}
+
+
+/* If there are any files in DIRNAME, call the function passed in
+   DATA1 (with the name of each file and DATA2 as arguments).  */
+static int
+foreachfile_callback (dirname, data1, data2)
+     char *dirname;
+     lt_ptr data1;
+     lt_ptr data2;
+{
+  int (*func) LT_PARAMS((const char *filename, lt_ptr data))
+	= (int (*) LT_PARAMS((const char *filename, lt_ptr data))) data1;
+
+  int	  is_done  = 0;
+  char   *argz     = 0;
+  size_t  argz_len = 0;
+
+  if (list_files_by_dir (dirname, &argz, &argz_len) != 0)
+    goto cleanup;
+  if (!argz)
+    goto cleanup;
+
+  {
+    char *filename = 0;
+    while ((filename = argz_next (argz, argz_len, filename)))
+      if ((is_done = (*func) (filename, data2)))
+	break;
+  }
+
+ cleanup:
+  LT_DLFREE (argz);
+
+  return is_done;
+}
+
+
+/* Call FUNC for each unique extensionless file in SEARCH_PATH, along
+   with DATA.  The filenames passed to FUNC would be suitable for
+   passing to lt_dlopenext.  The extensions are stripped so that
+   individual modules do not generate several entries (e.g. libfoo.la,
+   libfoo.so, libfoo.so.1, libfoo.so.1.0.0).  If SEARCH_PATH is NULL,
+   then the same directories that lt_dlopen would search are examined.  */
+int
+lt_dlforeachfile (search_path, func, data)
+     const char *search_path;
+     int (*func) LT_PARAMS ((const char *filename, lt_ptr data));
+     lt_ptr data;
+{
+  int is_done = 0;
+
+  if (search_path)
+    {
+      /* If a specific path was passed, search only the directories
+	 listed in it.  */
+      is_done = foreach_dirinpath (search_path, 0,
+				   foreachfile_callback, func, data);
+    }
+  else
+    {
+      /* Otherwise search the default paths.  */
+      is_done = foreach_dirinpath (user_search_path, 0,
+				   foreachfile_callback, func, data);
+      if (!is_done)
+	{
+	  is_done = foreach_dirinpath (getenv("LTDL_LIBRARY_PATH"), 0,
+				       foreachfile_callback, func, data);
+	}
+
+#ifdef LTDL_SHLIBPATH_VAR
+      if (!is_done)
+	{
+	  is_done = foreach_dirinpath (getenv(LTDL_SHLIBPATH_VAR), 0,
+				       foreachfile_callback, func, data);
+	}
+#endif
+#ifdef LTDL_SYSSEARCHPATH
+      if (!is_done)
+	{
+	  is_done = foreach_dirinpath (getenv(LTDL_SYSSEARCHPATH), 0,
+				       foreachfile_callback, func, data);
+	}
+#endif
+    }
+
+  return is_done;
+}
+
 int
 lt_dlclose (handle)
      lt_dlhandle handle;
@@ -2512,7 +3761,7 @@
   lt_dlhandle cur, last;
   int errors = 0;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
 
   /* check whether the handle is valid */
   last = cur = handles;
@@ -2524,7 +3773,7 @@
 
   if (!cur)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
       ++errors;
       goto done;
     }
@@ -2551,6 +3800,9 @@
       errors += handle->loader->module_close (data, handle->module);
       errors += unload_deplibs(handle);
 
+      /* It is up to the callers to free the data itself.  */
+      LT_DLFREE (handle->caller_data);
+
       LT_DLFREE (handle->info.filename);
       LT_DLFREE (handle->info.name);
       LT_DLFREE (handle);
@@ -2560,12 +3812,12 @@
 
   if (LT_DLIS_RESIDENT (handle))
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (CLOSE_RESIDENT_MODULE));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CLOSE_RESIDENT_MODULE));
       ++errors;
     }
 
  done:
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return errors;
 }
@@ -2575,7 +3827,7 @@
      lt_dlhandle handle;
      const char *symbol;
 {
-  int	lensym;
+  size_t lensym;
   char	lsym[LT_SYMBOL_LENGTH];
   char	*sym;
   lt_ptr address;
@@ -2583,26 +3835,18 @@
 
   if (!handle)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
       return 0;
     }
 
   if (!symbol)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
       return 0;
     }
 
-  lensym = strlen(symbol);
-  if (handle->loader->sym_prefix)
-    {
-      lensym += strlen(handle->loader->sym_prefix);
-    }
-
-  if (handle->info.name)
-    {
-      lensym += strlen(handle->info.name);
-    }
+  lensym = LT_STRLEN (symbol) + LT_STRLEN (handle->loader->sym_prefix)
+					+ LT_STRLEN (handle->info.name);
 
   if (lensym + LT_SYMBOL_OVERHEAD < LT_SYMBOL_LENGTH)
     {
@@ -2610,13 +3854,12 @@
     }
   else
     {
-      sym = LT_DLMALLOC (char, lensym + LT_SYMBOL_OVERHEAD + 1);
-    }
-
-  if (!sym)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (BUFFER_OVERFLOW));
-      return 0;
+      sym = LT_EMALLOC (char, lensym + LT_SYMBOL_OVERHEAD + 1);
+      if (!sym)
+	{
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (BUFFER_OVERFLOW));
+	  return 0;
+	}
     }
 
   data = handle->loader->dlloader_data;
@@ -2624,7 +3867,7 @@
     {
       const char *saved_error;
 
-      MUTEX_GETERROR (saved_error);
+      LT_DLMUTEX_GETERROR (saved_error);
 
       /* this is a libtool module */
       if (handle->loader->sym_prefix)
@@ -2650,7 +3893,7 @@
 	    }
 	  return address;
 	}
-      MUTEX_SETERROR (saved_error);
+      LT_DLMUTEX_SETERROR (saved_error);
     }
 
   /* otherwise try "symbol" */
@@ -2678,10 +3921,82 @@
 {
   const char *error;
 
-  MUTEX_GETERROR (error);
-  MUTEX_SETERROR (0);
+  LT_DLMUTEX_GETERROR (error);
+  LT_DLMUTEX_SETERROR (0);
 
-  return error;
+  return error ? error : LT_DLSTRERROR (UNKNOWN);
+}
+
+static int
+lt_dlpath_insertdir (ppath, before, dir)
+     char **ppath;
+     char *before;
+     const char *dir;
+{
+  int    errors		= 0;
+  char  *canonical	= 0;
+  char  *argz		= 0;
+  size_t argz_len	= 0;
+
+  assert (ppath);
+  assert (dir && *dir);
+
+  if (canonicalize_path (dir, &canonical) != 0)
+    {
+      ++errors;
+      goto cleanup;
+    }
+
+  assert (canonical && *canonical);
+
+  /* If *PPATH is empty, set it to DIR.  */
+  if (*ppath == 0)
+    {
+      assert (!before);		/* BEFORE cannot be set without PPATH.  */
+      assert (dir);		/* Without DIR, don't call this function!  */
+
+      *ppath = lt_estrdup (dir);
+      if (*ppath == 0)
+	++errors;
+
+      return errors;
+    }
+
+  assert (ppath && *ppath);
+
+  if (argzize_path (*ppath, &argz, &argz_len) != 0)
+    {
+      ++errors;
+      goto cleanup;
+    }
+
+  /* Convert BEFORE into an equivalent offset into ARGZ.  This only works
+     if *PPATH is already canonicalized, and hence does not change length
+     with respect to ARGZ.  We canonicalize each entry as it is added to
+     the search path, and don't call this function with (uncanonicalized)
+     user paths, so this is a fair assumption.  */
+  if (before)
+    {
+      assert (*ppath <= before);
+      assert (before - *ppath <= strlen (*ppath));
+
+      before = before - *ppath + argz;
+    }
+
+  if (lt_argz_insert (&argz, &argz_len, before, dir) != 0)
+    {
+      ++errors;
+      goto cleanup;
+    }
+
+  argz_stringify (argz, argz_len, LT_PATHSEP_CHAR);
+  LT_DLMEM_REASSIGN (*ppath,  argz);
+
+ cleanup:
+  LT_DLFREE (canonical);
+  LT_DLFREE (argz);
+
+  return errors;
 }
 
 int
@@ -2690,40 +4005,47 @@
 {
   int errors = 0;
 
-  if (!search_dir || !strlen(search_dir))
+  if (search_dir && *search_dir)
     {
-      return errors;
+      LT_DLMUTEX_LOCK ();
+      if (lt_dlpath_insertdir (&user_search_path, 0, search_dir) != 0)
+	++errors;
+      LT_DLMUTEX_UNLOCK ();
     }
 
-  MUTEX_LOCK ();
-  if (!user_search_path)
+  return errors;
+}
+
+int
+lt_dlinsertsearchdir (before, search_dir)
+     const char *before;
+     const char *search_dir;
+{
+  int errors = 0;
+
+  if (before)
     {
-      user_search_path = strdup (search_dir);
-      if (!user_search_path)
+      LT_DLMUTEX_LOCK ();
+      if ((before < user_search_path)
+	  || (before >= user_search_path + LT_STRLEN (user_search_path)))
 	{
-	  last_error = LT_DLSTRERROR (NO_MEMORY);
-	  ++errors;
+	  LT_DLMUTEX_UNLOCK ();
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_POSITION));
+	  return 1;
 	}
+      LT_DLMUTEX_UNLOCK ();
     }
-  else
-    {
-      size_t len = strlen (user_search_path) + 1 + strlen (search_dir);
-      char  *new_search_path = LT_DLMALLOC (char, 1+ len);
 
-      if (!new_search_path)
+  if (search_dir && *search_dir)
+    {
+      LT_DLMUTEX_LOCK ();
+      if (lt_dlpath_insertdir (&user_search_path,
+			       (char *) before, search_dir) != 0)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
 	  ++errors;
 	}
-      else
-	{
-	  sprintf (new_search_path, "%s%c%s", user_search_path,
-		   LT_PATHSEP_CHAR, search_dir);
-
-	  LT_DLMEM_REASSIGN (user_search_path, new_search_path);
-	}
+      LT_DLMUTEX_UNLOCK ();
     }
-  MUTEX_UNLOCK ();
 
   return errors;
 }
@@ -2732,24 +4054,21 @@
 lt_dlsetsearchpath (search_path)
      const char *search_path;
 {
-  int errors = 0;
+  int   errors	    = 0;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   LT_DLFREE (user_search_path);
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
-  if (!search_path || !strlen (search_path))
+  if (!search_path || !LT_STRLEN (search_path))
     {
       return errors;
     }
 
-  MUTEX_LOCK ();
-  user_search_path = strdup (search_path);
-  if (!user_search_path)
-    {
-      ++errors;
-    }
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_LOCK ();
+  if (canonicalize_path (search_path, &user_search_path) != 0)
+    ++errors;
+  LT_DLMUTEX_UNLOCK ();
 
   return errors;
 }
@@ -2759,9 +4078,9 @@
 {
   const char *saved_path;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   saved_path = user_search_path;
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return saved_path;
 }
@@ -2774,7 +4093,7 @@
 
   if (!handle)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
       ++errors;
     }
   else
@@ -2791,7 +4110,7 @@
 {
   if (!handle)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
       return -1;
     }
 
@@ -2809,7 +4128,7 @@
 {
   if (!handle)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_HANDLE));
       return 0;
     }
 
@@ -2820,7 +4139,7 @@
 lt_dlhandle_next (place)
      lt_dlhandle place;
 {
-  return place ? place->next : (lt_dlhandle) 0;
+  return place ? place->next : handles;
 }
 
 int
@@ -2831,7 +4150,7 @@
   int errors = 0;
   lt_dlhandle cur;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
 
   cur = handles;
   while (cur)
@@ -2846,7 +4165,7 @@
 	}
     }
 
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return errors;
 }
@@ -2854,18 +4173,16 @@
 lt_dlcaller_id
 lt_dlcaller_register ()
 {
-  static int last_caller_id = -1;
+  static lt_dlcaller_id last_caller_id = 0;
   int result;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   result = ++last_caller_id;
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return result;
 }
 
-#define N_ELEMENTS(a)	(sizeof(a) / sizeof(*(a)))
-
 lt_ptr
 lt_dlcaller_set_data (key, handle, data)
      lt_dlcaller_id key;
@@ -2878,10 +4195,11 @@
 
   /* This needs to be locked so that the caller data can be updated
      simultaneously by different threads.  */
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
 
   if (handle->caller_data)
-    n_elements = N_ELEMENTS (handle->caller_data);
+    while (handle->caller_data[n_elements].key)
+      ++n_elements;
 
   for (i = 0; i < n_elements; ++i)
     {
@@ -2893,31 +4211,29 @@
     }
 
   /* Ensure that there is enough room in this handle's caller_data
-     array to accept a new element.  */
+     array to accept a new element (and an empty end marker).  */
   if (i == n_elements)
     {
       lt_caller_data *temp
-	= LT_DLREALLOC (lt_caller_data, handle->caller_data, 1+ n_elements);
+	= LT_DLREALLOC (lt_caller_data, handle->caller_data, 2+ n_elements);
 
-      if (temp == 0)
+      if (!temp)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-	  stale =  (lt_ptr) 0;
+	  stale = 0;
 	  goto done;
 	}
-      else
-	{
-	  handle->caller_data = temp;
-	}
+
+      handle->caller_data = temp;
 
       /* We only need this if we needed to allocate a new caller_data.  */
       handle->caller_data[i].key  = key;
+      handle->caller_data[1+ i].key = 0;
     }
 
   handle->caller_data[i].data = data;
 
  done:
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return stale;
 }
@@ -2928,19 +4244,15 @@
      lt_dlhandle handle;
 {
   lt_ptr result = (lt_ptr) 0;
-  int n_elements = 0;
 
   /* This needs to be locked so that the caller data isn't updated by
      another thread part way through this function.  */
-  MUTEX_LOCK ();
-
-  if (handle->caller_data)
-    n_elements = N_ELEMENTS (handle->caller_data);
+  LT_DLMUTEX_LOCK ();
 
   /* Locate the index of the element with a matching KEY.  */
   {
     int i;
-    for (i = 0; i < n_elements; ++i)
+    for (i = 0; handle->caller_data[i].key; ++i)
       {
 	if (handle->caller_data[i].key == key)
 	  {
@@ -2950,7 +4262,7 @@
       }
   }
 
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return result;
 }
@@ -2974,17 +4286,14 @@
       || (dlloader->module_close == 0)
       || (dlloader->find_sym == 0))
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
       return 1;
     }
 
   /* Create a new dlloader node with copies of the user callbacks.  */
-  node = LT_DLMALLOC (lt_dlloader, 1);
-  if (node == 0)
-    {
-      MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-      return 1;
-    }
+  node = LT_EMALLOC (lt_dlloader, 1);
+  if (!node)
+    return 1;
 
   node->next		= 0;
   node->loader_name	= loader_name;
@@ -2995,7 +4304,7 @@
   node->find_sym	= dlloader->find_sym;
   node->dlloader_data	= dlloader->dlloader_data;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   if (!loaders)
     {
       /* If there are no loaders, NODE becomes the list! */
@@ -3028,7 +4337,7 @@
 
       if (ptr->next != place)
 	{
-	  last_error = LT_DLSTRERROR (INVALID_LOADER);
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
 	  ++errors;
 	}
       else
@@ -3039,7 +4348,7 @@
 	}
     }
 
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return errors;
 }
@@ -3054,18 +4363,18 @@
 
   if (!place)
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
       return 1;
     }
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
 
   /* Fail if there are any open modules which use this loader. */
   for  (handle = handles; handle; handle = handle->next)
     {
       if (handle->loader == place)
 	{
-	  MUTEX_SETERROR (LT_DLSTRERROR (REMOVE_LOADER));
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (REMOVE_LOADER));
 	  ++errors;
 	  goto done;
 	}
@@ -3100,7 +4409,7 @@
   LT_DLFREE (place);
 
  done:
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return errors;
 }
@@ -3111,9 +4420,9 @@
 {
   lt_dlloader *next;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   next = place ? place->next : loaders;
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return next;
 }
@@ -3126,13 +4435,13 @@
 
   if (place)
     {
-      MUTEX_LOCK ();
+      LT_DLMUTEX_LOCK ();
       name = place ? place->loader_name : 0;
-      MUTEX_UNLOCK ();
+      LT_DLMUTEX_UNLOCK ();
     }
   else
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
     }
 
   return name;
@@ -3146,13 +4455,13 @@
 
   if (place)
     {
-      MUTEX_LOCK ();
+      LT_DLMUTEX_LOCK ();
       data = place ? &(place->dlloader_data) : 0;
-      MUTEX_UNLOCK ();
+      LT_DLMUTEX_UNLOCK ();
     }
   else
     {
-      MUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
+      LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
     }
 
   return data;
@@ -3164,7 +4473,7 @@
 {
   lt_dlloader *place = 0;
 
-  MUTEX_LOCK ();
+  LT_DLMUTEX_LOCK ();
   for (place = loaders; place; place = place->next)
     {
       if (strcmp (place->loader_name, loader_name) == 0)
@@ -3172,236 +4481,7 @@
 	  break;
 	}
     }
-  MUTEX_UNLOCK ();
+  LT_DLMUTEX_UNLOCK ();
 
   return place;
 }
-
-#ifdef _AIX
-
-/* #define DBG_PRNT(a) fprintf a ; */
-#define DBG_PRNT(a)
-
-static void
-sys_dl_debug_print_loaded( const char* filename )
-{
-    int                    ret;
-    static unsigned char   buffer[1024*1024];
-    struct ld_info*        info;
-
-    ret = loadquery( L_GETINFO, buffer, 1024*1024 );
-    if( ret >= 0 )
-      {
-        DBG_PRNT((stderr, "%d: Successfully loaded %s\n",
-	        __LINE__, filename ))
-        info = (struct ld_info*)buffer;
-        do
-          {
-	    const char* c;
-	    const char* d;
-	    c = info->ldinfo_filename;
-	    d = &c[strlen(c)];
-	    d++;
-	    DBG_PRNT((stderr, "%d: path name %s, member name %s\n",
-		    __LINE__,
-		    c,d))
-	    info = (struct ld_info*)(((char*)info)+info->ldinfo_next);
-          }
-        while( info->ldinfo_next != 0 );
-      }
-    else if( errno == ENOMEM )
-      {
-        DBG_PRNT((stderr, "%d: Successfully loaded %s, loadquery needs larger buffer\n",
-	        __LINE__, filename ))
-      }
-    else
-      {
-        DBG_PRNT((stderr, "Loadquery failure\n"))
-      }
-}
-
-static void
-sys_dl_debug_print_handle( lt_dlhandle handle )
-{
-    DBG_PRNT((stderr," > next          = %ld\n", (long)handle->next ))
-    DBG_PRNT((stderr," > loader        = %ld\n", (long)handle->loader ))
-    DBG_PRNT((stderr," > info.filename = %s\n", handle->info.filename ))
-    DBG_PRNT((stderr," > info.name     = %s\n", handle->info.name ))
-    DBG_PRNT((stderr," > info.ref_count= %d\n", handle->info.ref_count ))
-    DBG_PRNT((stderr," > depcount      = %d\n", handle->depcount ))
-    DBG_PRNT((stderr," > resident flags %s\n",
-            (LT_DLGET_FLAG (handle, LT_DLRESIDENT_FLAG)?"yes":"no")))
-    DBG_PRNT((stderr," > not found flags %s\n",
-            (LT_DLGET_FLAG (handle, LT_DLNOTFOUND_FLAG)?"yes":"no")))
-}
-
-static void
-sys_dl_init( )
-{
-  char*           buffer = NULL;
-  size_t          buf_size = 512;
-  int             ret;
-  const char*     libname;
-  const char*     modname;
-  struct ld_info* info;
-  lt_dlhandle	  cur;
-  lt_dlhandle     handle;
-  int             already_listed;
-  const char*     last_slash;
-  const char*     last_dot;
-
-  do
-    {
-      buf_size *= 2;
-      if( buffer != NULL ) LT_DLFREE( buffer );
-      buffer = LT_DLMALLOC( char, buf_size );
-      ret = loadquery( L_GETINFO, buffer, buf_size );
-    }
-  while( ret==-1 && errno==ENOMEM );
-
-  if( ret >= 0 )
-    {
-      info = (struct ld_info*)buffer;
-      do
-        {
-	  libname        = info->ldinfo_filename;
-	  modname        = &libname[strlen(libname)];
-	  modname        += 1;
-	  already_listed = 0;
-
-          cur = handles;
-	  while (cur)
-	    {
-	      if( cur->info.filename &&
-		  !strcmp( cur->info.filename, libname ) )
-	        {
-		  already_listed = 1;
-		  break;
-	        }
-              cur = cur->next;
-	    }
-
-	  if( already_listed == 0 )
-	    {
-              handle = (lt_dlhandle) LT_DLMALLOC (struct lt_dlhandle_struct, 1);
-              if (!handle)
-                {
-                  MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-		  LT_DLFREE( buffer );
-                  return;
-                }
-	      memset( handle, 0, sizeof( struct lt_dlhandle_struct ) );
-
-	      last_slash = strrchr( libname, '/' );
-	      if( last_slash == NULL )
-	        {
-	          last_slash = libname;
-	        }
-	      else
-	        {
-		  last_slash++;
-	        }
-	      last_dot   = strrchr( last_slash, '.' );
-	      if( last_dot == NULL )
-	        {
-	          last_dot = &last_slash[strlen(last_slash)];
-	        }
-
-              handle->info.name = LT_DLMALLOC( char, last_dot-last_slash+1 );
-	      strncpy( handle->info.name, last_slash, last_dot-last_slash );
-	      handle->info.name[last_dot-last_slash] = '\0';
-
-	      handle->loader         = lt_dlloader_find ("dlopen");
-	      handle->info.filename  = strdup( libname );
-              handle->info.ref_count = 1;
-              handle->depcount       = 0;
-              handle->deplibs        = 0;
-              handle->module         = dlopen( libname, lt_dlopen_flag );
-              handle->system         = 0;
-              handle->caller_data    = 0;
-	      LT_DLSET_FLAG (handle, LT_DLRESIDENT_FLAG);
-
-              MUTEX_LOCK ();
-              handle->next = handles;
-              handles = handle;
-              MUTEX_UNLOCK ();
-	    }
-
-	  info = (struct ld_info*)(((char*)info)+info->ldinfo_next);
-        }
-      while( info->ldinfo_next != 0 );
-    }
-
-    if( buffer != NULL ) LT_DLFREE( buffer );
-}
-
-static lt_dlhandle
-sys_dl_search_by_name( const char* name )
-{
-  lt_dlhandle cur;
-  const char* la;
-  int         inlen;
-
-  cur = handles;
-
-  while (cur)
-    {
-      if( cur->info.name && name )
-        {
-	  if( !strcmp( cur->info.name, name ) )
-            {
-	      if( cur->info.filename )
-	        {
-	          la = strrchr( cur->info.filename, '.' );
-	          if( !la || strcmp(la,".la") )
-	            {
-	              return cur;
-	            }
-	        }
-            }
-        }
-      if( cur->info.filename && name )
-	{
-	  if( !strcmp( cur->info.filename, name ) )
-	    {
-	      return cur;
-	    }
-	}
-      cur = cur->next;
-    }
-  return NULL;
-}
-
-static void
-sys_dl_not_found_entry( const char* tmp )
-{
-    lt_dlhandle handle;
-
-    handle = (lt_dlhandle) LT_DLMALLOC (struct lt_dlhandle_struct, 1);
-    if (!handle)
-      {
-        MUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
-        return;
-      }
-    memset( handle, 0, sizeof( struct lt_dlhandle_struct ) );
-
-    handle->loader = NULL;
-
-    handle->info.filename = strdup( tmp );
-    handle->info.name = strdup( tmp );
-    handle->info.ref_count    = 0;
-    handle->depcount          = 0;
-    handle->deplibs           = 0;
-    handle->module            = 0;
-    handle->system            = 0;
-    handle->caller_data       = 0;
-
-    LT_DLSET_FLAG (handle, LT_DLNOTFOUND_FLAG);
-
-    MUTEX_LOCK ();
-    handle->next = handles;
-    handles = handle;
-    MUTEX_UNLOCK ();
-}
-
-#endif /* _AIX */
Index: libltdl/ltdl.h
===================================================================
RCS file: /home/kde/kdelibs/libltdl/ltdl.h,v
retrieving revision 1.10
diff -u -r1.10 ltdl.h
--- libltdl/ltdl.h	6 Apr 2001 03:56:42 -0000	1.10
+++ libltdl/ltdl.h	15 Aug 2003 23:17:07 -0000
@@ -34,6 +34,9 @@
 /* --- MACROS FOR PORTABILITY --- */
 
 
+/* Saves on those hard to debug '\0' typos....  */
+#define LT_EOS_CHAR	'\0'
+
 /* LTDL_BEGIN_C_DECLS should be used at the beginning of your declarations,
    so that C++ compilers don't mangle their names.  Use LTDL_END_C_DECLS at
    the end of C declarations. */
@@ -82,6 +85,8 @@
 #  define LT_CONC(s,t)	s/**/t
 #endif
 
+/* LT_STRLEN can be used safely on NULL pointers.  */
+#define LT_STRLEN(s)	(((s) && (s)[0]) ? strlen (s) : 0)
 
 
 
@@ -146,10 +151,16 @@
 extern	int	    lt_dlinit		LT_PARAMS((void));
 extern	int	    lt_dlexit		LT_PARAMS((void));
 
-/* Module search path manipultation.  */
-extern	int	    lt_dladdsearchdir	LT_PARAMS((const char *search_dir));
-extern	int 	    lt_dlsetsearchpath	LT_PARAMS((const char *search_path));
-extern	const char *lt_dlgetsearchpath	LT_PARAMS((void));
+/* Module search path manipulation.  */
+extern	int	    lt_dladdsearchdir	 LT_PARAMS((const char *search_dir));
+extern	int	    lt_dlinsertsearchdir LT_PARAMS((const char *before,
+						    const char *search_dir));
+extern	int 	    lt_dlsetsearchpath	 LT_PARAMS((const char *search_path));
+extern	const char *lt_dlgetsearchpath	 LT_PARAMS((void));
+extern	int	    lt_dlforeachfile	 LT_PARAMS((
+			const char *search_path,
+			int (*func) (const char *filename, lt_ptr data),
+			lt_ptr data));
 
 /* Portable libltdl versions of the system dlopen() API. */
 extern	lt_dlhandle lt_dlopen		LT_PARAMS((const char *filename));
@@ -171,7 +182,7 @@
 
 typedef void	lt_dlmutex_lock		LT_PARAMS((void));
 typedef void	lt_dlmutex_unlock	LT_PARAMS((void));
-typedef void	lt_dlmutex_seterror	LT_PARAMS((const char *error));
+typedef void	lt_dlmutex_seterror	LT_PARAMS((const char *errmsg));
 typedef const char *lt_dlmutex_geterror	LT_PARAMS((void));
 
 extern	int	lt_dlmutex_register	LT_PARAMS((lt_dlmutex_lock *lock,
@@ -185,8 +196,13 @@
 /* --- MEMORY HANDLING --- */
 
 
-/* Pointers to memory management functions to be used by libltdl. */
+/* By default, the realloc function pointer is set to our internal
+   realloc implementation which iself uses lt_dlmalloc and lt_dlfree.
+   libltdl relies on a featureful realloc, but if you are sure yours
+   has the right semantics then you can assign it directly.  Generally,
+   it is safe to assign just a malloc() and a free() function.  */
 LT_SCOPE  lt_ptr   (*lt_dlmalloc)	LT_PARAMS((size_t size));
+LT_SCOPE  lt_ptr   (*lt_dlrealloc)	LT_PARAMS((lt_ptr ptr, size_t size));
 LT_SCOPE  void	   (*lt_dlfree)		LT_PARAMS((lt_ptr ptr));
 
 
@@ -275,8 +291,8 @@
 extern	const char     *lt_dlloader_name    LT_PARAMS((lt_dlloader *place));
 extern	lt_user_data   *lt_dlloader_data    LT_PARAMS((lt_dlloader *place));
 extern	int		lt_dlloader_add     LT_PARAMS((lt_dlloader *place,
-						const struct lt_user_dlloader *dlloader,
-						const char *loader_name));
+				const struct lt_user_dlloader *dlloader,
+				const char *loader_name));
 extern	int		lt_dlloader_remove  LT_PARAMS((
 						const char *loader_name));
 
@@ -307,7 +323,8 @@
     LT_ERROR(INVALID_ERRORCODE,     "invalid errorcode")		\
     LT_ERROR(SHUTDOWN,		    "library already shutdown")		\
     LT_ERROR(CLOSE_RESIDENT_MODULE, "can't close resident module")	\
-    LT_ERROR(INVALID_MUTEX_ARGS,    "invalid mutex handler registration")
+    LT_ERROR(INVALID_MUTEX_ARGS,    "invalid mutex handler registration") \
+    LT_ERROR(INVALID_POSITION,	    "invalid search path insert position")
 
 /* Enumerate the symbolic error names. */
 enum {
@@ -325,9 +342,6 @@
 
 
 
-/* For KDE and for now, we want this source compatibility until I get rid
-   of the exportation of ltdl.h alltogether.  (matz@kde.org) */
-#define LT_NON_POSIX_NAMESPACE
 /* --- SOURCE COMPATIBILITY WITH OLD LIBLTDL --- */
 
 
Index: libltdl/ltdl.m4
===================================================================
RCS file: /home/kde/kdelibs/libltdl/ltdl.m4,v
retrieving revision 1.8
diff -u -r1.8 ltdl.m4
--- libltdl/ltdl.m4	22 May 2002 15:37:48 -0000	1.8
+++ libltdl/ltdl.m4	15 Aug 2003 23:17:07 -0000
@@ -1,5 +1,5 @@
-## ltdl.m4 - Configure ltdl for the target system. -*-Shell-script-*-
-## Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+## ltdl.m4 - Configure ltdl for the target system. -*-Autoconf-*-
+## Copyright (C) 1999-2000 Free Software Foundation, Inc.
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
@@ -20,482 +20,452 @@
 ## configuration script generated by Autoconf, you may include it under
 ## the same distribution terms that you use for the rest of that program.
 
-# serial 1 AC_LIB_LTDL
+# serial 6 AC_LIB_LTDL
 
-AC_DEFUN(AC_LIB_LTDL,
-[AC_PREREQ(2.13)dnl
-AC_REQUIRE([AC_PROG_CC])dnl
-AC_REQUIRE([AC_C_CONST])dnl
-AC_REQUIRE([AC_C_INLINE])dnl
-AC_REQUIRE([AC_LIB_LTDL_COMMON])dnl
-])
-
-AC_DEFUN(KDE_LIB_LTDL,
-[AC_PREREQ(2.13)dnl
-AC_REQUIRE([AC_PROG_CC])dnl
-AC_REQUIRE([AC_LIB_LTDL_COMMON])dnl
-])
-
-AC_DEFUN(AC_LIB_LTDL_COMMON,
-[dnl
-dnl AC_LIB_LTDL must perform all the checks necessary for compilation
-dnl of the ltdl objects -- including compiler checks (above) and header
-dnl checks (below).
-AC_REQUIRE([AC_HEADER_STDC])dnl
-
-AC_CHECK_HEADERS(malloc.h memory.h stdlib.h stdio.h ctype.h dlfcn.h dl.h dld.h)
-AC_CHECK_HEADERS(string.h strings.h, break)
-AC_CHECK_FUNCS(strchr index, break)
-AC_CHECK_FUNCS(strrchr rindex, break)
-AC_CHECK_FUNCS(memcpy bcopy, break)
-AC_CHECK_FUNCS(strcmp)
-
-AC_REQUIRE([AC_LTDL_ENABLE_INSTALL])dnl
-AC_REQUIRE([AC_LTDL_SHLIBEXT])dnl
-AC_REQUIRE([AC_LTDL_SHLIBPATH])dnl
-AC_REQUIRE([AC_LTDL_SYSSEARCHPATH])dnl
-AC_REQUIRE([AC_LTDL_OBJDIR])dnl
-AC_REQUIRE([AC_LTDL_DLPREOPEN])dnl
-AC_REQUIRE([AC_LTDL_DLLIB])dnl
-AC_REQUIRE([AC_LTDL_SYMBOL_USCORE])dnl
-AC_REQUIRE([AC_LTDL_DLSYM_USCORE])dnl
-AC_REQUIRE([AC_LTDL_SYS_DLOPEN_DEPLIBS])dnl
-])
-
-AC_DEFUN(AC_LTDL_ENABLE_INSTALL,
-[AC_ARG_ENABLE(ltdl-install,
-[  --enable-ltdl-install   install libltdl])
+# AC_WITH_LTDL
+# ------------
+# Clients of libltdl can use this macro to allow the installer to
+# choose between a shipped copy of the ltdl sources or a preinstalled
+# version of the library.
+AC_DEFUN([AC_WITH_LTDL],
+[AC_REQUIRE([AC_LIB_LTDL])
+AC_SUBST([LIBLTDL])
+AC_SUBST([INCLTDL])
+
+# Unless the user asks us to check, assume no installed ltdl exists.
+use_installed_libltdl=no
+
+AC_ARG_WITH([included_ltdl],
+    [  --with-included-ltdl    use the GNU ltdl sources included here])
+
+if test "x$with_included_ltdl" != xyes; then
+  # We are not being forced to use the included libltdl sources, so
+  # decide whether there is a useful installed version we can use.
+  AC_CHECK_HEADER([ltdl.h],
+      [AC_CHECK_LIB([ltdl], [lt_dlcaller_register],
+          [with_included_ltdl=no],
+          [with_included_ltdl=yes])
+  ])
+fi
+
+if test "x$enable_ltdl_install" != xyes; then
+  # If the user did not specify an installable libltdl, then default
+  # to a convenience lib.
+  AC_LIBLTDL_CONVENIENCE
+fi
+
+if test "x$with_included_ltdl" = xno; then
+  # If the included ltdl is not to be used. then Use the
+  # preinstalled libltdl we found.
+  AC_DEFINE([HAVE_LTDL], 1,
+    [Define this if a modern libltdl is already installed])
+  LIBLTDL=-lltdl
+fi
+
+# Report our decision...
+AC_MSG_CHECKING([whether to use included libltdl])
+AC_MSG_RESULT([$with_included_ltdl])
+
+AC_CONFIG_SUBDIRS([libltdl])
+])# AC_WITH_LTDL
+
+
+# KDE_LIB_LTDL
+# -----------
+# Perform all the checks necessary for compilation of the ltdl objects
+#  -- including compiler checks and header checks.
+AC_DEFUN([KDE_LIB_LTDL],
+[AC_PREREQ(2.50)
+AC_REQUIRE([AC_PROG_CC])
+AC_REQUIRE([AC_C_CONST])
+AC_REQUIRE([AC_HEADER_STDC])
+AC_REQUIRE([AC_HEADER_DIRENT])
+AC_REQUIRE([_LT_AC_CHECK_DLFCN])
+AC_REQUIRE([AC_LTDL_ENABLE_INSTALL])
+AC_REQUIRE([AC_LTDL_SHLIBEXT])
+AC_REQUIRE([AC_LTDL_SHLIBPATH])
+AC_REQUIRE([AC_LTDL_SYSSEARCHPATH])
+AC_REQUIRE([AC_LTDL_OBJDIR])
+AC_REQUIRE([AC_LTDL_DLPREOPEN])
+AC_REQUIRE([AC_LTDL_DLLIB])
+AC_REQUIRE([AC_LTDL_SYMBOL_USCORE])
+AC_REQUIRE([AC_LTDL_DLSYM_USCORE])
+AC_REQUIRE([AC_LTDL_SYS_DLOPEN_DEPLIBS])
+AC_REQUIRE([AC_LTDL_FUNC_ARGZ])
+
+AC_CHECK_HEADERS([assert.h ctype.h errno.h malloc.h memory.h stdlib.h \
+		  stdio.h unistd.h])
+AC_CHECK_HEADERS([dl.h sys/dl.h dld.h mach-o/dyld.h])
+AC_CHECK_HEADERS([string.h strings.h], [break])
+
+AC_CHECK_FUNCS([strchr index], [break])
+AC_CHECK_FUNCS([strrchr rindex], [break])
+AC_CHECK_FUNCS([memcpy bcopy], [break])
+AC_CHECK_FUNCS([memmove strcmp])
+AC_CHECK_FUNCS([closedir opendir readdir])
+])# KDE_LIB_LTDL
+
+
+# AC_LIB_LTDL
+# -----------
+# Perform all the checks necessary for compilation of the ltdl objects
+#  -- including compiler checks and header checks.
+AC_DEFUN([AC_LIB_LTDL],
+[AC_PREREQ(2.50)
+AC_REQUIRE([AC_PROG_CC])
+AC_REQUIRE([AC_C_CONST])
+AC_REQUIRE([AC_HEADER_STDC])
+AC_REQUIRE([AC_HEADER_DIRENT])
+AC_REQUIRE([_LT_AC_CHECK_DLFCN])
+AC_REQUIRE([AC_LTDL_ENABLE_INSTALL])
+AC_REQUIRE([AC_LTDL_SHLIBEXT])
+AC_REQUIRE([AC_LTDL_SHLIBPATH])
+AC_REQUIRE([AC_LTDL_SYSSEARCHPATH])
+AC_REQUIRE([AC_LTDL_OBJDIR])
+AC_REQUIRE([AC_LTDL_DLPREOPEN])
+AC_REQUIRE([AC_LTDL_DLLIB])
+AC_REQUIRE([AC_LTDL_SYMBOL_USCORE])
+AC_REQUIRE([AC_LTDL_DLSYM_USCORE])
+AC_REQUIRE([AC_LTDL_SYS_DLOPEN_DEPLIBS])
+AC_REQUIRE([AC_LTDL_FUNC_ARGZ])
+
+AC_CHECK_HEADERS([assert.h ctype.h errno.h malloc.h memory.h stdlib.h \
+		  stdio.h unistd.h])
+AC_CHECK_HEADERS([dl.h sys/dl.h dld.h mach-o/dyld.h])
+AC_CHECK_HEADERS([string.h strings.h], [break])
+
+AC_CHECK_FUNCS([strchr index], [break])
+AC_CHECK_FUNCS([strrchr rindex], [break])
+AC_CHECK_FUNCS([memcpy bcopy], [break])
+AC_CHECK_FUNCS([memmove strcmp])
+AC_CHECK_FUNCS([closedir opendir readdir])
+])# AC_LIB_LTDL
+
+
+# AC_LTDL_ENABLE_INSTALL
+# ----------------------
+AC_DEFUN([AC_LTDL_ENABLE_INSTALL],
+[AC_ARG_ENABLE([ltdl-install],
+    [AC_HELP_STRING([--enable-ltdl-install], [install libltdl])])
 
 AM_CONDITIONAL(INSTALL_LTDL, test x"${enable_ltdl_install-no}" != xno)
 AM_CONDITIONAL(CONVENIENCE_LTDL, test x"${enable_ltdl_convenience-no}" != xno)
-])])
+])])# AC_LTDL_ENABLE_INSTALL
 
 
-AC_DEFUN(AC_LTDL_SNARF_CONFIG,
-[# Read the libtool configuration
-rm -f conftest
-./libtool --config > conftest
-. ./conftest
-rm -f conftest
-])
-
 # AC_LTDL_SYS_DLOPEN_DEPLIBS
 # --------------------------
-AC_DEFUN(AC_LTDL_SYS_DLOPEN_DEPLIBS,
+AC_DEFUN([AC_LTDL_SYS_DLOPEN_DEPLIBS],
 [AC_REQUIRE([AC_CANONICAL_HOST])
 AC_CACHE_CHECK([whether deplibs are loaded by dlopen],
-	libltdl_cv_sys_dlopen_deplibs, [dnl
-	# PORTME does your system automatically load deplibs for dlopen()?
-	libltdl_cv_sys_dlopen_deplibs=unknown
-	case "$host_os" in
-	linux*)
-	  libltdl_cv_sys_dlopen_deplibs=yes
-	  ;;
-	netbsd*|openbsd*|freebsd*)
-	  libltdl_cv_sys_dlopen_deplibs=yes
-	  ;;
-	solaris*)
-	  libltdl_cv_sys_dlopen_deplibs=yes
-	  ;;
-	hpux*|irix*)
-	  libltdl_cv_sys_dlopen_deplibs=yes
-	  ;;
-	osf*)
-	  libltdl_cv_sys_dlopen_deplibs=yes
-	  ;;
-	esac
-])
+  [libltdl_cv_sys_dlopen_deplibs],
+  [# PORTME does your system automatically load deplibs for dlopen?
+  # or its logical equivalent (e.g. shl_load for HP-UX < 11)
+  # For now, we just catch OSes we know something about -- in the
+  # future, we'll try test this programmatically.
+  libltdl_cv_sys_dlopen_deplibs=unknown
+  case "$host_os" in
+  aix3*|aix4.1.*|aix4.2.*)
+    # Unknown whether this is true for these versions of AIX, but
+    # we want this `case' here to explicitly catch those versions.
+    libltdl_cv_sys_dlopen_deplibs=unknown
+    ;;
+  aix[[45]]*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  darwin*)
+    # Assuming the user has installed a libdl from somewhere, this is true
+    # If you are looking for one http://www.opendarwin.org/projects/dlcompat
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;   
+  freebsd*-gnu*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  gnu*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  hpux10*|hpux11*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  irix[[12345]]*|irix6.[[01]]*)
+    # Catch all versions of IRIX before 6.2, and indicate that we don't
+    # know how it worked for any of those versions.
+    libltdl_cv_sys_dlopen_deplibs=unknown
+    ;;
+  irix*)
+    # The case above catches anything before 6.2, and it's known that
+    # at 6.2 and later dlopen does load deplibs.
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  linux*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  netbsd*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  openbsd*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  osf[[1234]]*)
+    # dlopen did load deplibs (at least at 4.x), but until the 5.x series,
+    # it did *not* use an RPATH in a shared library to find objects the
+    # library depends on, so we explictly say `no'.
+    libltdl_cv_sys_dlopen_deplibs=no
+    ;;
+  osf5.0|osf5.0a|osf5.1)
+    # dlopen *does* load deplibs and with the right loader patch applied
+    # it even uses RPATH in a shared library to search for shared objects
+    # that the library depends on, but there's no easy way to know if that
+    # patch is installed.  Since this is the case, all we can really
+    # say is unknown -- it depends on the patch being installed.  If
+    # it is, this changes to `yes'.  Without it, it would be `no'.
+    libltdl_cv_sys_dlopen_deplibs=unknown
+    ;;
+  osf*)
+    # the two cases above should catch all versions of osf <= 5.1.  Read
+    # the comments above for what we know about them.
+    # At > 5.1, deplibs are loaded *and* any RPATH in a shared library
+    # is used to find them so we can finally say `yes'.
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  solaris*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  esac
+  ])
 if test "$libltdl_cv_sys_dlopen_deplibs" != yes; then
- AC_DEFINE(LTDL_DLOPEN_DEPLIBS, 1,
-    [Define if the OS needs help to load dependent libraries for dlopen(). ])
+ AC_DEFINE([LTDL_DLOPEN_DEPLIBS], [1],
+    [Define if the OS needs help to load dependent libraries for dlopen().])
 fi
 ])# AC_LTDL_SYS_DLOPEN_DEPLIBS
 
-AC_DEFUN(AC_LTDL_SHLIBEXT,
-[AC_REQUIRE([AC_LTDL_SNARF_CONFIG])dnl
-AC_CACHE_CHECK([which extension is used for shared libraries],
-  libltdl_cv_shlibext, [dnl
-(
-  last=
-  for spec in $library_names_spec; do
-    last="$spec"
-  done
-changequote(, )
-  echo "$last" | sed 's/\[.*\]//;s/^[^.]*//;s/\$.*$//;s/\.$//' > conftest
-changequote([, ])
-)
-libltdl_cv_shlibext=`cat conftest`
-rm -f conftest
-])
+
+# AC_LTDL_SHLIBEXT
+# ----------------
+AC_DEFUN([AC_LTDL_SHLIBEXT],
+[AC_REQUIRE([AC_LIBTOOL_SYS_DYNAMIC_LINKER])
+AC_CACHE_CHECK([which extension is used for loadable modules],
+  [libltdl_cv_shlibext],
+[
+module=yes
+eval libltdl_cv_shlibext=$shrext
+  ])
 if test -n "$libltdl_cv_shlibext"; then
   AC_DEFINE_UNQUOTED(LTDL_SHLIB_EXT, "$libltdl_cv_shlibext",
-    [Define to the extension used for shared libraries, say, ".so". ])
+    [Define to the extension used for shared libraries, say, ".so".])
 fi
-])
+])# AC_LTDL_SHLIBEXT
 
-AC_DEFUN(AC_LTDL_SHLIBPATH,
-[AC_REQUIRE([AC_LTDL_SNARF_CONFIG])dnl
+
+# AC_LTDL_SHLIBPATH
+# -----------------
+AC_DEFUN([AC_LTDL_SHLIBPATH],
+[AC_REQUIRE([AC_LIBTOOL_SYS_DYNAMIC_LINKER])
 AC_CACHE_CHECK([which variable specifies run-time library path],
-  libltdl_cv_shlibpath_var, [libltdl_cv_shlibpath_var="$shlibpath_var"])
+  [libltdl_cv_shlibpath_var], [libltdl_cv_shlibpath_var="$shlibpath_var"])
 if test -n "$libltdl_cv_shlibpath_var"; then
   AC_DEFINE_UNQUOTED(LTDL_SHLIBPATH_VAR, "$libltdl_cv_shlibpath_var",
-    [Define to the name of the environment variable that determines the dynamic library search path. ])
+    [Define to the name of the environment variable that determines the dynamic library search path.])
 fi
-])
+])# AC_LTDL_SHLIBPATH
 
-AC_DEFUN(AC_LTDL_SYSSEARCHPATH,
-[AC_REQUIRE([AC_LTDL_SNARF_CONFIG])dnl
+
+# AC_LTDL_SYSSEARCHPATH
+# ---------------------
+AC_DEFUN([AC_LTDL_SYSSEARCHPATH],
+[AC_REQUIRE([AC_LIBTOOL_SYS_DYNAMIC_LINKER])
 AC_CACHE_CHECK([for the default library search path],
-  libltdl_cv_sys_search_path, [libltdl_cv_sys_search_path="$sys_lib_dlsearch_path_spec"])
+  [libltdl_cv_sys_search_path],
+  [libltdl_cv_sys_search_path="$sys_lib_dlsearch_path_spec"])
 if test -n "$libltdl_cv_sys_search_path"; then
-  case "$host" in
-  *-*-mingw*) pathsep=";" ;;
-  *) pathsep=":" ;;
-  esac
   sys_search_path=
   for dir in $libltdl_cv_sys_search_path; do
     if test -z "$sys_search_path"; then
       sys_search_path="$dir"
     else
-      sys_search_path="$sys_search_path$pathsep$dir"
+      sys_search_path="$sys_search_path$PATH_SEPARATOR$dir"
     fi
   done
   AC_DEFINE_UNQUOTED(LTDL_SYSSEARCHPATH, "$sys_search_path",
-    [Define to the system default library search path. ])
+    [Define to the system default library search path.])
 fi
-])
+])# AC_LTDL_SYSSEARCHPATH
 
-AC_DEFUN(AC_LTDL_OBJDIR,
+
+# AC_LTDL_OBJDIR
+# --------------
+AC_DEFUN([AC_LTDL_OBJDIR],
 [AC_CACHE_CHECK([for objdir],
-  libltdl_cv_objdir, [libltdl_cv_objdir="$objdir"
-if test -n "$objdir"; then
-  :
-else
-  rm -f .libs 2>/dev/null
-  mkdir .libs 2>/dev/null
-  if test -d .libs; then
-    libltdl_cv_objdir=.libs
+  [libltdl_cv_objdir],
+  [libltdl_cv_objdir="$objdir"
+  if test -n "$objdir"; then
+    :
   else
-    # MS-DOS does not allow filenames that begin with a dot.
-    libltdl_cv_objdir=_libs
+    rm -f .libs 2>/dev/null
+    mkdir .libs 2>/dev/null
+    if test -d .libs; then
+      libltdl_cv_objdir=.libs
+    else
+      # MS-DOS does not allow filenames that begin with a dot.
+      libltdl_cv_objdir=_libs
+    fi
+  rmdir .libs 2>/dev/null
   fi
-rmdir .libs 2>/dev/null
-fi])
+  ])
 AC_DEFINE_UNQUOTED(LTDL_OBJDIR, "$libltdl_cv_objdir/",
-  [Define to the sub-directory in which libtool stores uninstalled libraries. ])
-])
+  [Define to the sub-directory in which libtool stores uninstalled libraries.])
+])# AC_LTDL_OBJDIR
+
 
-AC_DEFUN(AC_LTDL_DLPREOPEN,
-[AC_REQUIRE([AC_LTDL_GLOBAL_SYMBOL_PIPE])dnl
+# AC_LTDL_DLPREOPEN
+# -----------------
+AC_DEFUN([AC_LTDL_DLPREOPEN],
+[AC_REQUIRE([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])
 AC_CACHE_CHECK([whether libtool supports -dlopen/-dlpreopen],
-       libltdl_cv_preloaded_symbols, [dnl
-  if test -n "$global_symbol_pipe"; then
+  [libltdl_cv_preloaded_symbols],
+  [if test -n "$lt_cv_sys_global_symbol_pipe"; then
     libltdl_cv_preloaded_symbols=yes
   else
     libltdl_cv_preloaded_symbols=no
   fi
-])
-if test x"$libltdl_cv_preloaded_symbols" = x"yes"; then
+  ])
+if test x"$libltdl_cv_preloaded_symbols" = xyes; then
   AC_DEFINE(HAVE_PRELOADED_SYMBOLS, 1,
-    [Define if libtool can extract symbol lists from object files. ])
+    [Define if libtool can extract symbol lists from object files.])
 fi
-])
+])# AC_LTDL_DLPREOPEN
 
-AC_DEFUN(AC_LTDL_DLLIB,
+
+# AC_LTDL_DLLIB
+# -------------
+AC_DEFUN([AC_LTDL_DLLIB],
 [LIBADD_DL=
-AC_CHECK_LIB(dl, dlopen, [AC_DEFINE(HAVE_LIBDL, 1,
-   [Define if you have the libdl library or equivalent. ]) LIBADD_DL="-ldl"],
-[AC_CHECK_FUNC(dlopen, [AC_DEFINE(HAVE_LIBDL, 1,
-   [Define if you have the libdl library or equivalent.])],
-[AC_CHECK_LIB(svld, dlopen, [AC_DEFINE(HAVE_LIBDL, 1,
-   [Define if you have the libdl library or equivalent.]) LIBADD_DL="-lsvld"]
-)])])
-AC_CHECK_FUNC(shl_load, [AC_DEFINE(HAVE_SHL_LOAD, 1,
-   [Define if you have the shl_load function.])],
-[AC_CHECK_LIB(dld, shl_load,
-  [AC_DEFINE(HAVE_SHL_LOAD, 1,
-     [Define if you have the shl_load function.])
-   LIBADD_DL="$LIBADD_DL -ldld"])
-])
-AC_CHECK_LIB(dld, dld_link, [AC_DEFINE(HAVE_DLD, 1,
-  [Define if you have the GNU dld library.])dnl
-test "x$ac_cv_lib_dld_shl_load" = yes || LIBADD_DL="$LIBADD_DL -ldld"])
 AC_SUBST(LIBADD_DL)
+AC_LANG_PUSH([C])
 
-if test "x$ac_cv_func_dlopen" = xyes || test "x$ac_cv_lib_dl_dlopen" = xyes; then
- LIBS_SAVE="$LIBS"
- LIBS="$LIBS $LIBADD_DL"
- AC_CHECK_FUNCS(dlerror)
- LIBS="$LIBS_SAVE"
-fi
-])
-
-AC_DEFUN(AC_LTDL_GLOBAL_SYMBOL_PIPE,
-[dnl Check for command to grab the raw symbol name followed
-dnl by C symbol name from nm.
-AC_REQUIRE([AC_CANONICAL_HOST])dnl
-AC_REQUIRE([AC_PROG_NM])dnl
-# Check for command to grab the raw symbol name followed by C symbol from nm.
-AC_MSG_CHECKING([command to parse $NM output])
-AC_CACHE_VAL(ac_cv_sys_global_symbol_pipe,
-[# These are sane defaults that work on at least a few old systems.
-# {They come from Ultrix.  What could be older than Ultrix?!! ;)}
-
-changequote(,)dnl
-# Character class describing NM global symbol codes.
-ac_symcode='[BCDEGRST]'
-
-# Regexp to match symbols that can be accessed directly from C.
-ac_sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
-
-# Transform the above into a raw symbol and a C symbol.
-ac_symxfrm='\1 \2\3 \3'
-
-# Transform an extracted symbol line into a proper C declaration
-ac_global_symbol_to_cdecl="sed -n -e 's/^. .* \(.*\)$/extern char \1;/p'"
-
-# Define system-specific variables.
-case "$host_os" in
-aix*)
-  ac_symcode='[BCDT]'
-  ;;
-cygwin* | mingw*)
-  ac_symcode='[ABCDGISTW]'
-  ;;
-hpux*)
-  ac_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern char \1();/p' -e 's/^. .* \(.*\)$/extern char \1;/p'"
-  ;;
-irix*)
-  ac_symcode='[BCDEGRST]'
-  ;;
-solaris*)
-  ac_symcode='[BDT]'
-  ;;
-esac
-
-# If we're using GNU nm, then use its standard symbol codes.
-if $NM -V 2>&1 | egrep '(GNU|with BFD)' > /dev/null; then
-  ac_symcode='[ABCDGISTW]'
-fi
-changequote([,])dnl
-
-# Try without a prefix undercore, then with it.
-for ac_symprfx in "" "_"; do
-
-  ac_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[ 	]\($ac_symcode\)[ 	][ 	]*\($ac_symprfx\)$ac_sympat$/$ac_symxfrm/p'"
-
-  # Check to see that the pipe works correctly.
-  ac_pipe_works=no
-  rm -f conftest.$ac_ext
-  cat > conftest.$ac_ext <<EOF
-#ifdef __cplusplus
-extern "C" {
+AC_CHECK_FUNC([shl_load],
+      [AC_DEFINE([HAVE_SHL_LOAD], [1],
+		 [Define if you have the shl_load function.])],
+  [AC_CHECK_LIB([dld], [shl_load],
+	[AC_DEFINE([HAVE_SHL_LOAD], [1],
+		   [Define if you have the shl_load function.])
+	LIBADD_DL="$LIBADD_DL -ldld"],
+    [AC_CHECK_LIB([dl], [dlopen],
+	  [AC_DEFINE([HAVE_LIBDL], [1],
+		     [Define if you have the libdl library or equivalent.])
+	        LIBADD_DL="-ldl" libltdl_cv_lib_dl_dlopen="yes"],
+      [AC_TRY_LINK([#if HAVE_DLFCN_H
+#  include <dlfcn.h>
 #endif
-char nm_test_var;
+      ],
+	[dlopen(0, 0);],
+	    [AC_DEFINE([HAVE_LIBDL], [1],
+		             [Define if you have the libdl library or equivalent.]) libltdl_cv_func_dlopen="yes"],
+	[AC_CHECK_LIB([svld], [dlopen],
+	      [AC_DEFINE([HAVE_LIBDL], [1],
+			 [Define if you have the libdl library or equivalent.])
+	            LIBADD_DL="-lsvld" libltdl_cv_func_dlopen="yes"],
+	  [AC_CHECK_LIB([dld], [dld_link],
+	        [AC_DEFINE([HAVE_DLD], [1],
+			   [Define if you have the GNU dld library.])
+	 	LIBADD_DL="$LIBADD_DL -ldld"],
+	 	[AC_CHECK_FUNC([_dyld_func_lookup],
+	 	       [AC_DEFINE([HAVE_DYLD], [1],
+	 	          [Define if you have the _dyld_func_lookup function.])])
+          ])
+        ])
+      ])
+    ])
+  ])
+])
+
+if test x"$libltdl_cv_func_dlopen" = xyes || test x"$libltdl_cv_lib_dl_dlopen" = xyes
+then
+  lt_save_LIBS="$LIBS"
+  LIBS="$LIBS $LIBADD_DL"
+  AC_CHECK_FUNCS([dlerror])
+  LIBS="$lt_save_LIBS"
+fi
+AC_LANG_POP
+])# AC_LTDL_DLLIB
+
+
+# AC_LTDL_SYMBOL_USCORE
+# ---------------------
+# does the compiler prefix global symbols with an underscore?
+AC_DEFUN([AC_LTDL_SYMBOL_USCORE],
+[AC_REQUIRE([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])
+AC_CACHE_CHECK([for _ prefix in compiled symbols],
+  [ac_cv_sys_symbol_underscore],
+  [ac_cv_sys_symbol_underscore=no
+  cat > conftest.$ac_ext <<EOF
 void nm_test_func(){}
-#ifdef __cplusplus
-}
-#endif
-int main(){nm_test_var='a';nm_test_func;return 0;}
+int main(){nm_test_func;return 0;}
 EOF
-
   if AC_TRY_EVAL(ac_compile); then
     # Now try to grab the symbols.
     ac_nlist=conftest.nm
-
-    if AC_TRY_EVAL(NM conftest.$ac_objext \| $ac_cv_sys_global_symbol_pipe \> $ac_nlist) && test -s "$ac_nlist"; then
-
-      # Try sorting and uniquifying the output.
-      if sort "$ac_nlist" | uniq > "$ac_nlist"T; then
-	mv -f "$ac_nlist"T "$ac_nlist"
-      else
-	rm -f "$ac_nlist"T
-      fi
-
-      # Make sure that we snagged all the symbols we need.
-      if egrep ' nm_test_var$' "$ac_nlist" >/dev/null; then
-	if egrep ' nm_test_func$' "$ac_nlist" >/dev/null; then
-	  cat <<EOF > conftest.$ac_ext
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-EOF
-	  # Now generate the symbol file.
-	  eval "$ac_global_symbol_to_cdecl"' < "$ac_nlist" >> conftest.$ac_ext'
-
-	  cat <<EOF >> conftest.$ac_ext
-#if defined (__STDC__) && __STDC__
-# define lt_ptr_t void *
-#else
-# define lt_ptr_t char *
-# define const
-#endif
-
-/* The mapping between symbol names and symbols. */
-const struct {
-  const char *name;
-  lt_ptr_t address;
-}
-changequote(,)dnl
-lt_preloaded_symbols[] =
-changequote([,])dnl
-{
-EOF
-	sed 's/^. \(.*\) \(.*\)$/  {"\2", (lt_ptr_t) \&\2},/' <	"$ac_nlist" >> conftest.$ac_ext
-	cat <<\EOF >> conftest.$ac_ext
-  {0, (lt_ptr_t) 0}
-};
-
-#ifdef __cplusplus
-}
-#endif
-EOF
-	  # Now try linking the two files.
-	  mv conftest.$ac_objext conftstm.$ac_objext
-	  ac_save_LIBS="$LIBS"
-	  ac_save_CFLAGS="$CFLAGS"
-	  LIBS="conftstm.$ac_objext"
-	  CFLAGS="$CFLAGS$no_builtin_flag"
-	  if AC_TRY_EVAL(ac_link) && test -s conftest; then
-	    ac_pipe_works=yes
-	  else
-	    echo "configure: failed program was:" >&AC_FD_CC
-	    cat conftest.$ac_ext >&AC_FD_CC
-	  fi
-	  LIBS="$ac_save_LIBS"
-	  CFLAGS="$ac_save_CFLAGS"
-	else
-	  echo "cannot find nm_test_func in $ac_nlist" >&AC_FD_CC
-	fi
+    if AC_TRY_EVAL(NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $ac_nlist) && test -s "$ac_nlist"; then
+      # See whether the symbols have a leading underscore.
+      if grep '^. _nm_test_func' "$ac_nlist" >/dev/null; then
+        ac_cv_sys_symbol_underscore=yes
       else
-	echo "cannot find nm_test_var in $ac_nlist" >&AC_FD_CC
+        if grep '^. nm_test_func ' "$ac_nlist" >/dev/null; then
+	  :
+        else
+	  echo "configure: cannot find nm_test_func in $ac_nlist" >&AC_FD_CC
+        fi
       fi
     else
-      echo "cannot run $ac_cv_sys_global_symbol_pipe" >&AC_FD_CC
+      echo "configure: cannot run $lt_cv_sys_global_symbol_pipe" >&AC_FD_CC
     fi
   else
-    echo "$progname: failed program was:" >&AC_FD_CC
-    cat conftest.$ac_ext >&AC_FD_CC
+    echo "configure: failed program was:" >&AC_FD_CC
+    cat conftest.c >&AC_FD_CC
   fi
-  rm -rf conftest* conftst*
+  rm -rf conftest*
+  ])
+])# AC_LTDL_SYMBOL_USCORE
 
-  # Do not use the global_symbol_pipe unless it works.
-  if test "$ac_pipe_works" = yes; then
-    if test x"$ac_symprfx" = x"_"; then
-      ac_cv_sys_symbol_underscore=yes
-    else
-      ac_cv_sys_symbol_underscore=no
-    fi
-    break
-  else
-    ac_cv_sys_global_symbol_pipe=
-  fi
-done
-])
-
-ac_result=yes
-if test -z "$ac_cv_sys_global_symbol_pipe"; then
-   ac_result=no
-fi
-AC_MSG_RESULT($ac_result)
-])
 
-AC_DEFUN(AC_LTDL_SYMBOL_USCORE,
-[dnl does the compiler prefix global symbols with an underscore?
-AC_REQUIRE([AC_LTDL_GLOBAL_SYMBOL_PIPE])dnl
-AC_MSG_CHECKING([for _ prefix in compiled symbols])
-AC_CACHE_VAL(ac_cv_sys_symbol_underscore,
-[ac_cv_sys_symbol_underscore=no
-cat > conftest.$ac_ext <<EOF
-void nm_test_func(){}
-int main(){nm_test_func;return 0;}
-EOF
-if AC_TRY_EVAL(ac_compile); then
-  # Now try to grab the symbols.
-  ac_nlist=conftest.nm
-  if AC_TRY_EVAL(NM conftest.$ac_objext \| $ac_cv_sys_global_symbol_pipe \> $ac_nlist) && test -s "$ac_nlist"; then
-    # See whether the symbols have a leading underscore.
-    if egrep '^. _nm_test_func' "$ac_nlist" >/dev/null; then
-      ac_cv_sys_symbol_underscore=yes
-    else
-      if egrep '^. nm_test_func ' "$ac_nlist" >/dev/null; then
-	:
-      else
-	echo "configure: cannot find nm_test_func in $ac_nlist" >&AC_FD_CC
-      fi
-    fi
-  else
-    echo "configure: cannot run $ac_cv_sys_global_symbol_pipe" >&AC_FD_CC
-  fi
-else
-  echo "configure: failed program was:" >&AC_FD_CC
-  cat conftest.$ac_ext >&AC_FD_CC
-fi
-rm -rf conftest*
-])
-AC_MSG_RESULT($ac_cv_sys_symbol_underscore)
-])
-
-AC_DEFUN(AC_LTDL_DLSYM_USCORE,
-[AC_REQUIRE([AC_LTDL_SYMBOL_USCORE])dnl
+# AC_LTDL_DLSYM_USCORE
+# --------------------
+AC_DEFUN([AC_LTDL_DLSYM_USCORE],
+[AC_REQUIRE([AC_LTDL_SYMBOL_USCORE])
 if test x"$ac_cv_sys_symbol_underscore" = xyes; then
-  if test x"$ac_cv_func_dlopen" = xyes ||
-     test x"$ac_cv_lib_dl_dlopen" = xyes ; then
+  if test x"$libltdl_cv_func_dlopen" = xyes ||
+     test x"$libltdl_cv_lib_dl_dlopen" = xyes ; then
 	AC_CACHE_CHECK([whether we have to add an underscore for dlsym],
-		libltdl_cv_need_uscore, [dnl
-		AC_TRY_RUN([
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
-
-#include <stdio.h>
-
-#ifdef RTLD_GLOBAL
-# define LTDL_GLOBAL	RTLD_GLOBAL
-#else
-# ifdef DL_GLOBAL
-#  define LTDL_GLOBAL	DL_GLOBAL
-# else
-#  define LTDL_GLOBAL	0
-# endif
-#endif
-
-/* We may have to define LTDL_LAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LTDL_LAZY_OR_NOW
-# ifdef RTLD_LAZY
-#  define LTDL_LAZY_OR_NOW	RTLD_LAZY
-# else
-#  ifdef DL_LAZY
-#   define LTDL_LAZY_OR_NOW	DL_LAZY
-#  else
-#   ifdef RTLD_NOW
-#    define LTDL_LAZY_OR_NOW	RTLD_NOW
-#   else
-#    ifdef DL_NOW
-#     define LTDL_LAZY_OR_NOW	DL_NOW
-#    else
-#     define LTDL_LAZY_OR_NOW	0
-#    endif
-#   endif
-#  endif
-# endif
-#endif
-
-void fnord() { int i=42;}
-int main() {
-    void *self, *ptr1, *ptr2; self=dlopen(0,LTDL_GLOBAL|LTDL_LAZY_OR_NOW);
-    if(self) { ptr1=dlsym(self,"fnord"); ptr2=dlsym(self,"_fnord");
-	       if(ptr1 && !ptr2) { dlclose(self); exit(0); } } exit(1); }
-],	libltdl_cv_need_uscore=no, libltdl_cv_need_uscore=yes,
-	libltdl_cv_need_uscore=cross
-)])
+	  [libltdl_cv_need_uscore],
+	  [libltdl_cv_need_uscore=unknown
+          save_LIBS="$LIBS"
+          LIBS="$LIBS $LIBADD_DL"
+	  _LT_AC_TRY_DLOPEN_SELF(
+	    [libltdl_cv_need_uscore=no], [libltdl_cv_need_uscore=yes],
+	    [],				 [libltdl_cv_need_uscore=cross])
+	  LIBS="$save_LIBS"
+	])
   fi
 fi
 
 if test x"$libltdl_cv_need_uscore" = xyes; then
   AC_DEFINE(NEED_USCORE, 1,
-    [Define if dlsym() requires a leading underscode in symbol names. ])
+    [Define if dlsym() requires a leading underscore in symbol names.])
 fi
-])
+])# AC_LTDL_DLSYM_USCORE
+
+# AC_LTDL_FUNC_ARGZ
+# -----------------
+AC_DEFUN([AC_LTDL_FUNC_ARGZ],
+[AC_CHECK_HEADERS([argz.h])
+
+AC_CHECK_TYPES([error_t],
+  [],
+  [AC_DEFINE([error_t], [int],
+    [Define to a type to use for `error_t' if it is not otherwise available.])],
+  [#if HAVE_ARGZ_H
+#  include <argz.h>
+#endif])
+
+AC_CHECK_FUNCS([argz_append argz_create_sep argz_insert argz_next argz_stringify])
+])# AC_LTDL_FUNC_ARGZ
