Description: Patch removes internal definitions of the main Tk structures.
    Since they have been changed since Tcl/Tk 8.4 it's much better to
    include tkInt.h and other few headers. They are internal Tk headers,
    so the BLT library built with Tcl/Tk 8.6 won't work with Tcl/Tk 8.5.
Author: FreeBSD BLT port maintainers
Last-Modified: Fri, 04 Jul 2014 09:13:24 +0400

--- a/generic/bltTkInt.h
+++ b/generic/bltTkInt.h
@@ -27,214 +27,8 @@
 #ifndef _BLT_TKINT_H
 #define _BLT_TKINT_H
 
-typedef struct {
-    Tk_Uid family;		/* Font family. The most important field. */
-    int pointsize;		/* Pointsize of font, 0 for default size, or
-				 * negative number meaning pixel size. */
-    int weight;			/* Weight flag; see below for def'n. */
-    int slant;			/* Slant flag; see below for def'n. */
-    int underline;		/* Non-zero for underline font. */
-    int overstrike;		/* Non-zero for overstrike font. */
-} TkFontAttributes;
-
-typedef struct {
-    int ascent;			/* From baseline to top of font. */
-    int descent;		/* From baseline to bottom of font. */
-    int maxWidth;		/* Width of widest character in font. */
-    int fixed;			/* Non-zero if this is a fixed-width font,
-				 * 0 otherwise. */
-} TkFontMetrics;
-
-
-typedef struct TkFontStruct {
-    /*
-     * Fields used and maintained exclusively by generic code.
-     */
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-    int resourceRefCount;	/* Number of active uses of this font (each
-				 * active use corresponds to a call to
-				 * Tk_AllocFontFromTable or Tk_GetFont).
-				 * If this count is 0, then this TkFont
-				 * structure is no longer valid and it isn't
-				 * present in a hash table: it is being
-				 * kept around only because there are objects
-				 * referring to it.  The structure is freed
-				 * when resourceRefCount and objRefCount
-				 * are both 0. */
-    int objRefCount;		/* The number of Tcl objects that reference
-				 * this structure. */
-#else
-    int refCount;		/* Number of users of the TkFont. */
-#endif
-    Tcl_HashEntry *cacheHashPtr;/* Entry in font cache for this structure,
-				 * used when deleting it. */
-    Tcl_HashEntry *namedHashPtr;/* Pointer to hash table entry that
-				 * corresponds to the named font that the
-				 * tkfont was based on, or NULL if the tkfont
-				 * was not based on a named font. */
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-    Screen *screen;		/* The screen where this font is valid. */
-#endif /* TK_VERSION_NUMBER >= 8.1.0 */
-    int tabWidth;		/* Width of tabs in this font (pixels). */
-    int underlinePos;		/* Offset from baseline to origin of
-				 * underline bar (used for drawing underlines
-				 * on a non-underlined font). */
-    int underlineHeight;	/* Height of underline bar (used for drawing
-				 * underlines on a non-underlined font). */
-
-    /*
-     * Fields in the generic font structure that are filled in by
-     * platform-specific code.
-     */
-
-    Font fid;			/* For backwards compatibility with XGCValues
-				 * structures.  Remove when TkGCValues is
-				 * implemented.  */
-    TkFontAttributes fa;	/* Actual font attributes obtained when the
-				 * the font was created, as opposed to the
-				 * desired attributes passed in to
-				 * TkpGetFontFromAttributes().  The desired
-				 * metrics can be determined from the string
-				 * that was used to create this font. */
-    TkFontMetrics fm;		/* Font metrics determined when font was
-				 * created. */
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-    struct TkFontStruct *nextPtr;	/* Points to the next TkFont structure with
-				 * the same name.  All fonts with the
-				 * same name (but different displays) are
-				 * chained together off a single entry in
-				 * a hash table. */
-#endif /* TK_VERSION_NUMBER >= 8.1.0 */
-} TkFont;
-
-/*
- * This structure is used by the Mac and Window porting layers as
- * the internal representation of a clip_mask in a GC.
- */
-typedef struct TkRegionStruct *TkRegion;
-
-typedef struct {
-    int type;			/* One of TKP_CLIP_PIXMAP or TKP_CLIP_REGION */
-    union {
-	Pixmap pixmap;
-	TkRegion region;
-    } value;
-} TkpClipMask;
-
-#define TKP_CLIP_PIXMAP 0
-#define TKP_CLIP_REGION 1
-
-#ifdef WIN32
-/*
- * The TkWinDrawable is the internal implementation of an X Drawable (either
- * a Window or a Pixmap).  The following constants define the valid Drawable
- * types.
- */
-
-#define TWD_BITMAP	1
-#define TWD_WINDOW	2
-#define TWD_WINDC	3
-
-typedef struct TkWindowStruct TkWindow;
-
-typedef struct {
-    int type;
-    HWND handle;
-    TkWindow *winPtr;
-} TkWinWindow;
-
-typedef struct {
-    int type;
-    HBITMAP handle;
-    Colormap colormap;
-    int depth;
-} TkWinBitmap;
-
-typedef struct {
-    int type;
-    HDC hdc;
-} TkWinDC;
-
-typedef union {
-    int type;
-    TkWinWindow window;
-    TkWinBitmap bitmap;
-    TkWinDC winDC;
-} TkWinDrawable;
-
-/*
- * The TkWinDCState is used to save the state of a device context
- * so that it can be restored later.
- */
-
-typedef struct {
-    HPALETTE palette;
-    int bkmode;			/* This field was added in Tk
-				 * 8.3.1. Be careful that you don't 
-				 * use this structure in a context
-				 * where its size is important.  */
-} TkWinDCState;
-
-extern HDC TkWinGetDrawableDC(Display *display, Drawable drawable,
-    TkWinDCState * state);
-extern HDC TkWinReleaseDrawableDC(Drawable drawable, HDC dc,
-    TkWinDCState * state);
-
-extern HWND Tk_GetHWND _ANSI_ARGS_((Window window));
-
-extern HINSTANCE Tk_GetHINSTANCE _ANSI_ARGS_((void));
-
-extern Window Tk_AttachHWND _ANSI_ARGS_((Tk_Window tkwin, HWND hWnd));
-
-#endif /* WIN32 */
-
-/*
- * The Border structure used internally by the Tk_3D* routines.
- * The following is a copy of it from tk3d.c.
- */
-
-typedef struct TkBorderStruct {
-    Screen *screen;		/* Screen on which the border will be used. */
-    Visual *visual;		/* Visual for all windows and pixmaps using
-				 * the border. */
-    int depth;			/* Number of bits per pixel of drawables where
-				 * the border will be used. */
-    Colormap colormap;		/* Colormap out of which pixels are
-				 * allocated. */
-    int refCount;		/* Number of different users of
-				 * this border.  */
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-    int objRefCount;		/* The number of Tcl objects that reference
-				 * this structure. */
-#endif /* TK_VERSION_NUMBER >= 8.1.0 */
-    XColor *bgColor;		/* Background color (intensity between 
-				 * lightColorPtr and darkColorPtr). */
-    XColor *darkColor;		/* Color for darker areas (must free when
-				 * deleting structure). NULL means shadows
-				 * haven't been allocated yet.*/
-    XColor *lightColor;		/* Color used for lighter areas of border
-				 * (must free this when deleting structure).
-				 * NULL means shadows haven't been allocated
-				 * yet. */
-    Pixmap shadow;		/* Stipple pattern to use for drawing
-				 * shadows areas.  Used for displays with
-				 * <= 64 colors or where colormap has filled
-				 * up. */
-    GC bgGC;			/* Used (if necessary) to draw areas in
-				 * the background color. */
-    GC darkGC;			/* Used to draw darker parts of the
-				 * border. None means the shadow colors
-				 * haven't been allocated yet.*/
-    GC lightGC;			/* Used to draw lighter parts of
-				 * the border. None means the shadow colors
-				 * haven't been allocated yet. */
-    Tcl_HashEntry *hashPtr;	/* Entry in borderTable (needed in
-				 * order to delete structure). */
-    struct TkBorderStruct *nextPtr; /* Points to the next TkBorder structure with
-				 * the same color name.  Borders with the
-				 * same name but different screens or
-				 * colormaps are chained together off a
-				 * single entry in borderTable. */
-} TkBorder;
+#include <tkInt.h>
+#include <tk3d.h>
+#include <tkFont.h>
 
 #endif /* BLT_TKINT_H */
--- a/generic/bltWindow.c
+++ b/generic/bltWindow.c
@@ -33,25 +33,7 @@
 #include <X11/Xproto.h>
 #endif
 
-typedef struct TkIdStackStruct TkIdStack;
-typedef struct TkErrorHandlerStruct TkErrorHandler;
-typedef struct TkSelectionInfoStruct TkSelectionInfo;
-typedef struct TkClipboardTargetStruct TkClipboardTarget;
-
-#ifndef WIN32
-typedef struct TkWindowStruct TkWindow;
-#endif
-typedef struct TkWindowEventStruct TkWindowEvent;
-typedef struct TkMainInfoStruct TkMainInfo;
-typedef struct TkEventHandlerStruct TkEventHandler;
-typedef struct TkSelHandlerStruct TkSelHandler;
-typedef struct TkWinInfoStruct TkWinInfo;
-typedef struct TkClassProcsStruct TkClassProcs;
-typedef struct TkWindowPrivateStruct TkWindowPrivate;
-typedef struct TkGrabEventStruct TkGrabEvent;
-typedef struct TkColormapStruct TkColormap;
-typedef struct TkStressedCmapStruct TkStressedCmap;
-typedef struct TkWmInfoStruct TkWmInfo;
+#include <tkInt.h>
 
 #ifdef XNQueryInputStyle
 #define TK_USE_INPUT_METHODS
@@ -70,766 +52,6 @@
 #define TK_REPARENTED 	0
 #endif
 
-#if (TK_VERSION_NUMBER >= _VERSION(8,1,0))
-
-typedef struct TkCaret {
-    struct TkWindow *winPtr;	/* the window on which we requested caret
-				 * placement */
-    int x;			/* relative x coord of the caret */
-    int y;			/* relative y coord of the caret */
-    int height;			/* specified height of the window */
-} TkCaret;
-
-/*
- * One of the following structures is maintained for each display
- * containing a window managed by Tk.  In part, the structure is
- * used to store thread-specific data, since each thread will have
- * its own TkDisplay structure.
- */
-
-typedef struct TkDisplayStruct {
-    Display *display;		/* Xlib's info about display. */
-    struct TkDisplayStruct *nextPtr; /* Next in list of all displays. */
-    char *name;			/* Name of display (with any screen
-				 * identifier removed).  Malloc-ed. */
-    Time lastEventTime;		/* Time of last event received for this
-				 * display. */
-
-    /*
-     * Information used primarily by tk3d.c:
-     */
-
-    int borderInit;		/* 0 means borderTable needs initializing. */
-    Tcl_HashTable borderTable;	/* Maps from color name to TkBorder
-				 * structure. */
-
-    /*
-     * Information used by tkAtom.c only:
-     */
-
-    int atomInit;		/* 0 means stuff below hasn't been
-				 * initialized yet. */
-    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
-    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
-
-    /*
-     * Information used primarily by tkBind.c:
-     */
-
-    int bindInfoStale;		/* Non-zero means the variables in this
-				 * part of the structure are potentially
-				 * incorrect and should be recomputed. */
-    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to "mode shift".  If no
-				 * such modifier, than this is zero. */
-    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key.  If no
-				 * such modifier, then this is zero. */
-    unsigned int altModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key.  If no
-				 * such modifier, then this is zero. */
-    enum {
-	LU_IGNORE, LU_CAPS, LU_SHIFT
-    } lockUsage;		/* Indicates how to interpret lock modifier. */
-    int numModKeyCodes;		/* Number of entries in modKeyCodes array
-				 * below. */
-    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for
-				 * all of the keys that have modifiers
-				 * associated with them.  Malloc'ed, but
-				 * may be NULL. */
-
-    /*
-     * Information used by tkBitmap.c only:
-     */
-
-    int bitmapInit;		/* 0 means tables above need initializing. */
-    int bitmapAutoNumber;	/* Used to number bitmaps. */
-    Tcl_HashTable bitmapNameTable;
-				/* Maps from name of bitmap to the first
-				 * TkBitmap record for that name. */
-    Tcl_HashTable bitmapIdTable;/* Maps from bitmap id to the TkBitmap
-				 * structure for the bitmap. */
-    Tcl_HashTable bitmapDataTable;
-				/* Used by Tk_GetBitmapFromData to map from
-				 * a collection of in-core data about a
-				 * bitmap to a reference giving an auto-
-				 * matically-generated name for the bitmap. */
-
-    /*
-     * Information used by tkCanvas.c only:
-     */
-
-    int numIdSearches;
-    int numSlowSearches;
-
-    /*
-     * Used by tkColor.c only:
-     */
-
-    int colorInit;		/* 0 means color module needs initializing. */
-    TkStressedCmap *stressPtr;	/* First in list of colormaps that have
-				 * filled up, so we have to pick an
-				 * approximate color. */
-    Tcl_HashTable colorNameTable;
-				/* Maps from color name to TkColor structure
-				 * for that color. */
-    Tcl_HashTable colorValueTable;
-				/* Maps from integer RGB values to TkColor
-				 * structures. */
-
-    /*
-     * Used by tkCursor.c only:
-     */
-
-    int cursorInit;		/* 0 means cursor module need initializing. */
-    Tcl_HashTable cursorNameTable;
-				/* Maps from a string name to a cursor to the
-				 * TkCursor record for the cursor. */
-    Tcl_HashTable cursorDataTable;
-				/* Maps from a collection of in-core data
-				 * about a cursor to a TkCursor structure. */
-    Tcl_HashTable cursorIdTable;
-				/* Maps from a cursor id to the TkCursor
-				 * structure for the cursor. */
-    char cursorString[20];	/* Used to store a cursor id string. */
-    Font cursorFont;		/* Font to use for standard cursors.
-				 * None means font not loaded yet. */
-
-    /*
-     * Information used by tkError.c only:
-     */
-
-    struct TkErrorHandler *errorPtr;
-				/* First in list of error handlers
-				 * for this display.  NULL means
-				 * no handlers exist at present. */
-    int deleteCount;		/* Counts # of handlers deleted since
-				 * last time inactive handlers were
-				 * garbage-collected.  When this number
-				 * gets big, handlers get cleaned up. */
-
-    /*
-     * Used by tkEvent.c only:
-     */
-
-    struct TkWindowEvent *delayedMotionPtr;
-				/* Points to a malloc-ed motion event
-				 * whose processing has been delayed in
-				 * the hopes that another motion event
-				 * will come along right away and we can
-				 * merge the two of them together.  NULL
-				 * means that there is no delayed motion
-				 * event. */
-
-    /*
-     * Information used by tkFocus.c only:
-     */
-
-    int focusDebug;		/* 1 means collect focus debugging
-				 * statistics. */
-    struct TkWindow *implicitWinPtr;
-				/* If the focus arrived at a toplevel window
-				 * implicitly via an Enter event (rather
-				 * than via a FocusIn event), this points
-				 * to the toplevel window.  Otherwise it is
-				 * NULL. */
-    struct TkWindow *focusPtr;	/* Points to the window on this display that
-				 * should be receiving keyboard events.  When
-				 * multiple applications on the display have
-				 * the focus, this will refer to the
-				 * innermost window in the innermost
-				 * application.  This information isn't used
-				 * under Unix or Windows, but it's needed on
-				 * the Macintosh. */
-
-    /*
-     * Information used by tkGC.c only:
-     */
-
-    Tcl_HashTable gcValueTable;	/* Maps from a GC's values to a TkGC structure
-				 * describing a GC with those values. */
-    Tcl_HashTable gcIdTable;	/* Maps from a GC to a TkGC. */
-    int gcInit;			/* 0 means the tables below need
-				 * initializing. */
-
-    /*
-     * Information used by tkGeometry.c only:
-     */
-
-    Tcl_HashTable maintainHashTable;
-				/* Hash table that maps from a master's
-				 * Tk_Window token to a list of slaves
-				 * managed by that master. */
-    int geomInit;
-
-    /*
-     * Information used by tkGet.c only:
-     */
-
-    Tcl_HashTable uidTable;	/* Stores all Tk_Uids used in a thread. */
-    int uidInit;		/* 0 means uidTable needs initializing. */
-
-    /*
-     * Information used by tkGrab.c only:
-     */
-
-    struct TkWindow *grabWinPtr;
-				/* Window in which the pointer is currently
-				 * grabbed, or NULL if none. */
-    struct TkWindow *eventualGrabWinPtr;
-				/* Value that grabWinPtr will have once the
-				 * grab event queue (below) has been
-				 * completely emptied. */
-    struct TkWindow *buttonWinPtr;
-				/* Window in which first mouse button was
-				 * pressed while grab was in effect, or NULL
-				 * if no such press in effect. */
-    struct TkWindow *serverWinPtr;
-				/* If no application contains the pointer then
-				 * this is NULL.  Otherwise it contains the
-				 * last window for which we've gotten an
-				 * Enter or Leave event from the server (i.e.
-				 * the last window known to have contained
-				 * the pointer).  Doesn't reflect events
-				 * that were synthesized in tkGrab.c. */
-    TkGrabEvent *firstGrabEventPtr;
-				/* First in list of enter/leave events
-				 * synthesized by grab code.  These events
-				 * must be processed in order before any other
-				 * events are processed.  NULL means no such
-				 * events. */
-    TkGrabEvent *lastGrabEventPtr;
-				/* Last in list of synthesized events, or NULL
-				 * if list is empty. */
-    int grabFlags;		/* Miscellaneous flag values.  See definitions
-				 * in tkGrab.c. */
-
-    /*
-     * Information used by tkGrid.c only:
-     */
-
-    int gridInit;		/* 0 means table below needs initializing. */
-    Tcl_HashTable gridHashTable;/* Maps from Tk_Window tokens to
-				 * corresponding Grid structures. */
-
-    /*
-     * Information used by tkImage.c only:
-     */
-
-    int imageId;		/* Value used to number image ids. */
-
-    /*
-     * Information used by tkMacWinMenu.c only:
-     */
-
-    int postCommandGeneration;
-
-    /*
-     * Information used by tkOption.c only.
-     */
-
-
-
-    /*
-     * Information used by tkPack.c only.
-     */
-
-    int packInit;		/* 0 means table below needs initializing. */
-    Tcl_HashTable packerHashTable;
-				/* Maps from Tk_Window tokens to
-				 * corresponding Packer structures. */
-
-
-    /*
-     * Information used by tkPlace.c only.
-     */
-
-    int placeInit;		/* 0 means tables below need initializing. */
-    Tcl_HashTable masterTable;	/* Maps from Tk_Window toke to the Master
-				 * structure for the window, if it exists. */
-    Tcl_HashTable slaveTable;	/* Maps from Tk_Window toke to the Slave
-				 * structure for the window, if it exists. */
-
-    /*
-     * Information used by tkSelect.c and tkClipboard.c only:
-     */
-
-
-    struct TkSelectionInfo *selectionInfoPtr;
-    /* First in list of selection information
-				 * records.  Each entry contains information
-				 * about the current owner of a particular
-				 * selection on this display. */
-    Atom multipleAtom;		/* Atom for MULTIPLE.  None means
-				 * selection stuff isn't initialized. */
-    Atom incrAtom;		/* Atom for INCR. */
-    Atom targetsAtom;		/* Atom for TARGETS. */
-    Atom timestampAtom;		/* Atom for TIMESTAMP. */
-    Atom textAtom;		/* Atom for TEXT. */
-    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
-    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
-    Atom windowAtom;		/* Atom for TK_WINDOW. */
-    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
-#if (TK_VERSION_NUMBER >= _VERSION(8,4,0))
-    Atom utf8Atom;
-#endif
-    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
-				 * retrieve selections between processes. NULL
-				 * means clipboard info hasn't been
-				 * initialized. */
-    int clipboardActive;	/* 1 means we currently own the clipboard
-				 * selection, 0 means we don't. */
-    struct TkMainInfo *clipboardAppPtr;
-				/* Last application that owned clipboard. */
-    struct TkClipboardTarget *clipTargetPtr;
-				/* First in list of clipboard type information
-				 * records.  Each entry contains information
-				 * about the buffers for a given selection
-				 * target. */
-
-    /*
-     * Information used by tkSend.c only:
-     */
-
-    Tk_Window commTkwin;	/* Window used for communication
-				 * between interpreters during "send"
-				 * commands.  NULL means send info hasn't
-				 * been initialized yet. */
-    Atom commProperty;		/* X's name for comm property. */
-    Atom registryProperty;	/* X's name for property containing
-				 * registry of interpreter names. */
-    Atom appNameProperty;	/* X's name for property used to hold the
-				 * application name on each comm window. */
-
-    /*
-     * Information used by tkXId.c only:
-     */
-
-    struct TkIdStack *idStackPtr;
-				/* First in list of chunks of free resource
-				 * identifiers, or NULL if there are no free
-				 * resources. */
-    XID(*defaultAllocProc) _ANSI_ARGS_((Display *display));
-				/* Default resource allocator for display. */
-    struct TkIdStack *windowStackPtr;
-				/* First in list of chunks of window
-				 * identifers that can't be reused right
-				 * now. */
-#if (TK_VERSION_NUMBER < _VERSION(8,4,0))
-    int idCleanupScheduled;	/* 1 means a call to WindowIdCleanup has
-				 * already been scheduled, 0 means it
-				 * hasn't. */
-#else
-    Tcl_TimerToken idCleanupScheduled;
-				/* If set, it means a call to WindowIdCleanup
-				 * has already been scheduled, 0 means it
-				 * hasn't. */
-#endif
-    /*
-     * Information used by tkUnixWm.c and tkWinWm.c only:
-     */
-
-#if (TK_VERSION_NUMBER < _VERSION(8,4,0))
-    int wmTracing;		/* Used to enable or disable tracing in
-				 * this module.  If tracing is enabled,
-				 * then information is printed on
-				 * standard output about interesting
-				 * interactions with the window manager. */
-#endif
-    struct TkWmInfo *firstWmPtr; /* Points to first top-level window. */
-    struct TkWmInfo *foregroundWmPtr;
-				/* Points to the foreground window. */
-
-    /*
-     * Information maintained by tkWindow.c for use later on by tkXId.c:
-     */
-
-
-    int destroyCount;		/* Number of Tk_DestroyWindow operations
-				 * in progress. */
-    unsigned long lastDestroyRequest;
-				/* Id of most recent XDestroyWindow request;
-				 * can re-use ids in windowStackPtr when
-				 * server has seen this request and event
-				 * queue is empty. */
-
-    /*
-     * Information used by tkVisual.c only:
-     */
-
-    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
-				 * allocated for this display. */
-
-    /*
-     * Miscellaneous information:
-     */
-
-#ifdef TK_USE_INPUT_METHODS
-    XIM inputMethod;		/* Input method for this display */
-    XIMStyle inputStyle;        /* Input style selected for this display. */
-#if (TK_VERSION_NUMBER >= _VERSION(8,4,0))
-#if TK_XIM_SPOT
-    XFontSet inputXfs;		/* XFontSet cached for over-the-spot XIM. */
-#endif /* TK_XIM_SPOT */
-#endif /* TK_VERSION_NUMBER >= 8.4 */
-#endif /* TK_USE_INPUT_METHODS */
-    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
-    int refCount;		/* Reference count of how many Tk applications
-                                 * are using this display. Used to clean up
-                                 * the display when we no longer have any
-                                 * Tk applications using it.
-                                 */
-    /*
-     * The following field were all added for Tk8.3
-     */
-    int mouseButtonState;       /* current mouse button state for this
-                                 * display */
-    Window mouseButtonWindow;   /* Window the button state was set in, added
-				 * in Tk 8.4. */
-#if (TK_VERSION_NUMBER < _VERSION(8,4,0))
-    int warpInProgress;
-#endif
-    Window warpWindow;
-    int warpX;
-    int warpY;
-#if (TK_VERSION_NUMBER < _VERSION(8,4,0))
-    int useInputMethods;        /* Whether to use input methods */
-#else
-    /*
-     * The following field(s) were all added for Tk8.4
-     */
-/*    long deletionEpoch;		* Incremented by window deletions */
-    unsigned int flags;		/* Various flag values:  these are all
-				 * defined in below. */
-    TkCaret caret;		/* information about the caret for this
-				 * display.  This is not a pointer. */
-
-    int iconDataSize;           /* Size of default iconphoto image data. */
-    unsigned char *iconDataPtr; /* Default iconphoto image data, if set. */
-
-#endif
-} TkDisplay;
-
-#else
-
-/*
- * One of the following structures is maintained for each display
- * containing a window managed by Tk:
- */
-typedef struct TkDisplayStruct {
-    Display *display;		/* Xlib's info about display. */
-    struct TkDisplayStruct *nextPtr; /* Next in list of all displays. */
-    char *name;			/* Name of display (with any screen
-				 * identifier removed).  Malloc-ed. */
-    Time lastEventTime;		/* Time of last event received for this
-				 * display. */
-
-    /*
-     * Information used primarily by tkBind.c:
-     */
-
-    int bindInfoStale;		/* Non-zero means the variables in this
-				 * part of the structure are potentially
-				 * incorrect and should be recomputed. */
-    unsigned int modeModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to "mode shift".  If no
-				 * such modifier, than this is zero. */
-    unsigned int metaModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key.  If no
-				 * such modifier, then this is zero. */
-    unsigned int altModMask;	/* Has one bit set to indicate the modifier
-				 * corresponding to the "Meta" key.  If no
-				 * such modifier, then this is zero. */
-    enum {
-	LU_IGNORE, LU_CAPS, LU_SHIFT
-    } lockUsage;
-    /* Indicates how to interpret lock modifier. */
-    int numModKeyCodes;		/* Number of entries in modKeyCodes array
-				 * below. */
-    KeyCode *modKeyCodes;	/* Pointer to an array giving keycodes for
-				 * all of the keys that have modifiers
-				 * associated with them.  Malloc'ed, but
-				 * may be NULL. */
-
-    /*
-     * Information used by tkError.c only:
-     */
-
-    TkErrorHandler *errorPtr;
-    /* First in list of error handlers
-				 * for this display.  NULL means
-				 * no handlers exist at present. */
-     int deleteCount;		/* Counts # of handlers deleted since
-				 * last time inactive handlers were
-				 * garbage-collected.  When this number
-				 * gets big, handlers get cleaned up. */
-
-    /*
-     * Information used by tkSend.c only:
-     */
-
-    Tk_Window commTkwin;	/* Window used for communication
-				 * between interpreters during "send"
-				 * commands.  NULL means send info hasn't
-				 * been initialized yet. */
-    Atom commProperty;		/* X's name for comm property. */
-    Atom registryProperty;	/* X's name for property containing
-				 * registry of interpreter names. */
-    Atom appNameProperty;	/* X's name for property used to hold the
-				 * application name on each comm window. */
-
-    /*
-     * Information used by tkSelect.c and tkClipboard.c only:
-     */
-
-     TkSelectionInfo *selectionInfoPtr;
-    /* First in list of selection information
-				 * records.  Each entry contains information
-				 * about the current owner of a particular
-				 * selection on this display. */
-    Atom multipleAtom;		/* Atom for MULTIPLE.  None means
-				 * selection stuff isn't initialized. */
-    Atom incrAtom;		/* Atom for INCR. */
-    Atom targetsAtom;		/* Atom for TARGETS. */
-    Atom timestampAtom;		/* Atom for TIMESTAMP. */
-    Atom textAtom;		/* Atom for TEXT. */
-    Atom compoundTextAtom;	/* Atom for COMPOUND_TEXT. */
-    Atom applicationAtom;	/* Atom for TK_APPLICATION. */
-    Atom windowAtom;		/* Atom for TK_WINDOW. */
-    Atom clipboardAtom;		/* Atom for CLIPBOARD. */
-
-    Tk_Window clipWindow;	/* Window used for clipboard ownership and to
-				 * retrieve selections between processes. NULL
-				 * means clipboard info hasn't been
-				 * initialized. */
-    int clipboardActive;	/* 1 means we currently own the clipboard
-				 * selection, 0 means we don't. */
-     TkMainInfo *clipboardAppPtr;
-     /* Last application that owned clipboard. */
-     TkClipboardTarget *clipTargetPtr;
-     /* First in list of clipboard type information
-				 * records.  Each entry contains information
-				 * about the buffers for a given selection
-				 * target. */
-
-    /*
-     * Information used by tkAtom.c only:
-     */
-
-    int atomInit;		/* 0 means stuff below hasn't been
-				 * initialized yet. */
-    Tcl_HashTable nameTable;	/* Maps from names to Atom's. */
-    Tcl_HashTable atomTable;	/* Maps from Atom's back to names. */
-
-    /*
-     * Information used by tkCursor.c only:
-     */
-
-    Font cursorFont;		/* Font to use for standard cursors.
-				 * None means font not loaded yet. */
-
-    /*
-     * Information used by tkGrab.c only:
-     */
-
-     TkWindow *grabWinPtr;
-    /* Window in which the pointer is currently
-				 * grabbed, or NULL if none. */
-     TkWindow *eventualGrabWinPtr;
-    /* Value that grabWinPtr will have once the
-				 * grab event queue (below) has been
-				 * completely emptied. */
-     TkWindow *buttonWinPtr;
-    /* Window in which first mouse button was
-				 * pressed while grab was in effect, or NULL
-				 * if no such press in effect. */
-     TkWindow *serverWinPtr;
-    /* If no application contains the pointer then
-				 * this is NULL.  Otherwise it contains the
-				 * last window for which we've gotten an
-				 * Enter or Leave event from the server (i.e.
-				 * the last window known to have contained
-				 * the pointer).  Doesn't reflect events
-				 * that were synthesized in tkGrab.c. */
-    TkGrabEvent *firstGrabEventPtr;
-    /* First in list of enter/leave events
-				 * synthesized by grab code.  These events
-				 * must be processed in order before any other
-				 * events are processed.  NULL means no such
-				 * events. */
-    TkGrabEvent *lastGrabEventPtr;
-    /* Last in list of synthesized events, or NULL
-				 * if list is empty. */
-    int grabFlags;		/* Miscellaneous flag values.  See definitions
-				 * in tkGrab.c. */
-
-    /*
-     * Information used by tkXId.c only:
-     */
-
-     TkIdStack *idStackPtr;
-    /* First in list of chunks of free resource
-				 * identifiers, or NULL if there are no free
-				 * resources. */
-              XID(*defaultAllocProc) _ANSI_ARGS_((Display *display));
-    /* Default resource allocator for display. */
-     TkIdStack *windowStackPtr;
-    /* First in list of chunks of window
-				 * identifers that can't be reused right
-				 * now. */
-    int idCleanupScheduled;	/* 1 means a call to WindowIdCleanup has
-				 * already been scheduled, 0 means it
-				 * hasn't. */
-
-    /*
-     * Information maintained by tkWindow.c for use later on by tkXId.c:
-     */
-
-
-    int destroyCount;		/* Number of Tk_DestroyWindow operations
-				 * in progress. */
-    unsigned long lastDestroyRequest;
-    /* Id of most recent XDestroyWindow request;
-				 * can re-use ids in windowStackPtr when
-				 * server has seen this request and event
-				 * queue is empty. */
-
-    /*
-     * Information used by tkVisual.c only:
-     */
-
-    TkColormap *cmapPtr;	/* First in list of all non-default colormaps
-				 * allocated for this display. */
-
-    /*
-     * Information used by tkFocus.c only:
-     */
-#if (TK_MAJOR_VERSION == 4)
-
-     TkWindow *focusWinPtr;
-				/* Window that currently has the focus for
-				 * this display, or NULL if none. */
-     TkWindow *implicitWinPtr;
-				/* If the focus arrived at a toplevel window
-				 * implicitly via an Enter event (rather
-				 * than via a FocusIn event), this points
-				 * to the toplevel window.  Otherwise it is
-				 * NULL. */
-     TkWindow *focusOnMapPtr;
-				/* This points to a toplevel window that is
-				 * supposed to receive the X input focus as
-				 * soon as it is mapped (needed to handle the
-				 * fact that X won't allow the focus on an
-				 * unmapped window).  NULL means no delayed
-				 * focus op in progress. */
-    int forceFocus;		/* Associated with focusOnMapPtr:  non-zero
-				 * means claim the focus even if some other
-				 * application currently has it. */
-#else
-     TkWindow *implicitWinPtr;
-				/* If the focus arrived at a toplevel window
-				 * implicitly via an Enter event (rather
-				 * than via a FocusIn event), this points
-				 * to the toplevel window.  Otherwise it is
-				 * NULL. */
-     TkWindow *focusPtr;	/* Points to the window on this display that
-				 * should be receiving keyboard events.  When
-				 * multiple applications on the display have
-				 * the focus, this will refer to the
-				 * innermost window in the innermost
-				 * application.  This information isn't used
-				 * under Unix or Windows, but it's needed on
-				 * the Macintosh. */
-#endif /* TK_MAJOR_VERSION == 4 */
-
-    /*
-     * Used by tkColor.c only:
-     */
-
-    TkStressedCmap *stressPtr;	/* First in list of colormaps that have
-				 * filled up, so we have to pick an
-				 * approximate color. */
-
-    /*
-     * Used by tkEvent.c only:
-     */
-
-     TkWindowEvent *delayedMotionPtr;
-				/* Points to a malloc-ed motion event
-				 * whose processing has been delayed in
-				 * the hopes that another motion event
-				 * will come along right away and we can
-				 * merge the two of them together.  NULL
-				 * means that there is no delayed motion
-				 * event. */
-    /*
-     * Miscellaneous information:
-     */
-
-#ifdef TK_USE_INPUT_METHODS
-    XIM inputMethod;		/* Input method for this display */
-#endif /* TK_USE_INPUT_METHODS */
-    Tcl_HashTable winTable;	/* Maps from X window ids to TkWindow ptrs. */
-#if (TK_MAJOR_VERSION > 4)
-    int refCount;		/* Reference count of how many Tk applications
-                                 * are using this display. Used to clean up
-                                 * the display when we no longer have any
-                                 * Tk applications using it.
-                                 */
-#endif /* TK_MAJOR_VERSION > 4 */
-
-} TkDisplay;
-
-#endif /* TK_VERSION_NUMBER >= _VERSION(8,1,0) */
-
-
-struct TkWindowStruct {
-    Display *display;
-    TkDisplay *dispPtr;
-    int screenNum;
-    Visual *visual;
-    int depth;
-    Window window;
-    TkWindow *childList;
-    TkWindow *lastChildPtr;
-    TkWindow *parentPtr;
-    TkWindow *nextPtr;
-    TkMainInfo *infoPtr;
-    char *pathName;
-    Tk_Uid nameUid;
-    Tk_Uid classUid;
-    XWindowChanges changes;
-    unsigned int dirtyChanges;
-    XSetWindowAttributes atts;
-    unsigned long dirtyAtts;
-    unsigned int flags;
-    TkEventHandler *handlerList;
-#ifdef TK_USE_INPUT_METHODS
-    XIC inputContext;
-#endif /* TK_USE_INPUT_METHODS */
-    ClientData *tagPtr;
-    int nTags;
-    int optionLevel;
-    TkSelHandler *selHandlerList;
-    Tk_GeomMgr *geomMgrPtr;
-    ClientData geomData;
-    int reqWidth, reqHeight;
-    int internalBorderWidth;
-    TkWinInfo *wmInfoPtr;
-#if (TK_MAJOR_VERSION > 4)
-    TkClassProcs *classProcsPtr;
-    ClientData instanceData;
-#endif
-    TkWindowPrivate *privatePtr;
-    int internalBorderRight;
-    int internalBorderTop;
-    int internalBorderBottom;
-
-    int minReqWidth;
-    int minReqHeight;
-
-};
-
 #ifdef WIN32
 /*
  *----------------------------------------------------------------------
--- a/generic/bltPs.c
+++ b/generic/bltPs.c
@@ -895,7 +895,7 @@
 	return;
     }
     if ((relief == TK_RELIEF_SOLID) ||
-	(borderPtr->lightColor == NULL) || (borderPtr->darkColor == NULL)) {
+	(borderPtr->lightColorPtr == NULL) || (borderPtr->darkColorPtr == NULL)) {
 	if (relief == TK_RELIEF_SOLID) {
 	    darkColor.red = darkColor.blue = darkColor.green = 0x00;
 	    lightColor.red = lightColor.blue = lightColor.green = 0x00;
@@ -903,7 +903,7 @@
 	} else {
 	    Screen *screenPtr;
 
-	    lightColor = *borderPtr->bgColor;
+	    lightColor = *borderPtr->bgColorPtr;
 	    screenPtr = Tk_Screen(tokenPtr->tkwin);
 	    if (lightColor.pixel == WhitePixelOfScreen(screenPtr)) {
 		darkColor.red = darkColor.blue = darkColor.green = 0x00;
@@ -914,8 +914,8 @@
 	lightColorPtr = &lightColor;
 	darkColorPtr = &darkColor;
     } else {
-	lightColorPtr = borderPtr->lightColor;
-	darkColorPtr = borderPtr->darkColor;
+	lightColorPtr = borderPtr->lightColorPtr;
+	darkColorPtr = borderPtr->darkColorPtr;
     }
 
 
@@ -944,7 +944,7 @@
 	topColor = darkColorPtr;
 	bottomColor = lightColorPtr;
     } else {
-	topColor = bottomColor = borderPtr->bgColor;
+	topColor = bottomColor = borderPtr->bgColorPtr;
     }
     Blt_BackgroundToPostScript(tokenPtr, bottomColor);
     Blt_RectangleToPostScript(tokenPtr, x, y + height - borderWidth, width,
@@ -984,7 +984,7 @@
      * Setting the pen color as foreground or background only affects
      * the plot when the colormode option is "monochrome".
      */
-    Blt_BackgroundToPostScript(tokenPtr, borderPtr->bgColor);
+    Blt_BackgroundToPostScript(tokenPtr, borderPtr->bgColorPtr);
     Blt_RectangleToPostScript(tokenPtr, x, y, width, height);
     Blt_Draw3DRectangleToPostScript(tokenPtr, border, x, y, width, height,
 	borderWidth, relief);
--- a/generic/bltText.c
+++ b/generic/bltText.c
@@ -903,7 +903,7 @@
 	    TkBorder *borderPtr = (TkBorder *) tsPtr->border;
 	    XColor *color1, *color2;
 
-	    color1 = borderPtr->lightColor, color2 = borderPtr->darkColor;
+	    color1 = borderPtr->lightColorPtr, color2 = borderPtr->darkColorPtr;
 	    if (tsPtr->state & STATE_EMPHASIS) {
 		XColor *hold;
 
@@ -968,7 +968,7 @@
 	TkBorder *borderPtr = (TkBorder *) tsPtr->border;
 	XColor *color1, *color2;
 
-	color1 = borderPtr->lightColor, color2 = borderPtr->darkColor;
+	color1 = borderPtr->lightColorPtr, color2 = borderPtr->darkColorPtr;
 	if (tsPtr->state & STATE_EMPHASIS) {
 	    XColor *hold;
 
--- a/generic/tkFrame.c
+++ b/generic/tkFrame.c
@@ -116,7 +116,7 @@
     int flags;			/* Various flags;  see below for
 				 * definitions. */
     Blt_Tile tile;
-} Frame;
+} bltFrame;
 
 /*
  * Flag bits for frames:
@@ -143,65 +143,65 @@
 static Tk_ConfigSpec configSpecs[] =
 {
     {TK_CONFIG_BORDER, "-background", "background", "Background",
-	DEF_FRAME_BACKGROUND, Tk_Offset(Frame, border),
+	DEF_FRAME_BACKGROUND, Tk_Offset(bltFrame, border),
 	BOTH | TK_CONFIG_COLOR_ONLY | TK_CONFIG_NULL_OK},
     {TK_CONFIG_BORDER, "-background", "background", "Background",
-	DEF_FRAME_BG_MONO, Tk_Offset(Frame, border),
+	DEF_FRAME_BG_MONO, Tk_Offset(bltFrame, border),
 	BOTH | TK_CONFIG_MONO_ONLY | TK_CONFIG_NULL_OK},
     {TK_CONFIG_SYNONYM, "-bd", "borderWidth", (char *)NULL,
 	(char *)NULL, 0, BOTH},
     {TK_CONFIG_SYNONYM, "-bg", "background", (char *)NULL,
 	(char *)NULL, 0, BOTH},
     {TK_CONFIG_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
-	DEF_FRAME_BORDERWIDTH, Tk_Offset(Frame, borderWidth), BOTH},
+	DEF_FRAME_BORDERWIDTH, Tk_Offset(bltFrame, borderWidth), BOTH},
     {TK_CONFIG_STRING, "-class", "class", "Class",
-	DEF_FRAME_CLASS, Tk_Offset(Frame, className), FRAME},
+	DEF_FRAME_CLASS, Tk_Offset(bltFrame, className), FRAME},
     {TK_CONFIG_STRING, "-class", "class", "Class",
-	DEF_TOPLEVEL_CLASS, Tk_Offset(Frame, className), TOPLEVEL},
+	DEF_TOPLEVEL_CLASS, Tk_Offset(bltFrame, className), TOPLEVEL},
     {TK_CONFIG_STRING, "-colormap", "colormap", "Colormap",
-	DEF_FRAME_COLORMAP, Tk_Offset(Frame, colormapName),
+	DEF_FRAME_COLORMAP, Tk_Offset(bltFrame, colormapName),
 	BOTH | TK_CONFIG_NULL_OK},
 #if (TK_MAJOR_VERSION > 4)
     {TK_CONFIG_BOOLEAN, "-container", "container", "Container",
-	DEF_FRAME_CONTAINER, Tk_Offset(Frame, isContainer), BOTH},
+	DEF_FRAME_CONTAINER, Tk_Offset(bltFrame, isContainer), BOTH},
 #endif /* TK_MAJOR_VERSION > 4 */
     {TK_CONFIG_ACTIVE_CURSOR, "-cursor", "cursor", "Cursor",
-	DEF_FRAME_CURSOR, Tk_Offset(Frame, cursor), BOTH | TK_CONFIG_NULL_OK},
+	DEF_FRAME_CURSOR, Tk_Offset(bltFrame, cursor), BOTH | TK_CONFIG_NULL_OK},
     {TK_CONFIG_PIXELS, "-height", "height", "Height",
-	DEF_FRAME_HEIGHT, Tk_Offset(Frame, height), BOTH},
+	DEF_FRAME_HEIGHT, Tk_Offset(bltFrame, height), BOTH},
     {TK_CONFIG_COLOR, "-highlightbackground", "highlightBackground",
 	"HighlightBackground", DEF_FRAME_HIGHLIGHT_BG,
-	Tk_Offset(Frame, highlightBgColorPtr), BOTH},
+	Tk_Offset(bltFrame, highlightBgColorPtr), BOTH},
     {TK_CONFIG_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
-	DEF_FRAME_HIGHLIGHT, Tk_Offset(Frame, highlightColorPtr), BOTH},
+	DEF_FRAME_HIGHLIGHT, Tk_Offset(bltFrame, highlightColorPtr), BOTH},
     {TK_CONFIG_PIXELS, "-highlightthickness", "highlightThickness",
 	"HighlightThickness",
-	DEF_FRAME_HIGHLIGHT_WIDTH, Tk_Offset(Frame, highlightWidth), BOTH},
+	DEF_FRAME_HIGHLIGHT_WIDTH, Tk_Offset(bltFrame, highlightWidth), BOTH},
 #if (TK_MAJOR_VERSION > 4)
     {TK_CONFIG_STRING, "-menu", "menu", "Menu",
-	DEF_TOPLEVEL_MENU, Tk_Offset(Frame, menuName),
+	DEF_TOPLEVEL_MENU, Tk_Offset(bltFrame, menuName),
 	TOPLEVEL | TK_CONFIG_NULL_OK},
 #endif /* TK_MAJOR_VERSION > 4 */
     {TK_CONFIG_RELIEF, "-relief", "relief", "Relief",
-	DEF_FRAME_RELIEF, Tk_Offset(Frame, relief), BOTH},
+	DEF_FRAME_RELIEF, Tk_Offset(bltFrame, relief), BOTH},
     {TK_CONFIG_STRING, "-screen", "screen", "Screen",
-	DEF_TOPLEVEL_SCREEN, Tk_Offset(Frame, screenName),
+	DEF_TOPLEVEL_SCREEN, Tk_Offset(bltFrame, screenName),
 	TOPLEVEL | TK_CONFIG_NULL_OK},
     {TK_CONFIG_STRING, "-takefocus", "takeFocus", "TakeFocus",
-	DEF_FRAME_TAKE_FOCUS, Tk_Offset(Frame, takeFocus),
+	DEF_FRAME_TAKE_FOCUS, Tk_Offset(bltFrame, takeFocus),
 	BOTH | TK_CONFIG_NULL_OK},
     {TK_CONFIG_CUSTOM, "-tile", "tile", "Tile",
-	(char *)NULL, Tk_Offset(Frame, tile), BOTH | TK_CONFIG_NULL_OK,
+	(char *)NULL, Tk_Offset(bltFrame, tile), BOTH | TK_CONFIG_NULL_OK,
 	&bltTileOption},
 #if (TK_MAJOR_VERSION > 4)
     {TK_CONFIG_STRING, "-use", "use", "Use",
-	DEF_FRAME_USE, Tk_Offset(Frame, useThis), TOPLEVEL|TK_CONFIG_NULL_OK},
+	DEF_FRAME_USE, Tk_Offset(bltFrame, useThis), TOPLEVEL|TK_CONFIG_NULL_OK},
 #endif
     {TK_CONFIG_STRING, "-visual", "visual", "Visual",
-	DEF_FRAME_VISUAL, Tk_Offset(Frame, visualName),
+	DEF_FRAME_VISUAL, Tk_Offset(bltFrame, visualName),
 	BOTH | TK_CONFIG_NULL_OK},
     {TK_CONFIG_PIXELS, "-width", "width", "Width",
-	DEF_FRAME_WIDTH, Tk_Offset(Frame, width), BOTH},
+	DEF_FRAME_WIDTH, Tk_Offset(bltFrame, width), BOTH},
     {TK_CONFIG_END, (char *)NULL, (char *)NULL, (char *)NULL,
 	(char *)NULL, 0, 0}
 };
@@ -211,7 +211,7 @@
  */
 
 static int ConfigureFrame _ANSI_ARGS_((Tcl_Interp *interp,
-	Frame * framePtr, int argc, char **argv,
+	bltFrame * framePtr, int argc, CONST84 char **argv,
 	int flags));
 static void DestroyFrame _ANSI_ARGS_((DestroyData *memPtr));
 static void DisplayFrame _ANSI_ARGS_((ClientData clientData));
@@ -219,27 +219,16 @@
 	ClientData clientData));
 static void FrameEventProc _ANSI_ARGS_((ClientData clientData,
 	XEvent *eventPtr));
-static int FrameWidgetCmd _ANSI_ARGS_((ClientData clientData,
-	Tcl_Interp *interp, int argc, char **argv));
 static void MapFrame _ANSI_ARGS_((ClientData clientData));
 
 static Blt_TileChangedProc TileChangedProc;
-static Tcl_CmdProc FrameCmd, ToplevelCmd;
+static Tcl_CmdProc FrameCmd, ToplevelCmd, FrameWidgetCmd;
 
-#ifdef TILE_MAINWINDOW
-EXTERN
-#else
 static
-#endif
-int TkCreateFrame _ANSI_ARGS_((ClientData clientData,
-	Tcl_Interp *interp, int argc, char **argv,
+int BltCreateFrame _ANSI_ARGS_((ClientData clientData,
+	Tcl_Interp *interp, int argc, CONST84 char **argv,
 	int toplevel, char *appName));
 
-EXTERN void TkSetWindowMenuBar _ANSI_ARGS_((Tcl_Interp *interp, Tk_Window tkwin,
-        char *oldMenuName, char *menuName));
-
-EXTERN Tk_Window TkCreateMainWindow _ANSI_ARGS_((Tcl_Interp * interp, 
-	char * screenName, char * baseName));
 #if (TK_MAJOR_VERSION == 8) && (TK_MINOR_VERSION > 3)
 #define TkSetClassProcs	Tk_SetClassProcs
 #else 
@@ -247,10 +236,10 @@
 	ClientData instanceData));
 #endif /* TK_MAJOR_VERSION == 8 && TK_MINOR_VERSION > 3 */
 
+#if (TCL_VERSION_NUMBER < _VERSION(8,6,0))
 EXTERN void TkpSetMainMenubar _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin,
 	char * menuName));
-EXTERN int TkpUseWindow _ANSI_ARGS_((Tcl_Interp * interp, Tk_Window tkwin, 
-	char * string));
+#endif
 EXTERN void TkpMakeContainer _ANSI_ARGS_((Tk_Window tkwin));
 
 
@@ -279,9 +268,9 @@
 				 * interpreter. */
     Tcl_Interp *interp;		/* Current interpreter. */
     int argc;			/* Number of arguments. */
-    char **argv;		/* Argument strings. */
+    CONST84 char **argv;		/* Argument strings. */
 {
-    return TkCreateFrame(clientData, interp, argc, argv, 0, (char *)NULL);
+    return BltCreateFrame(clientData, interp, argc, argv, 0, (char *)NULL);
 }
 
 static int
@@ -290,9 +279,9 @@
 				 * interpreter. */
     Tcl_Interp *interp;		/* Current interpreter. */
     int argc;			/* Number of arguments. */
-    char **argv;		/* Argument strings. */
+    CONST84 char **argv;		/* Argument strings. */
 {
-    return TkCreateFrame(clientData, interp, argc, argv, 1, (char *)NULL);
+    return BltCreateFrame(clientData, interp, argc, argv, 1, (char *)NULL);
 }
 
 /*
@@ -319,20 +308,20 @@
 static
 #endif /* TILE_MAINWINDOW */
 int
-TkCreateFrame(clientData, interp, argc, argv, toplevel, appName)
+BltCreateFrame(clientData, interp, argc, argv, toplevel, appName)
     ClientData clientData;	/* Main window associated with interpreter.
 				 * If we're called by Tk_Init to create a
 				 * new application, then this is NULL. */
     Tcl_Interp *interp;		/* Current interpreter. */
     int argc;			/* Number of arguments. */
-    char **argv;		/* Argument strings. */
+    CONST84 char *argv[];	/* Argument strings. */
     int toplevel;		/* Non-zero means create a toplevel window,
 				 * zero means create a frame. */
     char *appName;		/* Should only be non-NULL if clientData is
 				 * NULL:  gives the base name to use for the
 				 * new application. */
 {
-    Frame *framePtr;
+    bltFrame *framePtr;
     Tk_Window new;
     char *className, *screenName, *visualName, *colormapName, *arg, *useOption;
     int i, c, length, depth;
@@ -407,7 +396,7 @@
 	 */
 
 	if (appName == NULL) {
-	    panic("TkCreateFrame didn't get application name");
+	    panic("BltCreateFrame didn't get application name");
 	}
 	new = (Tk_Window)TkCreateMainWindow(interp, screenName, appName);
     }
@@ -467,7 +456,7 @@
      * in the widget record from the special options.
      */
 
-    framePtr = Blt_Malloc(sizeof(Frame));
+    framePtr = Blt_Malloc(sizeof(bltFrame));
     framePtr->tkwin = new;
     framePtr->display = Tk_Display(new);
     framePtr->interp = interp;
@@ -558,9 +547,9 @@
     ClientData clientData;	/* Information about frame widget. */
     Tcl_Interp *interp;		/* Current interpreter. */
     int argc;			/* Number of arguments. */
-    char **argv;		/* Argument strings. */
+    CONST84 char *argv[];		/* Argument strings. */
 {
-    register Frame *framePtr = (Frame *) clientData;
+    register bltFrame *framePtr = (bltFrame *) clientData;
     int result;
     size_t length;
     int c, i;
@@ -660,7 +649,7 @@
 DestroyFrame(memPtr)
     DestroyData *memPtr;	/* Info about frame widget. */
 {
-    register Frame *framePtr = (Frame *) memPtr;
+    register bltFrame *framePtr = (bltFrame *) memPtr;
     
     Tk_FreeOptions(configSpecs, (char *)framePtr, framePtr->display,
 	framePtr->mask);
@@ -689,7 +678,7 @@
     ClientData clientData;
     Blt_Tile tile;
 {
-    Frame *framePtr = (Frame *) clientData;
+    bltFrame *framePtr = (bltFrame *) clientData;
 
     if (framePtr->tkwin != NULL) {
 	if (!(framePtr->flags & REDRAW_PENDING)) {
@@ -723,10 +712,10 @@
 static int
 ConfigureFrame(interp, framePtr, argc, argv, flags)
     Tcl_Interp *interp;		/* Used for error reporting. */
-    register Frame *framePtr;	/* Information about widget;  may or may
+    register bltFrame *framePtr;	/* Information about widget;  may or may
 				 * not already have values for some fields. */
     int argc;			/* Number of valid entries in argv. */
-    char **argv;		/* Arguments. */
+    CONST84 char **argv;		/* Arguments. */
     int flags;			/* Flags to pass to Tk_ConfigureWidget. */
 {
 #if (TK_MAJOR_VERSION > 4)
@@ -810,7 +799,7 @@
 DisplayFrame(clientData)
     ClientData clientData;	/* Information about widget. */
 {
-    register Frame *framePtr = (Frame *) clientData;
+    register bltFrame *framePtr = (bltFrame *) clientData;
     register Tk_Window tkwin = framePtr->tkwin;
     GC gc;
 
@@ -877,7 +866,7 @@
     ClientData clientData;	/* Information about window. */
     register XEvent *eventPtr;	/* Information about event. */
 {
-    register Frame *framePtr = (Frame *) clientData;
+    register bltFrame *framePtr = (bltFrame *) clientData;
 
     if (((eventPtr->type == Expose) && (eventPtr->xexpose.count == 0))
 	|| (eventPtr->type == ConfigureNotify)) {
@@ -964,7 +953,7 @@
 FrameCmdDeletedProc(clientData)
     ClientData clientData;	/* Pointer to widget record for widget. */
 {
-    Frame *framePtr = (Frame *) clientData;
+    bltFrame *framePtr = (bltFrame *) clientData;
     Tk_Window tkwin = framePtr->tkwin;
 
 #if (TK_MAJOR_VERSION > 4)
@@ -1010,7 +999,7 @@
 MapFrame(clientData)
     ClientData clientData;	/* Pointer to frame structure. */
 {
-    Frame *framePtr = (Frame *) clientData;
+    bltFrame *framePtr = (bltFrame *) clientData;
 
     /*
      * Wait for all other background events to be processed before
@@ -1067,9 +1056,9 @@
 #define Tk_InstanceData(tkwin)	(((Tk_FakeWin *)(tkwin))->dummy18)
 #define Tk_MainPtr(tkwin)	(((Tk_FakeWin *)(tkwin))->dummy5)
     if (Tk_MainPtr(tkwin) != NULL) {
-	Frame *framePtr;
+	bltFrame *framePtr;
 
-	framePtr = (Frame *) Tk_InstanceData(tkwin);
+	framePtr = (bltFrame *) Tk_InstanceData(tkwin);
 	TkpMenuNotifyToplevelCreate(framePtr->interp, framePtr->menuName);
     }
 #endif /* TK_MAJOR_VERSION > 4 */
--- a/configure.in
+++ b/configure.in
@@ -816,6 +816,7 @@
 if test "${TK_INC_DIR}" != "/usr/include" ; then
   INC_SPECS="${INC_SPECS} -I${TK_INC_DIR}"
 fi
+INC_SPECS="${INC_SPECS} -I${TK_SRC_DIR}/generic -I${TK_SRC_DIR}/unix"
 
 # Tcl include files
 #
