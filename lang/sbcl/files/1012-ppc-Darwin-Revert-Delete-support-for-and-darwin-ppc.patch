From 320bbe69f03ef2765d7368c3c48655c12ea40eaa Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <vital.had@gmail.com>
Date: Mon, 5 Jun 2023 22:03:43 +0800
Subject: [PATCH] ppc/Darwin: Revert "Delete support for #+(and darwin ppc)"

This reverts commit 217791a738a5960092e38106e9931c424cd4ee98.
---
 src/code/alieneval.lisp                   |   2 +-
 src/code/float-trap.lisp                  |   2 +
 src/code/ppc-vm.lisp                      |   3 +-
 src/compiler/ppc/c-call.lisp              | 282 +++++++++++++++++++++-
 src/compiler/ppc/float.lisp               |  65 +++++
 src/compiler/ppc/parms.lisp               |   3 +-
 src/compiler/ppc/vm.lisp                  |  12 +-
 src/runtime/Config.ppc-darwin             |  41 ++++
 src/runtime/monitor.c                     |   4 +
 src/runtime/ppc-arch.c                    |   2 +
 src/runtime/ppc-assem.S                   | 165 +++++++++++++
 src/runtime/ppc-darwin-os.c               | 142 +++++++++++
 src/runtime/ppc-darwin-os.h               |  29 +++
 src/runtime/ppc-lispregs.h                |  15 ++
 src/runtime/ppc64-lispregs.h              |  10 +
 tests/float.pure.lisp                     |   2 +
 tests/foreign-stack-alignment.impure.lisp |   3 +-
 tests/test-funs.lisp                      |   2 +-
 18 files changed, 773 insertions(+), 11 deletions(-)
 create mode 100644 src/runtime/Config.ppc-darwin
 create mode 100644 src/runtime/ppc-darwin-os.c
 create mode 100644 src/runtime/ppc-darwin-os.h

diff --git src/code/alieneval.lisp src/code/alieneval.lisp
index 4946312c4..3df3c6ac9 100644
--- src/code/alieneval.lisp
+++ src/code/alieneval.lisp
@@ -25,7 +25,7 @@
 
 (defun guess-alignment (bits)
   (cond ((null bits) nil)
-        #-(and x86 (not win32)) ((> bits 32) 64)
+        #-(or (and x86 (not win32)) (and ppc darwin)) ((> bits 32) 64)
         ((> bits 16) 32)
         ((> bits 8) 16)
         ((> bits 1) 8)
diff --git src/code/float-trap.lisp src/code/float-trap.lisp
index 1a634d9f6..95355c0df 100644
--- src/code/float-trap.lisp
+++ src/code/float-trap.lisp
@@ -117,6 +117,8 @@ in effect."
       (setf (ldb float-precision-control modes)
             (or (cdr (assoc precision +precision-mode-alist+))
                 (error "unknown precision mode: ~S" precision))))
+    ;; FIXME: This apparently doesn't work on Darwin
+    #-(and darwin ppc)
     (setf (floating-point-modes) modes))
   (values))
 
diff --git src/code/ppc-vm.lisp src/code/ppc-vm.lisp
index 4783c0d00..30ba89b09 100644
--- src/code/ppc-vm.lisp
+++ src/code/ppc-vm.lisp
@@ -46,7 +46,8 @@
 ;;; Given a signal context, return the floating point modes word in
 ;;; the same format as returned by FLOATING-POINT-MODES.
 ;;;
-;;; FIXME: surely this must be accessible somewhere under *BSD?
+;;; FIXME: surely this must be accessible somewhere under Darwin?  Or
+;;; under NetBSD?
 #+linux
 (define-alien-routine ("os_context_fp_control" context-floating-point-modes)
     (unsigned 32)
diff --git src/compiler/ppc/c-call.lisp src/compiler/ppc/c-call.lisp
index 464ce441e..b2bf4ecdb 100644
--- src/compiler/ppc/c-call.lisp
+++ src/compiler/ppc/c-call.lisp
@@ -19,14 +19,19 @@
 
 (defconstant +stack-alignment-bytes+
   ;; Duh.  PPC Linux (and VxWorks) adhere to the EABI.
-  7)
+  #-darwin 7
+  ;; But Darwin doesn't
+  #+darwin 15)
 
 (defstruct arg-state
   (gpr-args 0)
   (fpr-args 0)
   ;; SVR4 [a]abi wants two words on stack (callee saved lr,
   ;; backpointer).
-  (stack-frame-size 2))
+  #-darwin (stack-frame-size 2)
+  ;; PowerOpen ABI wants 8 words on the stack corresponding to GPR3-10
+  ;; in addition to the 6 words of link area (see number-stack-displacement)
+  #+darwin (stack-frame-size (+ 8 6)))
 
 (defun int-arg (state prim-type reg-sc stack-sc)
   (let ((reg-args (arg-state-gpr-args state)))
@@ -57,6 +62,7 @@
 ;;;   Excess floats stored on the stack are stored as floats.
 ;;;
 ;;; We follow gcc.
+#-darwin
 (define-alien-type-method (single-float :arg-tn) (type state)
   (declare (ignore type))
   (let* ((fprs (arg-state-fpr-args state)))
@@ -69,6 +75,31 @@
              (setf (arg-state-stack-frame-size state) (+ stack-offset 1))
              (make-wired-tn* 'single-float single-stack-sc-number stack-offset))))))
 
+;;; If a single-float arg has to go on the stack, it's promoted to
+;;; double.  That way, C programs can get subtle rounding errors when
+;;; unrelated arguments are introduced.
+#+darwin
+(define-alien-type-method (single-float :arg-tn) (type state)
+  (declare (ignore type))
+  (let* ((fprs (arg-state-fpr-args state))
+         (gprs (arg-state-gpr-args state)))
+    (cond ((< gprs 8) ; and by implication also (< fprs 13)
+           (incf (arg-state-fpr-args state))
+           ;; Assign outgoing FPRs starting at FP1
+           (list (make-wired-tn* 'single-float single-reg-sc-number (1+ fprs))
+                 (int-arg state 'signed-byte-32 signed-reg-sc-number signed-stack-sc-number)))
+          ((< fprs 13)
+           ;; See comments below for double-float.
+           (incf (arg-state-fpr-args state))
+           (incf (arg-state-stack-frame-size state))
+           (make-wired-tn* 'single-float single-reg-sc-number (1+ fprs)))
+          (t
+           ;; Pass on stack only
+           (let ((stack-offset (arg-state-stack-frame-size state)))
+             (incf (arg-state-stack-frame-size state))
+             (make-wired-tn* 'single-float single-stack-sc-number stack-offset))))))
+
+#-darwin
 (define-alien-type-method (double-float :arg-tn) (type state)
   (declare (ignore type))
   (let* ((fprs (arg-state-fpr-args state)))
@@ -83,6 +114,35 @@
              (setf (arg-state-stack-frame-size state) (+ stack-offset 2))
              (make-wired-tn* 'double-float double-stack-sc-number stack-offset))))))
 
+#+darwin
+(define-alien-type-method (double-float :arg-tn) (type state)
+  (declare (ignore type))
+  (let ((fprs (arg-state-fpr-args state))
+        (gprs (arg-state-gpr-args state)))
+    (cond ((< gprs 8) ; and by implication also (< fprs 13)
+           (incf (arg-state-fpr-args state))
+           ;; Assign outgoing FPRs starting at FP1
+           ;;
+           ;; The PowerOpen ABI says float values are stored in float
+           ;; regs.  But if we're calling a varargs function, we also
+           ;; need to put the float into some gprs.  We indicate this
+           ;; to %alien-funcall ir2-convert by making a list of the
+           ;; TNs for the float reg and for the int regs.
+           ;;
+           (list (make-wired-tn* 'double-float double-reg-sc-number (1+ fprs))
+                 (int-arg state 'signed-byte-32 signed-reg-sc-number signed-stack-sc-number)
+                 (int-arg state 'unsigned-byte-32 unsigned-reg-sc-number unsigned-stack-sc-number)))
+          ((< fprs 13)
+           (incf (arg-state-fpr-args state))
+           (list (make-wired-tn* 'double-float double-reg-sc-number (1+ fprs))
+                 (int-arg state 'signed-byte-32 signed-reg-sc-number signed-stack-sc-number)
+                 (int-arg state 'unsigned-byte-32 unsigned-reg-sc-number unsigned-stack-sc-number)))
+          (t
+           ;; Pass on stack only
+           (let ((stack-offset (arg-state-stack-frame-size state)))
+             (incf (arg-state-stack-frame-size state) 2)
+             (make-wired-tn* 'double-float double-stack-sc-number stack-offset))))))
+
 ;;; Result state handling
 
 (defstruct result-state
@@ -93,6 +153,11 @@
     (0 nl0-offset)
     (1 nl1-offset)))
 
+;;; FIXME: These #-DARWIN methods should be adjusted to take a state
+;;; argument, firstly because that's our "official" API (see
+;;; src/code/host-alieneval) and secondly because that way we can
+;;; probably have less duplication of code.  -- CSR, 2003-07-29
+
 (define-alien-type-method (system-area-pointer :result-tn) (type state)
   (declare (ignore type))
   (let ((num-results (result-state-num-results state)))
@@ -143,6 +208,7 @@
 ;;; Sort out long longs, by splitting them up.  However, need to take
 ;;; care about register/stack alignment and whether they will fully
 ;;; fit into registers or must go on the stack.
+#-darwin
 (deftransform %alien-funcall ((function type &rest args))
   (aver (sb-c:constant-lvar-p type))
   (let* ((type (sb-c:lvar-value type))
@@ -238,6 +304,67 @@
                            ,@(new-args))))))
         (sb-c::give-up-ir1-transform))))
 
+#+darwin
+(deftransform %alien-funcall ((function type &rest args))
+  (aver (sb-c:constant-lvar-p type))
+  (let* ((type (sb-c:lvar-value type))
+         (arg-types (alien-fun-type-arg-types type))
+         (result-type (alien-fun-type-result-type type)))
+    (aver (= (length arg-types) (length args)))
+    ;; We need to do something special for 64-bit integer arguments
+    ;; and results.
+    (if (or (some #'(lambda (type)
+                      (and (alien-integer-type-p type)
+                           (> (sb-alien::alien-integer-type-bits type) 32)))
+                  arg-types)
+            (and (alien-integer-type-p result-type)
+                 (> (sb-alien::alien-integer-type-bits result-type) 32)))
+        (collect ((new-args) (lambda-vars) (new-arg-types))
+                 (dolist (type arg-types)
+                   (let ((arg (gensym)))
+                     (lambda-vars arg)
+                     (cond ((and (alien-integer-type-p type)
+                                 (> (sb-alien::alien-integer-type-bits type) 32))
+                            ;; 64-bit long long types are stored in
+                            ;; consecutive locations, most significant word
+                            ;; first (big-endian).
+                            (new-args `(ash ,arg -32))
+                            (new-args `(logand ,arg #xffffffff))
+                            (if (alien-integer-type-signed type)
+                                (new-arg-types (parse-alien-type '(signed 32) nil))
+                                (new-arg-types (parse-alien-type '(unsigned 32) nil)))
+                            (new-arg-types (parse-alien-type '(unsigned 32) nil)))
+                           (t
+                            (new-args arg)
+                            (new-arg-types type)))))
+                 (cond ((and (alien-integer-type-p result-type)
+                             (> (sb-alien::alien-integer-type-bits result-type) 32))
+                        (let ((new-result-type
+                               (let ((sb-alien::*values-type-okay* t))
+                                 (parse-alien-type
+                                  (if (alien-integer-type-signed result-type)
+                                      '(values (signed 32) (unsigned 32))
+                                      '(values (unsigned 32) (unsigned 32)))
+                                  nil))))
+                          `(lambda (function type ,@(lambda-vars))
+                            (declare (ignore type))
+                            (multiple-value-bind (high low)
+                                (%alien-funcall function
+                                                ',(make-alien-fun-type
+                                                   :arg-types (new-arg-types)
+                                                   :result-type new-result-type)
+                                                ,@(new-args))
+                              (logior low (ash high 32))))))
+                       (t
+                        `(lambda (function type ,@(lambda-vars))
+                          (declare (ignore type))
+                          (%alien-funcall function
+                           ',(make-alien-fun-type
+                              :arg-types (new-arg-types)
+                              :result-type result-type)
+                           ,@(new-args))))))
+        (sb-c::give-up-ir1-transform))))
+
 (define-vop (foreign-symbol-sap)
   (:translate foreign-symbol-sap)
   (:policy :fast-safe)
@@ -341,12 +468,20 @@
             (t
              `(deref (sap-alien (sap+ ,sap ,offset) (* ,type)))))))
 
+  ;;; The "Mach-O Runtime Conventions" document for OS X almost
+  ;;; specifies the calling convention (it neglects to mention that
+  ;;; the linkage area is 24 bytes).
+  #+darwin
+  (defconstant n-foreign-linkage-area-bytes 24)
+
   ;;; On linux only use 8 bytes for LR and Back chain.  JRXR
   ;;; 2006/11/10.
+  #-darwin
   (defconstant n-foreign-linkage-area-bytes 8)
 
   ;;; Returns a vector in static space containing machine code for the
   ;;; callback wrapper.  Linux version.  JRXR.  2006/11/13
+  #-darwin
   (defun alien-callback-assembler-wrapper (index result-type argument-types)
     (flet ((make-gpr (n)
              (make-random-tn :kind :normal :sc (sc-or-lose 'any-reg) :offset n))
@@ -561,4 +696,145 @@
                                             unsigned-long))
            sap (length buffer))
           vector))))
-)
+
+  ;;; Returns a vector in static space containing machine code for the
+  ;;; callback wrapper
+  #+darwin
+  (defun alien-callback-assembler-wrapper (index result-type argument-types)
+    (flet ((make-gpr (n)
+             (make-random-tn :kind :normal :sc (sc-or-lose 'any-reg) :offset n))
+           (make-fpr (n)
+             (make-random-tn :kind :normal :sc (sc-or-lose 'double-reg) :offset n)))
+      (let* ((segment (make-segment)))
+        (assemble (segment)
+          ;; To save our arguments, we follow the algorithm sketched in the
+          ;; "PowerPC Calling Conventions" section of that document.
+          ;;
+          ;; CLH: There are a couple problems here. First, we bail if
+          ;; we run out of registers. AIUI, we can just ignore the extra
+          ;; args here and we will be ok...
+          (let ((words-processed 0)
+                (gprs (mapcar #'make-gpr '(3 4 5 6 7 8 9 10)))
+                (fprs (mapcar #'make-fpr '(1 2 3 4 5 6 7 8 9 10 11 12 13)))
+                (stack-pointer (make-gpr 1)))
+            (labels ((save-arg (type words)
+                       (let ((integerp (not (alien-float-type-p type)))
+                             (offset (+ (* words-processed n-word-bytes)
+                                        n-foreign-linkage-area-bytes)))
+                         (cond (integerp
+                                (dotimes (k words)
+                                  (let ((gpr (pop gprs)))
+                                    (when gpr
+                                      (inst stw gpr stack-pointer offset))
+                                    (incf words-processed)
+                                    (incf offset n-word-bytes))))
+                               ;; The handling of floats is a little ugly
+                               ;; because we hard-code the number of words
+                               ;; for single- and double-floats.
+                               ((alien-single-float-type-p type)
+                                (pop gprs)
+                                (let ((fpr (pop fprs)))
+                                  (when fpr
+                                    (inst stfs fpr stack-pointer offset)))
+                                (incf words-processed))
+                               ((alien-double-float-type-p type)
+                                (setf gprs (cddr gprs))
+                                (let ((fpr (pop fprs)))
+                                  (when fpr
+                                    (inst stfd fpr stack-pointer offset)))
+                                (incf words-processed 2))
+                               (t
+                                (bug "Unknown alien floating point type: ~S" type))))))
+              (mapc #'save-arg
+                    argument-types
+                    (mapcar (lambda (arg)
+                              (ceiling (alien-type-bits arg) n-word-bits))
+                            argument-types))))
+          ;; Set aside room for the return area just below sp, then
+          ;; actually call funcall3: funcall3 (call-alien-function,
+          ;; index, args, return-area)
+          ;;
+          ;; INDEX is fixnumized, ARGS and RETURN-AREA don't need to be
+          ;; because they're word-aligned. Kinda gross, but hey ...
+          (let* ((n-return-area-words
+                  (ceiling (or (alien-type-bits result-type) 0) n-word-bits))
+                 (n-return-area-bytes (* n-return-area-words n-word-bytes))
+                 ;; FIXME: magic constant, and probably n-args-bytes
+                 (args-size (* 3 n-word-bytes))
+                 ;; FIXME: n-frame-bytes?
+                 (frame-size (logandc2 (+ n-foreign-linkage-area-bytes
+                                          n-return-area-bytes
+                                          args-size
+                                          +stack-alignment-bytes+)
+                                       +stack-alignment-bytes+)))
+            (destructuring-bind (sp r0 arg1 arg2 arg3 arg4)
+                (mapcar #'make-gpr '(1 0 3 4 5 6))
+              ;; FIXME: This is essentially the same code as LR in
+              ;; insts.lisp, but attempting to use (INST LR ...) instead
+              ;; of this function results in callbacks not working.  Why?
+              ;;   --njf, 2006-01-04
+              (flet ((load-address-into (reg addr)
+                       (let ((high (ldb (byte 16 16) addr))
+                             (low (ldb (byte 16 0) addr)))
+                         (inst lis reg high)
+                         (inst ori reg reg low))))
+                ;; Setup the args
+                (load-address-into arg1 (static-fdefn-fun-addr 'enter-alien-callback))
+                (loadw arg1 arg1)
+                (inst li arg2 (fixnumize index))
+                (inst addi arg3 sp n-foreign-linkage-area-bytes)
+                ;; FIXME: This was (- (* RETURN-AREA-SIZE N-WORD-BYTES)), while
+                ;; RETURN-AREA-SIZE was (* N-RETURN-AREA-WORDS N-WORD-BYTES):
+                ;; I assume the intention was (- N-RETURN-AREA-BYTES), but who knows?
+                ;; --NS 2005-06-11
+                (inst addi arg4 sp (- n-return-area-bytes))
+                ;; FIXME! FIXME FIXME: What does this FIXME refer to?
+                ;; Save sp, setup the frame
+                (inst mflr r0)
+                (inst stw r0 sp (* 2 n-word-bytes)) ; FIXME: magic constant
+                (inst stwu sp sp (- frame-size))
+                ;; Make the call
+                (load-address-into r0 (foreign-symbol-address "funcall3"))
+                (inst mtlr r0)
+                (inst blrl))
+              ;; We're back!  Restore sp and lr, load the return value from just
+              ;; under sp, and return.
+              (inst lwz sp sp 0)
+              (inst lwz r0 sp (* 2 n-word-bytes))
+              (inst mtlr r0)
+              (cond
+                ((sb-alien::alien-single-float-type-p result-type)
+                 (let ((f1 (make-fpr 1)))
+                   (inst lfs f1 sp (- (* n-return-area-words n-word-bytes)))))
+                ((sb-alien::alien-double-float-type-p result-type)
+                 (let ((f1 (make-fpr 1)))
+                   (inst lfd f1 sp (- (* n-return-area-words n-word-bytes)))))
+                ((sb-alien::alien-void-type-p result-type)
+                 ;; Nothing to do
+                 )
+                (t
+                 (loop with gprs = (mapcar #'make-gpr '(3 4))
+                    repeat n-return-area-words
+                    for gpr = (pop gprs)
+                    for offset from (- (* n-return-area-words n-word-bytes))
+                    by n-word-bytes
+                    do
+                      (unless gpr
+                        (bug "Out of return registers in alien-callback trampoline."))
+                      (inst lwz gpr sp offset))))
+              (inst blr))))
+        (finalize-segment segment)
+        ;; Now that the segment is done, convert it to a static
+        ;; vector we can point foreign code to.
+        (let* ((buffer (sb-assem:segment-buffer segment))
+               (vector (make-static-vector (length buffer)
+                                           :element-type '(unsigned-byte 8)
+                                           :initial-contents buffer))
+               (sap (vector-sap vector)))
+          (alien-funcall
+           (extern-alien "ppc_flush_icache"
+                         (function void
+                                   system-area-pointer
+                                   unsigned-long))
+           sap (length buffer))
+          vector)))))
diff --git src/compiler/ppc/float.lisp src/compiler/ppc/float.lisp
index 28a6d2e90..91ddfab72 100644
--- src/compiler/ppc/float.lisp
+++ src/compiler/ppc/float.lisp
@@ -849,3 +849,68 @@
   (:translate imagpart)
   (:note "complex double float imagpart")
   (:variant :imag))
+
+;; This vop and the next are intended to be used only for moving a
+;; float to an integer arg location (register or stack) for C callout.
+;; See %alien-funcall ir2convert in aliencomp.lisp.
+
+#+darwin
+(define-vop (move-double-to-int-arg)
+  (:args (float :scs (double-reg)))
+  (:results (hi-bits :scs (signed-reg signed-stack))
+            (lo-bits :scs (unsigned-reg unsigned-stack)))
+  (:temporary (:scs (double-stack)) stack-temp)
+  (:temporary (:scs (signed-reg)) temp)
+  (:arg-types double-float)
+  (:result-types signed-num unsigned-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 5
+    (sc-case float
+      (double-reg
+       (inst stfd float (current-nfp-tn vop)
+             (tn-byte-offset stack-temp))
+       (sc-case hi-bits
+         (signed-reg
+          (inst lwz hi-bits (current-nfp-tn vop)
+                (tn-byte-offset stack-temp)))
+         (signed-stack
+          (inst lwz temp (current-nfp-tn vop)
+                (tn-byte-offset stack-temp))
+          (inst stw temp nsp-tn
+                (tn-byte-offset hi-bits))))
+       (sc-case lo-bits
+         (unsigned-reg
+          (inst lwz lo-bits (current-nfp-tn vop)
+                (* (1+ (tn-offset stack-temp)) n-word-bytes)))
+         (unsigned-stack
+          (inst lwz temp (current-nfp-tn vop)
+                (* (1+ (tn-offset stack-temp)) n-word-bytes))
+          (inst stw temp nsp-tn
+                (tn-byte-offset lo-bits))))))))
+
+#+darwin
+(define-vop (move-single-to-int-arg)
+  (:args (float :scs (single-reg)))
+  (:results (bits :scs (signed-reg signed-stack)))
+  (:temporary (:scs (double-stack)) stack-temp)
+  (:temporary (:scs (signed-reg)) temp)
+  (:arg-types single-float)
+  (:result-types signed-num)
+  (:policy :fast-safe)
+  (:vop-var vop)
+  (:generator 5
+    (sc-case float
+      (single-reg
+       (inst stfs float (current-nfp-tn vop)
+             (tn-byte-offset stack-temp))
+       (sc-case bits
+         (signed-reg
+          (inst lwz bits (current-nfp-tn vop)
+                (tn-byte-offset stack-temp)))
+         (signed-stack
+          (inst lwz temp (current-nfp-tn vop)
+                (tn-byte-offset stack-temp))
+          (inst stw temp nsp-tn
+                (tn-byte-offset bits))))))))
+
diff --git src/compiler/ppc/parms.lisp src/compiler/ppc/parms.lisp
index d2881fd5a..916c6e345 100644
--- src/compiler/ppc/parms.lisp
+++ src/compiler/ppc/parms.lisp
@@ -90,7 +90,8 @@
                      :dynamic-space-start
                      #+linux   #x4f000000
                      #+netbsd  #x4f000000
-                     #+openbsd #x4f000000)
+                     #+openbsd #x4f000000
+                     #+darwin  #x10000000)
 
 (defconstant alien-linkage-table-growth-direction :up)
 (defconstant alien-linkage-table-entry-size 16)
diff --git src/compiler/ppc/vm.lisp src/compiler/ppc/vm.lisp
index f85968b53..0163f16cd 100644
--- src/compiler/ppc/vm.lisp
+++ src/compiler/ppc/vm.lisp
@@ -20,7 +20,8 @@
 ;;; work. This must be a power of 2 - see BYTES-REQUIRED-FOR-NUMBER-STACK.
 ;;;
 (defconstant number-stack-displacement
-  (* 2
+  (* #-darwin 2
+     #+darwin 8
      n-word-bytes))
 
 ;;;; Define the registers
@@ -52,8 +53,13 @@
   (defreg nl6 9)
   (defreg fdefn 10)
   (defreg nargs 11)
-  (defreg nfp 12)
-  (defreg cfunc 13)
+  ;; FIXME: some kind of comment here would be nice.
+  ;;
+  ;; FIXME II: this also reveals the need to autogenerate lispregs.h
+  #+darwin  (defreg cfunc 12)
+  #-darwin  (defreg nfp 12)
+  #+darwin  (defreg nfp 13)
+  #-darwin  (defreg cfunc 13)
   (defreg bsp 14)
   (defreg cfp 15)
   (defreg csp 16)
diff --git src/runtime/Config.ppc-darwin src/runtime/Config.ppc-darwin
new file mode 100644
index 000000000..b34a07236
--- /dev/null
+++ src/runtime/Config.ppc-darwin
@@ -0,0 +1,41 @@
+# -*- makefile -*- for the C-level run-time support for SBCL
+
+# This software is part of the SBCL system. See the README file for
+# more information.
+#
+# This software is derived from the CMU CL system, which was
+# written at Carnegie Mellon University and released into the
+# public domain. The software is in the public domain and is
+# provided with absolutely no warranty. See the COPYING and CREDITS
+# files for more information.
+
+CFLAGS = -g -Wall -O2 -fdollars-in-identifiers -mmacosx-version-min=10.4
+LINKFLAGS += -mmacosx-version-min=10.4
+
+OS_SRC = bsd-os.c darwin-os.c ppc-darwin-os.c
+
+OS_LIBS = -lSystem -lc
+ifdef LISP_FEATURE_SB_CORE_COMPRESSION
+  OS_LIBS += -lz
+endif
+
+CC = gcc
+
+ASSEM_SRC = ppc-assem.S
+ARCH_SRC = ppc-arch.c
+
+CPPFLAGS += -no-cpp-precomp
+
+ifdef LISP_FEATURE_GENCGC
+  GC_SRC = fullcgc.c gencgc.c traceroot.c
+endif
+
+ifdef LISP_FEATURE_SB_LINKABLE_RUNTIME
+  LIBSBCL = libsbcl.a
+  USE_LIBSBCL = -Wl,-force_load libsbcl.a
+endif
+
+.PHONY: after-grovel-headers
+
+# Nothing to do.
+after-grovel-headers:
diff --git src/runtime/monitor.c src/runtime/monitor.c
index a768fe51e..1c9857db7 100644
--- src/runtime/monitor.c
+++ src/runtime/monitor.c
@@ -640,6 +640,10 @@ print_context(os_context_t *context)
         brief_print((lispobj)(*os_context_register_addr(context,i)));
 
     }
+#if defined(LISP_FEATURE_DARWIN) && defined(LISP_FEATURE_PPC)
+    printf("DAR:\t\t 0x%08lx\n", (unsigned long)(*os_context_register_addr(context, 41)));
+    printf("DSISR:\t\t 0x%08lx\n", (unsigned long)(*os_context_register_addr(context, 42)));
+#endif
 #ifndef REG_PC
     printf("PC:\t\t  0x%08lx\n", (unsigned long)os_context_pc(context));
 #endif
diff --git src/runtime/ppc-arch.c src/runtime/ppc-arch.c
index 757997f09..a7624c00c 100644
--- src/runtime/ppc-arch.c
+++ src/runtime/ppc-arch.c
@@ -46,8 +46,10 @@
 
      Caveat callers.  */
 
+#if defined (LISP_FEATURE_DARWIN) || defined(LISP_FEATURE_LINUX)
 #ifndef PT_DAR
 #define PT_DAR          41
+#endif
 
 #ifndef PT_DSISR
 #define PT_DSISR        42
diff --git src/runtime/ppc-assem.S src/runtime/ppc-assem.S
index 342952dc0..982c4e7e9 100644
--- src/runtime/ppc-assem.S
+++ src/runtime/ppc-assem.S
@@ -16,8 +16,20 @@
 #include "genesis/static-symbols.h"
 #include "genesis/thread.h"
 
+#ifdef LISP_FEATURE_DARWIN
+#define CSYMBOL(x) _ ## x
+#else
 #define CSYMBOL(x) x
+#endif
+
+#if defined LISP_FEATURE_DARWIN
+#define FUNCDEF(x)	.text @ \
+			.align 3 @ \
+_##x:
 
+#define GFUNCDEF(x)	.globl _ ## x @ \
+	FUNCDEF(x)
+#else
 #define FUNCDEF(x)	.text ; \
 			.align 3 ; \
 			.type x,@function ; \
@@ -25,23 +37,52 @@ x:
 
 #define GFUNCDEF(x)	.globl x ; \
 	FUNCDEF(x)
+#endif
 
+#if defined LISP_FEATURE_DARWIN
+#define SET_SIZE(x)
+#else
 #define SET_SIZE(x) .size x,.-x
+#endif
 
 /* Load a register from a global, using the register as an intermediary */
 /* The register will be a fixnum for one instruction, so this is gc-safe */
 
+#if defined LISP_FEATURE_DARWIN
+#define load(reg,global) \
+	lis reg,ha16(global) @ \
+	lwz reg,lo16(global)(reg) ; Comment
+#define store(reg,temp,global) \
+	lis temp,ha16(global) @\
+	stw reg,lo16(global)(temp) ; Comment
+#else
 #define load(reg,global) \
 	lis reg,global@ha; lwz reg,global@l(reg)
 #define store(reg,temp,global) \
 	lis temp,global@ha; stw reg,global@l(temp)
+#endif
 
 #define	FIRST_SAVE_FPR	14	/* lowest-numbered non-volatile FPR */
+#ifdef LISP_FEATURE_DARWIN
+#define	FIRST_SAVE_GPR	13	/* lowest-numbered non-volatile GPR */
+#define NGPR_SAVE_BYTES(n) ((32-(n))*4)
+#define FRAME_ARG_BYTES(n)  (((((n)+6)*4)+15)&~15)
+#else
 #define	FIRST_SAVE_GPR	14	/* lowest-numbered non-volatile GPR */
 #define NGPR_SAVE_BYTES(n) ((32-(~1&((n)+1)))*4)
 #define FRAME_ARG_BYTES(n)  (((((n)+2)*4)+15)&~15)
+#endif
 #define	NFPR_SAVE_BYTES(n) ((32-(n))*8)
 
+#ifdef LISP_FEATURE_DARWIN
+#define FRAME_SIZE(first_g,first_f,out_arg_words,savecr) \
+(NFPR_SAVE_BYTES(first_f)+ NGPR_SAVE_BYTES(first_g)+ FRAME_ARG_BYTES(out_arg_words))
+#define SAVE_FPR(n) stfd f##n,-8*(32- n)(r11)
+#define SAVE_GPR(n) stw r##n,-4*(32- n)(r11)
+#define FULL_FRAME_SIZE (FRAME_SIZE(FIRST_SAVE_GPR,FIRST_SAVE_FPR,8,1)+15&~15)
+#define RESTORE_FPR(n) lfd f##n,-8*(32- n)(r11)
+#define RESTORE_GPR(n) lwz r##n,-4*(32- n)(r11)
+#else
 #define FRAME_SIZE(first_g,first_f,out_arg_words,savecr) \
 (NFPR_SAVE_BYTES(first_f)+ NGPR_SAVE_BYTES(first_g)+ FRAME_ARG_BYTES(out_arg_words+savecr))
 #define SAVE_FPR(n) stfd n,-8*(32-(n))(11)
@@ -50,6 +91,105 @@ x:
 
 #define RESTORE_FPR(n) lfd n,-8*(32-(n))(11)
 #define RESTORE_GPR(n) lwz n,-4*(32-(n))(11)
+#endif
+
+#ifdef LISP_FEATURE_DARWIN
+#define C_FULL_PROLOG \
+	nop @\
+	nop @ \
+	mfcr REG(0) @ \
+	stw REG(0),4(REG(1)) @ \
+	mflr REG(0) @ \
+	stw REG(0),8(REG(1)) @ \
+	mr REG(11),REG(1) @ \
+	stwu REG(1),-FULL_FRAME_SIZE(REG(1)) @ \
+	SAVE_FPR(14) @ \
+	SAVE_FPR(15) @ \
+	SAVE_FPR(16) @ \
+	SAVE_FPR(17) @ \
+	SAVE_FPR(18) @ \
+	SAVE_FPR(19) @ \
+	SAVE_FPR(20) @ \
+	SAVE_FPR(21) @ \
+	SAVE_FPR(22) @ \
+	SAVE_FPR(23) @ \
+	SAVE_FPR(24) @ \
+	SAVE_FPR(25) @ \
+	SAVE_FPR(26) @ \
+	SAVE_FPR(27) @ \
+	SAVE_FPR(28) @ \
+	SAVE_FPR(29) @ \
+	SAVE_FPR(30) @ \
+	SAVE_FPR(31) @ \
+	la REG(11),-NFPR_SAVE_BYTES(FIRST_SAVE_FPR)(REG(11)) @ \
+	SAVE_GPR(13) @ \
+	SAVE_GPR(14) @ \
+	SAVE_GPR(15) @ \
+	SAVE_GPR(16) @ \
+	SAVE_GPR(17) @ \
+	SAVE_GPR(18) @ \
+	SAVE_GPR(19) @ \
+	SAVE_GPR(20) @ \
+	SAVE_GPR(21) @ \
+	SAVE_GPR(22) @ \
+	SAVE_GPR(23) @ \
+	SAVE_GPR(24) @ \
+	SAVE_GPR(25) @ \
+	SAVE_GPR(26) @ \
+	SAVE_GPR(27) @ \
+	SAVE_GPR(28) @ \
+	SAVE_GPR(29) @ \
+	SAVE_GPR(30) @ \
+	SAVE_GPR(31)
+
+
+#define C_FULL_EPILOG \
+	la REG(11),FULL_FRAME_SIZE-NFPR_SAVE_BYTES(FIRST_SAVE_FPR)(REG(1)) @ \
+	RESTORE_GPR(13) @ \
+	RESTORE_GPR(14) @ \
+	RESTORE_GPR(15) @ \
+	RESTORE_GPR(16) @ \
+	RESTORE_GPR(17) @ \
+	RESTORE_GPR(18) @ \
+	RESTORE_GPR(19) @ \
+	RESTORE_GPR(20) @ \
+	RESTORE_GPR(21) @ \
+	RESTORE_GPR(22) @ \
+	RESTORE_GPR(23) @ \
+	RESTORE_GPR(24) @ \
+	RESTORE_GPR(25) @ \
+	RESTORE_GPR(26) @ \
+	RESTORE_GPR(27) @ \
+	RESTORE_GPR(28) @ \
+	RESTORE_GPR(29) @ \
+	RESTORE_GPR(30) @ \
+	RESTORE_GPR(31) @ \
+	la REG(11),NFPR_SAVE_BYTES(FIRST_SAVE_FPR)(REG(11)) @ \
+	RESTORE_FPR(14) @ \
+	RESTORE_FPR(15) @ \
+	RESTORE_FPR(16) @ \
+	RESTORE_FPR(17) @ \
+	RESTORE_FPR(18) @ \
+	RESTORE_FPR(19) @ \
+	RESTORE_FPR(20) @ \
+	RESTORE_FPR(21) @ \
+	RESTORE_FPR(22) @ \
+	RESTORE_FPR(23) @ \
+	RESTORE_FPR(24) @ \
+	RESTORE_FPR(25) @ \
+	RESTORE_FPR(26) @ \
+	RESTORE_FPR(27) @ \
+	RESTORE_FPR(28) @ \
+	RESTORE_FPR(29) @ \
+	RESTORE_FPR(30) @ \
+	RESTORE_FPR(31) @ \
+	lwz REG(1),0(REG(1)) @ \
+	lwz REG(0),4(REG(1)) @ \
+	mtcr REG(0) @ \
+	lwz REG(0),8(REG(1)) @ \
+	mtlr REG(0) @ \
+
+#else
 
 #define C_FULL_PROLOG \
 	mflr 0 ; \
@@ -141,6 +281,8 @@ x:
 	lwz 0,4(1) ; \
 	mtlr 0 ; \
 
+#endif
+
 #define BEGIN_PSEUDO_ATOMIC stb reg_NULL,THREAD_PSEUDO_ATOMIC_BITS_OFFSET(reg_THREAD)
 #define END_PSEUDO_ATOMIC \
 	stb reg_THREAD, THREAD_PSEUDO_ATOMIC_BITS_OFFSET(reg_THREAD) ; \
@@ -198,6 +340,9 @@ x:
 
 	/* Call out to obtain our TLS block. */
 	load(reg_NL0,CSYMBOL(current_thread))
+	/* This won't work on darwin: wrong fixup style.  And is it
+	 * supposed to be lis/ori or lis/addi?  Or does it differ
+	 * between darwin and everything else again? */
 	lis reg_CFUNC,CSYMBOL(pthread_getspecific)@h
 	ori reg_CFUNC,reg_CFUNC,CSYMBOL(pthread_getspecific)@l
 	mtctr reg_CFUNC
@@ -228,8 +373,13 @@ x:
 	li reg_L1,0
 	li reg_L2,0
 	li reg_LIP,0
+#ifdef LISP_FEATURE_DARWIN
+	lis reg_NULL,hi16(NIL)
+	ori reg_NULL,reg_NULL,lo16(NIL)
+#else
 	lis reg_NULL,NIL@h
 	ori reg_NULL,reg_NULL,NIL@l
+#endif
 	/* Turn on pseudo-atomic */
 
 	BEGIN_PSEUDO_ATOMIC
@@ -258,8 +408,13 @@ x:
 	lwz reg_A3,12(reg_CFP)
 
 	/* Calculate LRA */
+#ifdef LISP_FEATURE_DARWIN
+	lis reg_LRA,ha16(lra)
+	addi reg_LRA,reg_LRA,lo16(lra)
+#else
 	lis reg_LRA,lra@h
 	ori reg_LRA,reg_LRA,lra@l
+#endif
 	addi reg_LRA,reg_LRA,OTHER_POINTER_LOWTAG
 
 	/* Function is an indirect closure */
@@ -364,12 +519,22 @@ lra:
 
 	mr reg_NL3,reg_NARGS
 
+#ifdef LISP_FEATURE_DARWIN
+	/* PowerOpen (i.e. OS X) requires the callee address in r12
+           (a.k.a. CFUNC), so move it back there, too. */
+	mfctr reg_CFUNC
+#endif
         /* Into C we go. */
 	bctrl
 
 	/* Re-establish NIL */
+#ifdef LISP_FEATURE_DARWIN
+	lis reg_NULL,hi16(NIL)
+	ori reg_NULL,reg_NULL,lo16(NIL)
+#else
 	lis reg_NULL,NIL@h
 	ori reg_NULL,reg_NULL,NIL@l
+#endif
 	/* And reg_ZERO */
 	li reg_ZERO,0
 
diff --git src/runtime/ppc-darwin-os.c src/runtime/ppc-darwin-os.c
new file mode 100644
index 000000000..9258e273b
--- /dev/null
+++ src/runtime/ppc-darwin-os.c
@@ -0,0 +1,142 @@
+/*
+ * This is the PowerPC/Darwin incarnation of arch-dependent
+ * OS-dependent routines. See also "bsdos.c".
+ */
+
+/*
+ * This software is part of the SBCL system. See the README file for
+ * more information.
+ *
+ * This software is derived from the CMU CL system, which was
+ * written at Carnegie Mellon University and released into the
+ * public domain. The software is in the public domain and is
+ * provided with absolutely no warranty. See the COPYING and CREDITS
+ * files for more information.
+ */
+
+#include "sbcl.h"
+#include "globals.h"
+#include "runtime.h"
+#include <signal.h>
+#include <ucontext.h>
+#include <limits.h>
+#include <mach-o/dyld.h>
+#include "arch.h"
+#include "interr.h"                     /* for declaration of lose */
+
+#ifdef LISP_FEATURE_SB_THREAD
+#error "Define threading support functions"
+#else
+int arch_os_thread_init(struct thread *thread) {
+    return 1;                   /* success */
+}
+int arch_os_thread_cleanup(struct thread *thread) {
+    return 1;                   /* success */
+}
+#endif
+
+os_context_register_t   *
+os_context_register_addr(os_context_t *context, int offset)
+{
+    ppc_ss_struct_t *state = &context->uc_mcontext->PPC_DARWIN_REGIFY(ss);
+    switch(offset) {
+    case 0:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r0);
+    case 1:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r1);
+    case 2:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r2);
+    case 3:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r3);
+    case 4:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r4);
+    case 5:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r5);
+    case 6:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r6);
+    case 7:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r7);
+    case 8:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r8);
+    case 9:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r9);
+    case 10:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r10);
+    case 11:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r11);
+    case 12:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r12);
+    case 13:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r13);
+    case 14:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r14);
+    case 15:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r15);
+    case 16:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r16);
+    case 17:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r17);
+    case 18:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r18);
+    case 19:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r19);
+    case 20:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r20);
+    case 21:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r21);
+    case 22:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r22);
+    case 23:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r23);
+    case 24:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r24);
+    case 25:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r25);
+    case 26:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r26);
+    case 27:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r27);
+    case 28:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r28);
+    case 29:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r29);
+    case 30:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r30);
+    case 31:
+        return (os_context_register_t *) &state->PPC_DARWIN_REGIFY(r31);
+    case 41:
+        /* PT_DAR */
+        return (os_context_register_t *) &context->uc_mcontext->PPC_DARWIN_REGIFY(es).PPC_DARWIN_REGIFY(dar);
+    case 42:
+        /* PT_DSISR */
+        return (os_context_register_t *) &context->uc_mcontext->PPC_DARWIN_REGIFY(es).PPC_DARWIN_REGIFY(dsisr);
+    default:
+        lose("bad offset to os_context_register_addr");
+    }
+}
+
+os_context_register_t *
+os_context_lr_addr(os_context_t *context)
+{
+    return (os_context_register_t *) &context->uc_mcontext->PPC_DARWIN_REGIFY(ss).PPC_DARWIN_REGIFY(lr);
+}
+
+os_context_register_t *
+os_context_ctr_addr(os_context_t *context)
+{
+    return (os_context_register_t *) &context->uc_mcontext->PPC_DARWIN_REGIFY(ss).PPC_DARWIN_REGIFY(ctr);
+}
+
+os_context_register_t *
+os_context_cr_addr(os_context_t *context)
+{
+    return (os_context_register_t *) &context->uc_mcontext->PPC_DARWIN_REGIFY(ss).PPC_DARWIN_REGIFY(cr);
+}
+
+void
+os_flush_icache(os_vm_address_t address, os_vm_size_t length)
+{
+    /* see ppc-arch.c */
+    ppc_flush_icache(address,length);
+}
+
diff --git src/runtime/ppc-darwin-os.h src/runtime/ppc-darwin-os.h
new file mode 100644
index 000000000..36ec9d4d2
--- /dev/null
+++ src/runtime/ppc-darwin-os.h
@@ -0,0 +1,29 @@
+#ifndef _PPC_DARWIN_OS_H
+#define _PPC_DARWIN_OS_H
+
+#include "darwin-os.h"
+
+typedef unsigned int os_context_register_t;
+#include "arch-os-generic.inc"
+
+/* On OS X 10.5, the field names for the thread state have changed and
+ * now are prepended with __. Use some #define hackery to deal with
+ * this.
+ */
+#if __DARWIN_UNIX03
+
+#define PPC_DARWIN_REGIFY(foo) __ ## foo
+
+typedef ppc_thread_state_t ppc_ss_struct_t;
+
+#else
+
+#define PPC_DARWIN_REGIFY(foo) foo
+
+typedef ppc_saved_state_t ppc_ss_struct_t;
+
+#endif /* __DARWIN_UNIX03 */
+
+#define OS_CONTEXT_PC(context) context->uc_mcontext->PPC_DARWIN_REGIFY(ss).PPC_DARWIN_REGIFY(srr0)
+
+#endif /* _PPC_DARWIN_OS_H */
diff --git src/runtime/ppc-lispregs.h src/runtime/ppc-lispregs.h
index 35815eedc..02074728d 100644
--- src/runtime/ppc-lispregs.h
+++ src/runtime/ppc-lispregs.h
@@ -1,5 +1,15 @@
+#if defined LISP_FEATURE_DARWIN
+#if defined __ASSEMBLER__
+#define REG(num) r##num
+#define FREG(num) f##num
+#else
 #define REG(num) num
 #define FREG(num) num
+#endif
+#else
+#define REG(num) num
+#define FREG(num) num
+#endif
 
 #define NREGS 32
 
@@ -15,8 +25,13 @@
 #define reg_NL6       REG(9)    /* Last (7th) FF param */
 #define reg_FDEFN     REG(10)   /* was NL7 until recently -dan */
 #define reg_NARGS     REG(11)
+#ifdef LISP_FEATURE_DARWIN
+#define reg_CFUNC     REG(12)   /* Silly to blow a reg on FF-name */
+#define reg_NFP       REG(13)   /* Lisp may save around FF-call */
+#else
 #define reg_NFP       REG(12)   /* Lisp may save around FF-call */
 #define reg_CFUNC     REG(13)   /* Silly to blow a reg on FF-name */
+#endif
 #define reg_BSP       REG(14)   /* Binding stack pointer */
 #define reg_CFP       REG(15)   /* Control/value stack frame pointer */
 #define reg_CSP       REG(16)   /* Control/value stack top */
diff --git src/runtime/ppc64-lispregs.h src/runtime/ppc64-lispregs.h
index e0c31f7cd..7fefc085e 100644
--- src/runtime/ppc64-lispregs.h
+++ src/runtime/ppc64-lispregs.h
@@ -1,5 +1,15 @@
+#if defined LISP_FEATURE_DARWIN
+#if defined __ASSEMBLER__
+#define REG(num) r##num
+#define FREG(num) f##num
+#else
 #define REG(num) num
 #define FREG(num) num
+#endif
+#else
+#define REG(num) num
+#define FREG(num) num
+#endif
 
 #define NREGS 32
 
diff --git tests/float.pure.lisp tests/float.pure.lisp
index 8ed76998c..914d874c7 100644
--- tests/float.pure.lisp
+++ tests/float.pure.lisp
@@ -136,6 +136,7 @@
             :fails-on (or (and :arm64 (not :darwin))
                           :arm
                           (and :ppc :openbsd)
+                          (and :ppc :darwin)
                           (and :x86 :netbsd)))
   (assert-error
    (sb-sys:without-interrupts
@@ -157,6 +158,7 @@
             :fails-on (or (and :arm64 (not :darwin))
                           :arm
                           (and :ppc :openbsd)
+                          (and :ppc :darwin)
                           (and :x86 :netbsd)))
   (assert-error
    (sb-sys:without-interrupts
diff --git tests/foreign-stack-alignment.impure.lisp tests/foreign-stack-alignment.impure.lisp
index bd505938d..23b431f3e 100644
--- tests/foreign-stack-alignment.impure.lisp
+++ tests/foreign-stack-alignment.impure.lisp
@@ -34,7 +34,8 @@
 (defvar *required-alignment*
   (or #+arm 8
       #+mips 8
-      #+ppc 8
+      #+(and ppc darwin) 16
+      #+(and ppc (not darwin)) 8
       #+(or arm64 x86 x86-64 riscv ppc64) 16
       #+sparc 8
       (error "Unknown platform")))
diff --git tests/test-funs.lisp tests/test-funs.lisp
index 784c7815a..6bb6f7d0c 100644
--- tests/test-funs.lisp
+++ tests/test-funs.lisp
@@ -37,7 +37,7 @@
         (start-time (get-internal-real-time)))
     (declare (special test-util::*deferred-test-forms*))
     (makunbound 'test-util::*deferred-test-forms*)
-    (let ((*features* (append *features* #+(and (or arm arm64) (not darwin))
+    (let ((*features* (append *features* #+(and (or arm arm64) (not (and darwin ppc)))
                                          (unless (getf (sb-int:get-floating-point-modes) :traps)
                                            '(:no-float-traps))
                                          sb-impl:+internal-features+)))
-- 
2.41.0

