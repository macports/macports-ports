Only in .: 106changes.patch
--- ./libcxxabi/src/CMakeLists.txt	2025-01-14 02:41:02.000000000 -0700
+++ ./libcxxabi/src/CMakeLists.txt	2025-07-08 10:51:06.000000000 -0600
@@ -227,7 +227,11 @@
     export_symbols("${file}")
     # -reexported_symbols_list is only available on Apple platforms
     if (APPLE)
-      target_link_libraries(cxxabi-reexports INTERFACE "-Wl,-reexported_symbols_list,${file}")
+      if (NOT MIN_OSX_VERSION VERSION_LESS "10.7")
+        target_link_libraries(cxxabi-reexports INTERFACE "-Wl,-reexported_symbols_list,${file}")
+      else()
+        target_link_libraries(cxxabi-reexports INTERFACE "-Wl,-reexport_library,/usr/lib/libc++abi.dylib")
+      endif()
     endif()
   endfunction()
 
diff -ur ./compiler-rt/cmake/config-ix.cmake ./compiler-rt/cmake/config-ix.cmake
--- ./compiler-rt/cmake/config-ix.cmake 2025-07-05 16:37:37.000000000 -0600
+++ ./compiler-rt/cmake/config-ix.cmake 2025-01-14 02:41:02.000000000 -0700
@@ -476,11 +476,6 @@
       set(MIN_OSX_VERSION ${DEFAULT_SANITIZER_MIN_OSX_VERSION})
    endif()

-    # Note: In order to target x86_64h on OS X the minimum deployment target must
-    # be 10.8 or higher.
-    if(MIN_OSX_VERSION VERSION_LESS "10.7")
-      message(FATAL_ERROR "macOS deployment target '${SANITIZER_MIN_OSX_VERSION}' is too old.")
-    endif()
   endif()

   set(SANITIZER_MIN_OSX_VERSION "${MIN_OSX_VERSION}" CACHE STRING
--- ./compiler-rt/cmake/builtin-config-ix.cmake	2025-07-14 18:51:28.000000000 -0600
+++ ./compiler-rt/cmake/builtin-config-ix.cmake	2025-07-14 18:51:31.000000000 -0600
@@ -122,7 +122,7 @@
   endfunction()
 
   set(DARWIN_EMBEDDED_PLATFORMS)
-  set(DARWIN_osx_BUILTIN_MIN_VER 10.7)
+  set(DARWIN_osx_BUILTIN_MIN_VER 10.6)
   set(DARWIN_osx_BUILTIN_MIN_VER_FLAG
       -mmacosx-version-min=${DARWIN_osx_BUILTIN_MIN_VER})
   set(DARWIN_osx_BUILTIN_ALL_POSSIBLE_ARCHS ${X86} ${X86_64})
diff -ur ./libunwind/src/AddressSpace.hpp ./libunwind/src/AddressSpace.hpp
--- ./libunwind/src/AddressSpace.hpp	2025-01-14 02:41:02.000000000 -0700
+++ ./libunwind/src/AddressSpace.hpp	2025-07-05 08:53:08.000000000 -0600
@@ -56,15 +56,67 @@
 
   struct dyld_unwind_sections
   {
+#ifdef __LP64__
+    const struct mach_header_64* mh;
+#else
     const struct mach_header*   mh;
+#endif
     const void*                 dwarf_section;
+#ifdef __LP64__
+    uint64_t                    dwarf_section_length;
+#else
     uintptr_t                   dwarf_section_length;
+#endif
     const void*                 compact_unwind_section;
+#ifdef __LP64__
+    uint64_t                    compact_unwind_section_length;
+#else
     uintptr_t                   compact_unwind_section_length;
+#endif
   };
 
-  // In 10.7.0 or later, libSystem.dylib implements this function.
-  extern "C" bool _dyld_find_unwind_sections(void *, dyld_unwind_sections *);
+#if (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) \
+    && (__MAC_OS_X_VERSION_MIN_REQUIRED >= 1070)) \
+|| defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+// In 10.7.0 or later, libSystem.dylib implements this function.
+extern "C" bool _dyld_find_unwind_sections(void *, dyld_unwind_sections *);
+#else
+       #include <mach-o/getsect.h>
+// In 10.6.x and earlier, we need to implement this functionality. Note
+// that this requires a newer version of libmacho (from cctools) than is
+// present in libSystem on 10.6.x (for getsectiondata).
+static inline bool _dyld_find_unwind_sections(void* addr,
+    dyld_unwind_sections* info) {
+  // Find mach-o image containing address.
+  Dl_info dlinfo;
+  if (!dladdr(addr, &dlinfo))
+    return false;
+#if __LP64__
+  const struct mach_header_64 *mh = (const struct mach_header_64 *)dlinfo.dli_fbase;
+  // Initialize the return struct
+  info->mh = (const struct mach_header_64 *)mh;
+  info->dwarf_section = getsectdatafromheader_64(mh, "__TEXT", "__eh_frame", &info->dwarf_section_length);
+  info->compact_unwind_section = getsectdatafromheader_64(mh, "__TEXT", "__unwind_info", &info->compact_unwind_section_length);
+#else
+  const struct mach_header *mh = (const struct mach_header *)dlinfo.dli_fbase;
+  // Initialize the return struct
+  info->mh = (const struct mach_header *)mh;
+  info->dwarf_section = getsectdatafromheader(mh, "__TEXT", "__eh_frame", &info->dwarf_section_length);
+  info->compact_unwind_section = getsectdatafromheader(mh, "__TEXT", "__unwind_info", &info->compact_unwind_section_length);
+#endif
+
+
+  if (!info->dwarf_section) {
+    info->dwarf_section_length = 0;
+  }
+
+  if (!info->compact_unwind_section) {
+    info->compact_unwind_section_length = 0;
+  }
+
+  return true;
+}
+#endif
 
 namespace libunwind {
   bool findDynamicUnwindSections(void *, unw_dynamic_unwind_sections *);
--- ./libcxxabi/src/cxa_thread_atexit.cpp	2025-01-14 02:41:02.000000000 -0700
+++ ./libcxxabi/src/cxa_thread_atexit.cpp	2025-07-15 06:47:48.000000000 -0600
@@ -21,15 +21,14 @@
 
   using Dtor = void(*)(void*);
 
-  extern "C"
 #ifndef HAVE___CXA_THREAD_ATEXIT_IMPL
+  extern "C"
   // A weak symbol is used to detect this function's presence in the C library
   // at runtime, even if libc++ is built against an older libc
   _LIBCXXABI_WEAK
-#endif
-  int __cxa_thread_atexit_impl(Dtor, void*, void*);
 
-#ifndef HAVE___CXA_THREAD_ATEXIT_IMPL
+  void* __cxa_thread_atexit_impl;
+  void* __cxa_thread_atexit_impl = 0;
 
 namespace {
   // This implementation is used if the C library does not provide
@@ -113,7 +112,8 @@
     return __cxa_thread_atexit_impl(dtor, obj, dso_symbol);
 #else
     if (__cxa_thread_atexit_impl) {
-      return __cxa_thread_atexit_impl(dtor, obj, dso_symbol);
+      return reinterpret_cast<int (*)(Dtor, void*, void*)>(
+         __cxa_thread_atexit_impl)(dtor, obj, dso_symbol);
     } else {
       // Initialize the dtors std::__libcpp_tls_key (uses __cxa_guard_*() for
       // one-time initialization and __cxa_atexit() for destruction)
