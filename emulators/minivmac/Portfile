# $Id$

PortSystem              1.0

name                    minivmac
conflicts               minivmac-devel
set my_name             minivmac
version                 3.0.4
revision                3
categories              emulators aqua
maintainers             ryandesign
license                 GPLv2
homepage                http://minivmac.sourceforge.net/
use_zip                 yes
platforms               macosx
universal_variant       no
use_parallel_build      yes
dist_subdir             ${my_name}

description \
    a Mac 128K, Mac 512K, Mac 512KE, Mac Plus and Mac SE emulator

long_description \
    Mini vMac is a Macintosh emulator. It emulates the earliest Macs, \
    from the original Mac 128K (built 1984-85) to the Mac SE (1987-1990). \
    The default is to emulate a Mac Plus (1986-1990)\; this is also \
    the best-tested and therefore recommended emulation.

master_sites \
    sourceforge:${my_name}:minivmac \
    http://download.info.apple.com/Apple_Support_Area/Apple_Software_Updates/English-North_American/Macintosh/System/Older_System/System_7.0.x/:apple

distname                                    ${my_name}-${version}
set my_src                                  ${distname}.src
set my_src_distfile                         ${my_src}.zip
set my_bootstrap_distfile                   ${my_name}-3.1.2-umch.bin.tgz
set my_clipin                               clipin-1.1.0
set my_clipin_distfile                      ${my_clipin}.zip
set my_icons                                icnsosx-1.0.0
set my_icons_distfile                       ${my_icons}.zip
set my_system_disk_container                System_7.0.1.smi
set my_system_disk_container_distfile       ${my_system_disk_container}.bin

distfiles \
    ${my_src_distfile}:minivmac \
    ${my_bootstrap_distfile}:minivmac \
    ${my_icons_distfile}:minivmac \
    ${my_clipin_distfile}:minivmac \
    ${my_system_disk_container_distfile}:apple

extract.only \
    ${my_src_distfile} \
    ${my_icons_distfile} \
    ${my_clipin_distfile}

checksums \
    ${my_src_distfile} \
        md5     ab308459e98bd5103ad8bbb7dd158eb6 \
        sha1    ff99aa72da0868a5306631f0d06ae190cbd2a03a \
        rmd160  b8f1f5269d21835ff3e9e428da12a7b6c224e60e \
    ${my_bootstrap_distfile} \
        md5     53239cda5f1827fcc00d9254ee1ee9e0 \
        sha1    d6c16c541d72241cabafcbb94eec7c198e8b1670 \
        rmd160  f3925e194c59f704f6fac391609ccc72dd12c718 \
    ${my_icons_distfile} \
        md5     2af006506de7549be14f94317918d59a \
        sha1    4ef79bb56b988fedfeb82a8b6cafd8066f5bbab2 \
        rmd160  cef6d7d7578464538d0042b0d98379ae7f18fab7 \
    ${my_clipin_distfile} \
        md5     e094de97d1c6c214a80fb74895124c3e \
        sha1    725f622ad6681c77e7f9f4a64d05ac1d6a103beb \
        rmd160  5699b56c8db62b2568c8de88b6d419180b1fb73d \
    ${my_system_disk_container_distfile} \
        md5     8a4776350b15b5a516cdf7dd18e27290 \
        sha1    d4c8b8653de9c7a9b2594dd6126ec7120e3e2e9e \
        rmd160  89fc3780c9c5d575a8da4068dc810c1f56c70211

depends_extract \
    port:macutil \
    bin:expect:expect

set my_app_dir          "${applications_dir}/Mini vMac"
set my_rom_dir          "~/Library/Preferences/Gryphel/mnvm_rom"
set my_bootstrap_app    "Mini vMac.app"
set my_rom_file         vMac.ROM
set my_base_options     "-maintainer MacPorts -homepage http://www.macports.org/ -cl -eol unx -nex -im 1"
set my_archs            {}

options my_variations
default my_variations   {}

# The universal variant is disabled until MacPorts 1.8.2 is released
# and this port is upgraded to version 3.1.x final.
if {0} {
variant universal {
    configure.universal_args
    configure.universal_archs ppc i386
    set my_archs ${configure.universal_archs}
}
}
if {![variant_isset universal]} {
    switch ${os.arch} {
        powerpc {
            configure.build_arch ppc
        }
        default {
            configure.build_arch ${os.arch}
        }
    }
    set my_archs ${configure.build_arch}
}

pre-fetch {
    set my_real_rom_dir [exec osascript ${filespath}/readalias.applescript [file normalize ${my_rom_dir}]]
    if {![file exists ${my_real_rom_dir}/${my_rom_file}] && ![file exists ${my_app_dir}/${my_rom_file}]} {
        ui_msg "****************************************************************"
        ui_msg "To build Mini vMac, you will need a ROM file from a Macintosh"
        ui_msg "Plus or 512Ke. And to run it, you need a ROM file from the type"
        ui_msg "of Mac you want to emulate. ROM files are not included with this"
        ui_msg "package because they are copyrighted Apple software."
        ui_msg "To create a ROM file, download the CopyRoms program from"
        ui_msg "${homepage}extras/copyroms.html"
        ui_msg "and transfer it to a real physical early Macintosh that you own."
        ui_msg "Run the CopyRoms program there, then transfer the ROM file back"
        ui_msg "to this Mac and put it in ${my_rom_dir}"
        ui_msg "(which can be an alias or symlink if desired) or"
        ui_msg "${my_app_dir}."
        ui_msg "****************************************************************"
        return -code error "${my_rom_file} not found"
    }
}

worksrcdir              stuff
extract.mkdir           yes

post-extract {
    # Decode the system disk container image.
    my_system "sh ${filespath}/demacbinary.sh ${distpath}/${my_system_disk_container_distfile} ${worksrcpath}"
    
    # Copy the Disk Tools image from the container image.
    set my_system_disk_container_mount [my_attach_disk_image ${worksrcpath}/${my_system_disk_container}]
    file copy "${my_system_disk_container_mount}/Disk Tools.image" "${worksrcpath}/Disk Tools.dsk"
    my_detach_disk_image ${my_system_disk_container_mount}
    
    # Use the .img extension for the source disk image so that we can mount it on Mac OS X later.
    file rename ${worksrcpath}/${my_src}/${my_src}.dsk ${worksrcpath}/${my_src}/${my_src}.img
    
    # Unrestrict the permissions on the source disk image so the Build program
    # can write its output to it.
    file attributes ${worksrcpath}/${my_src}/${my_src}.img -permissions 0777
    
    # Extract the bootstrap version of Mini vMac.
    my_system "tar -x -z -C ${worksrcpath} -f ${distpath}/${my_bootstrap_distfile}"
    
    # Make the data directory, where Mini vMac looks for the files it needs.
    set my_mnvm_dat "${worksrcpath}/${my_bootstrap_app}/Contents/mnvm_dat"
    file mkdir ${my_mnvm_dat}
    
    # Symlink the ROM file into the data directory.
    ln -s ${my_app_dir}/${my_rom_file} ${my_mnvm_dat}
    
    # Symlink the disk images into the data directory with sequentially-numbered
    # names so Mini vMac will find them and automatically mount them.
    ln -s "${worksrcpath}/Disk Tools.dsk" "${my_mnvm_dat}/disk1.dsk"
    ln -s ${worksrcpath}/${my_src}/${my_src}.img "${my_mnvm_dat}/disk2.dsk"
    ln -s ${worksrcpath}/${my_clipin}/${my_clipin}.dsk "${my_mnvm_dat}/disk3.dsk"
}

pre-configure {
    set i 0
    foreach my_arch ${my_archs} {
        set my_target [my_arch_to_target ${my_arch}]
        foreach {my_machine my_variation_options} ${my_variations} {
            if {${i} > 0} {
                configure.args-append {\;}
            }
            configure.args-append \
                ${my_base_options} \
                -t ${my_target} \
                ${my_variation_options} \
                -n ${version}_${revision}-[strsed [string tolower ${my_machine}] {g/[^a-z0-9_-]//}]-${my_target}
            incr i
        }
    }
    
    # Launch Mini vMac so the configure script can talk to it.
    my_system "open '${worksrcpath}/${my_bootstrap_app}'"
}

configure.cmd           osascript
configure.pre_args      ${filespath}/configure.applescript

build.dir               ${workpath}/variations

post-configure {
    file mkdir ${build.dir}
    set my_variation_dirs ""
    set my_src_disk_mount [my_attach_disk_image ${worksrcpath}/${my_src}/${my_src}.img]
    foreach my_arch ${my_archs} {
        file mkdir ${build.dir}/${my_arch}
        set my_target [my_arch_to_target ${my_arch}]
        foreach {my_machine unused} ${my_variations} {
            set my_src_dir ${my_src_disk_mount}/output/${version}_${revision}-[strsed [string tolower ${my_machine}] {g/[^a-z0-9_-]//}]-${my_target}
            if {[file isdirectory ${my_src_dir}]} {
                set my_variation_dir ${my_arch}/${my_machine}
                set my_variation_dirs "${my_variation_dirs} [strsed ${my_variation_dir} {g/ /\\\\ /}]"
                
                # Get the configured source code.
                file copy ${my_src_dir} ${build.dir}/${my_variation_dir}
                
                # Use the right compiler.
                reinplace "s|gcc|${configure.cc}|g" ${build.dir}/${my_variation_dir}/Makefile
                
                # Remove references to SDKs -- the 10.4u SDK is not installed by default on 10.6
                # and even if you install it manually it does not work here.
                reinplace -E {s|-isysroot /Developer/SDKs/[^ ]+||g} ${build.dir}/${my_variation_dir}/Makefile
            }
        }
    }
    my_detach_disk_image ${my_src_disk_mount}
    
    # Set up the global Makefile.
    xinstall ${filespath}/Makefile.in ${build.dir}/Makefile
    reinplace "s|@SUBDIRS@|${my_variation_dirs}|" ${build.dir}/Makefile
    
    # If no variation directoriess were produced by configuration, either the flags we
    # passed in were bad, or the automation script got out of sync with the emulator;
    # if the latter, the delays in configure.applescript may need to be adjusted.
    if {"" == ${my_variation_dirs}} {
        return -code error "configuration failed!"
    }
}

set my_share_dir        ${prefix}/share/${my_name}

post-build {
    # To save space, keep only a single copy of the Resources directory.
    set i 0
    foreach my_arch ${my_archs} {
        set my_target [my_arch_to_target ${my_arch}]
        foreach {my_machine unused} ${my_variations} {
            if {[variant_isset universal]} {
                reinplace "s|${my_target}|umch|" ${build.dir}/${my_arch}/${my_machine}/minivmac.app/Contents/Info.plist
            }
            set my_resources_dir ${build.dir}/${my_arch}/${my_machine}/minivmac.app/Contents/Resources
            if {0 == ${i}} {
                move ${my_resources_dir} ${build.dir}
            } else {
                delete ${my_resources_dir}
            }
            ln -s ${my_share_dir}/Resources ${my_resources_dir}
            incr i
        }
    }
    
    # Install the prettier icons.
    eval xinstall -m 644 [glob ${worksrcpath}/${my_icons}/icons/*.icns] ${build.dir}/Resources
}

destroot {
    # Install the global Resources directory.
    xinstall -d ${destroot}${my_share_dir}
    copy ${build.dir}/Resources ${destroot}${my_share_dir}
    
    # Install the programs.
    foreach my_arch ${my_archs} {
        if {[variant_isset universal]} {
            set my_dest ${workpath}/pre-dest/${my_arch}
        } else {
            set my_dest ${destroot}
        }
        xinstall -d ${my_dest}${my_app_dir}
        foreach {my_machine unused} ${my_variations} {
            copy ${build.dir}/${my_arch}/${my_machine}/minivmac.app \
                "${my_dest}${my_app_dir}/Mini vMac ${my_machine}.app"
        }
    }
    if {[variant_isset universal]} {
        merge ${workpath}/pre-dest
    }
}

if { ![variant_isset mac128k] && ![variant_isset mac512k] && ![variant_isset mac512ke] && ![variant_isset macse] } {
    default_variants +macplus
}

variant mac128k conflicts mac512k mac512ke macplus macse description {Emulate a Macintosh with 128K RAM and 2 drives} {
    my_variations-append {128K} {-m 128K}
}

variant mac512k conflicts mac128k mac512ke macplus macse description {Emulate a Macintosh 512K with 512K RAM and 2 drives} {
    my_variations-append {512K} {-m 512K}
}

variant mac512ke conflicts mac128k mac512k macplus macse description {Emulate a Macintosh 512Ke with 512K RAM and 6 drives} {
    my_variations-append {512Ke} {-m 512Ke}
}

variant macplus conflicts mac128k mac512k mac512ke macse description {Emulate a Macintosh Plus with 4 MB RAM and 6 drives} {
    my_variations-append {Plus} {-m Plus}
}

variant macse conflicts mac128k mac512k mac512ke macplus description {Emulate a Macintosh SE with 4 MB RAM and 6 drives} {
    my_variations-append {SE} {-m SE}
}

# Converts normal arch names into Mini vMac target names.
proc my_arch_to_target {arch} {
    switch ${arch} {
        i386 {
            return imch
        }
        ppc {
            return mach
        }
        default {
            return -code error "unsupported architecture ${arch}"
        }
    }
}

# Mounts a disk image.
proc my_attach_disk_image {disk_image} {
    global my_name filespath
    set mountpoint [mkdtemp "/tmp/${my_name}.XXXXXXXX"]
    # Use this expect script instead of using hdiutil directly, because the
    # system disk image has a license agreement we must agree to.
    my_system "expect ${filespath}/attach.exp '${disk_image}' '${mountpoint}'"
    return ${mountpoint}
}

# Unmounts a disk image.
proc my_detach_disk_image {mountpoint} {
    my_system "hdiutil detach ${mountpoint} -force"
    file delete -force ${mountpoint}
}

proc my_system {cmd} {
     ui_debug ${cmd}
     system ${cmd}
}

livecheck.type          regex
livecheck.url           ${homepage}download.html
livecheck.regex         ${my_name}-(\[0-9.\]+)\\.src
