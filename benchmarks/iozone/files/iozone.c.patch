--- iozone.c.orig	2025-08-22 14:04:11
+++ iozone.c	2025-08-27 15:51:15
@@ -105,28 +105,13 @@ extern  int h_errno; /* imported for errors */
    syscall(__NR_sched_setaffinity, (pid_t)pid, (size_t)size, (void *)cpuset)
 #endif
 
-#if defined(HAVE_ANSIC_C) && defined(linux)
+#if defined(HAVE_ANSIC_C) && (defined(linux) || defined(IOZ_macosx))
 #include <stdlib.h>
 #include <sys/wait.h>
 #endif
 
-#ifdef HAVE_PROTO
-#include "proto.h"
-#else
-int atoi(const char *);
-int close(int);
-int unlink(const char *);
-int * main(int, char **);
-#if !defined(linux)
-int wait();
-#endif
-int fsync(int);
-void srand48(long int);
-long lrand48(void);
-void create_list();
 void init_by_array64(unsigned long long *, unsigned long long );
 unsigned long long genrand64_int64(void);
-#endif
 
 #ifdef ASYNC_IO
 #include <aio.h>
@@ -392,7 +377,7 @@ THISVERSION,
 #include <string.h>
 #endif
 
-#if defined(linux)
+#if defined(linux) || defined(IOZ_macosx)
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
@@ -439,6 +424,8 @@ typedef long long off64_t;
 #endif
 #endif
 
+void create_list(long long *list_off, long long reclen, off64_t numrecs64);
+
 #ifdef __AIX__
 #include <fcntl.h>
 #endif
@@ -1063,8 +1050,8 @@ static void pit( int, struct timeval *);
 /*int pit_gettimeofday( struct timeval *, struct timezone *, char *, char *);*/
 static int openSckt( const char *, const char *, unsigned int );
 static void pit( int, struct timeval *);
-void auto_test();		/* perform automatic test series  */
-static double time_so_far();	/* time since start of program    */
+void auto_test(void);		/* perform automatic test series  */
+static double time_so_far(void);	/* time since start of program    */
 static void update_burst_sleep(int, long long, double *);
 #ifndef NO_THREADS
 static void count_burst(double* burst_acc_time_sec, long long stream_id);
@@ -1080,9 +1067,7 @@ sighandler_t signal_handler(void);	/* clean up if user
 #else
 sighandler_t signal_handler(void);	/* clean up if user interrupts us */
 #endif
-void auto_test(void);
 void throughput_test(void);
-static double time_so_far(void);
 void fetchit(char *,long long);
 long long verify_buffer(volatile char *,long long, off64_t, long long, unsigned long long, char );
 void purgeit(char *,long long);
@@ -1315,13 +1300,8 @@ ssize_t pread64(int, void *, size_t, off_t);
 ssize_t pread64(int, void *, size_t, off_t);
 /*ssize_t pread64(); */
 #endif
-#if !defined(linux)
-char *getenv();
-char *inet_ntoa();
-int system();
-#endif
 
-#ifdef ASYNC_IO
+struct cache;
 void async_init(struct cache **,int, int);
 int async_read_no_copy(struct cache *, long long, char **, off64_t, long long, long long, off64_t, long long);
 void async_release(struct cache *gc);
@@ -1329,31 +1309,20 @@ size_t async_write_no_copy(struct cache *,long long ,c
 int async_read(struct cache *, long long , char *, off64_t, long long, long long, off64_t, long long);
 size_t async_write(struct cache *,long long, char *, long long, off64_t, long long);
 size_t async_write_no_copy(struct cache *,long long ,char *,long long,long long,long long,char *);
-#else
-long long *gc=0;
-void async_init(long long **,int,int);
-int async_read();
-int async_read_no_copy();
-size_t async_write();
-size_t async_write_no_copy();
-void async_release();
-#endif
 void do_float(int, double, int, int);
 int create_xls(char *);
 void close_xls(int);
 void do_label(int, char *, int, int );
 int mylockf(int, int, int);
 int mylockr(int,int, int, off64_t, off64_t);
-int rand(void);
-void srand(unsigned int);
 int get_client_info(void);
-void exit(int);
 void find_remote_shell(char *);
 void find_external_mon(char *,char *);
 void start_monitor(char *);
 void stop_monitor(char *);
-void takeoff_cache();
-void del_cache();
+struct cache_ent;
+void takeoff_cache(struct cache *, struct cache_ent *);
+void del_cache(struct cache *);
 void fill_area(long long *, long long *, long long);
 void fill_buffer(char *,long long ,long long ,char, long long );
 void store_value(off64_t);
@@ -1452,7 +1421,6 @@ long long get_traj();
 void *(thread_join)();
 void disrupt();
 long long get_traj();
-void init_file_sizes();
 off64_t get_next_file_size();
 void add_file_size();
 void init_record_sizes();
@@ -1879,8 +1847,6 @@ long long rest_val;
  * Sort of... Full prototypes break non-ansi C compilers. No protos is 
  * a bit sloppy, so the compromise is this.
  */
-void stop_child_send();
-void stop_child_send();
 void child_send(char *, struct master_command *, int );
 void compressible_rand_16_int(int *);
 void new_touch_dedup(char *, int);
@@ -1893,7 +1859,7 @@ int negatives, positives;
 /****************************************************************/
 int negatives, positives;
 
-int * main(int argc,char **argv) 
+int main(int argc,char **argv)
 {
 
 	long long fileindx,i,tval;
@@ -9196,6 +9162,7 @@ long long *data1,*data2;
 				}
 			  }
 			}
+#ifdef ASYNC_IO
 			if(async_flag)
 			{
 				if(no_copy_flag)
@@ -9203,6 +9170,7 @@ long long *data1,*data2;
 				end_async(gc);
 				gc=0;
 			}
+#endif
 			buffer1=0;
 			if(hist_summary)
 			{
@@ -9677,6 +9645,7 @@ long long *data1, *data2;
 				}
 			  }
 			}
+#ifdef ASYNC_IO
 			if(async_flag)
 			{
 				if(no_copy_flag)
@@ -9684,6 +9653,7 @@ long long *data1, *data2;
 				end_async(gc);
 				gc=0;
 			}
+#endif
 			if(rlocking)
 			{
 				lock_offset=I_LSEEK(fd,0,SEEK_CUR);
@@ -10140,6 +10110,7 @@ long long *data1,*data2;
 				}
 			   }
 			}
+#ifdef ASYNC_IO
 			if(async_flag)
 			{
 				if(no_copy_flag)
@@ -10147,6 +10118,7 @@ long long *data1,*data2;
 				end_async(gc);
 				gc=0;
 			}
+#endif
 			if(rlocking)
 			{
 				mylockr((int) fd, (int) 0, (int)1,
@@ -10744,8 +10716,10 @@ printf("Read_Stride\n");
 		}
 		else
 		{
+#ifdef ASYNC_IO
 			if(async_flag)
 				async_init(&gc,fd,direct_flag);
+#endif
 			if(async_flag)
 			{
 			    if(no_copy_flag)
@@ -10792,6 +10766,7 @@ printf("Read_Stride\n");
 			   }
 			}
 		}
+#ifdef ASYNC_IO
 		if(async_flag)
 		{
 			if(no_copy_flag)
@@ -10799,6 +10774,7 @@ printf("Read_Stride\n");
 			end_async(gc);
 			gc=0;
 		}
+#endif
 			
 		/* This is a bit tricky.  The goal is to read with a stride through
 		   the file. The problem is that you need to touch all of the file
@@ -15528,6 +15504,7 @@ thread_read_test(x)
 			   }
 		   }
 		}
+#ifdef ASYNC_IO
 		if(async_flag)
 		{
 			if(no_copy_flag)
@@ -15535,6 +15512,7 @@ thread_read_test(x)
 			end_async(gc);
 			gc=0;
 		}
+#endif
 		read_so_far+=reclen/1024;
 		r_traj_bytes_completed+=reclen;
 		r_traj_ops_completed++;
@@ -16093,6 +16071,7 @@ thread_pread_test(x)
 			   }
 		   }
 		}
+#ifdef ASYNC_IO
 		if(async_flag)
 		{
 			if(no_copy_flag)
@@ -16100,6 +16079,7 @@ thread_pread_test(x)
 			end_async(gc);
 			gc=0;
 		}
+#endif
 		read_so_far+=reclen/1024;
 		r_traj_bytes_completed+=reclen;
 		r_traj_ops_completed++;
@@ -16708,6 +16688,7 @@ thread_rread_test(x)
 			}
 		   }
 		}
+#ifdef ASYNC_IO
 		if(async_flag)
 		{
 			if(no_copy_flag)
@@ -16715,6 +16696,7 @@ thread_rread_test(x)
 			end_async(gc);
 			gc=0;
 		}
+#endif
 		re_read_so_far+=reclen/1024;
 		r_traj_bytes_completed+=reclen;
 		r_traj_ops_completed++;
@@ -17287,6 +17269,7 @@ thread_reverse_read_test(x)
 			  lock_offset, reclen);
 		}
 		current_position+=reclen;
+#ifdef ASYNC_IO
 		if(async_flag)
 		{
 			if(no_copy_flag)
@@ -17294,6 +17277,7 @@ thread_reverse_read_test(x)
 			end_async(gc);
 			gc=0;
 		}
+#endif
 		t_offset = (off64_t)reclen*2;
 		if (!(h_flag || k_flag || mmapflag))
 		{
@@ -17821,6 +17805,7 @@ thread_stride_read_test(x)
 			}
 		   }
 		}
+#ifdef ASYNC_IO
 		if(async_flag)
 		{
 			if(no_copy_flag)
@@ -17828,6 +17813,7 @@ thread_stride_read_test(x)
 			end_async(gc);
 			gc=0;
 		}
+#endif
 		if(current_position + (stride * reclen) >= (numrecs64 * reclen)-reclen) 
 		{
 			current_position=0;
@@ -18571,6 +18557,7 @@ void *x;
 			}
 		   }
 		}
+#ifdef ASYNC_IO
 		if(async_flag)
 		{
 			if(no_copy_flag)
@@ -18578,6 +18565,7 @@ void *x;
 			end_async(gc);
 			gc=0;
 		}
+#endif
 		ranread_so_far+=reclen/1024;
 		if(*stop_flag)
 		{
@@ -20124,37 +20112,37 @@ int
 
 #ifndef ASYNC_IO
 int
-async_read()
+async_read(struct cache *a, long long b, char *c, off64_t d, long long e, long long f, off64_t g, long long h)
 {
 	printf("Your system does not support async I/O\n");
 	exit(169);
 }
 size_t
-async_write_no_copy()
+async_write_no_copy(struct cache *gc,long long fd,char *buffer,long long size,long long offset,long long depth,char *free_addr)
 {
 	printf("Your system does not support async I/O\n");
 	exit(170);
 }
 size_t
-async_write()
+async_write(struct cache *a,long long b, char *c, long long d, off64_t e, long long f)
 {
 	printf("Your system does not support async I/O\n");
 	exit(171);
 }
 void
-async_init()
+async_init(struct cache **a, int b, int c)
 {
 	printf("Your system does not support async I/O\n");
 	exit(172);
 }
 int
-async_read_no_copy()
+async_read_no_copy(struct cache *a, long long b, char **c, off64_t d, long long e, long long f, off64_t g, long long h)
 {
 	printf("Your system does not support async I/O\n");
 	exit(172);
 }
 void
-async_release()
+async_release(struct cache *gc)
 {
 	printf("Your system does not support async I/O\n");
 	exit(173);
